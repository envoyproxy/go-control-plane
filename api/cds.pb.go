// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: api/cds.proto

package api

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "istio.io/gogo-genproto/googleapis/google/api"
import google_protobuf2 "github.com/gogo/protobuf/types"
import google_protobuf4 "github.com/gogo/protobuf/types"
import google_protobuf "github.com/gogo/protobuf/types"
import _ "github.com/lyft/protoc-gen-validate/validate"
import _ "github.com/gogo/protobuf/gogoproto"

import time "time"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// Refer to :ref:`service discovery type <arch_overview_service_discovery_types>`
// for an explanation on each type.
type Cluster_DiscoveryType int32

const (
	// Refer to the :ref:`static discovery type<arch_overview_service_discovery_types_static>`
	// for an explanation.
	Cluster_STATIC Cluster_DiscoveryType = 0
	// Refer to the :ref:`strict DNS discovery
	// type<arch_overview_service_discovery_types_strict_dns>`
	// for an explanation.
	Cluster_STRICT_DNS Cluster_DiscoveryType = 1
	// Refer to the :ref:`logical DNS discovery
	// type<arch_overview_service_discovery_types_logical_dns>`
	// for an explanation.
	Cluster_LOGICAL_DNS Cluster_DiscoveryType = 2
	// Refer to the :ref:`service discovery type<arch_overview_service_discovery_types_sds>`
	// for an explanation.
	Cluster_EDS Cluster_DiscoveryType = 3
	// Refer to the :ref:`original destination discovery
	// type<arch_overview_service_discovery_types_original_destination>`
	// for an explanation.
	Cluster_ORIGINAL_DST Cluster_DiscoveryType = 4
)

var Cluster_DiscoveryType_name = map[int32]string{
	0: "STATIC",
	1: "STRICT_DNS",
	2: "LOGICAL_DNS",
	3: "EDS",
	4: "ORIGINAL_DST",
}
var Cluster_DiscoveryType_value = map[string]int32{
	"STATIC":       0,
	"STRICT_DNS":   1,
	"LOGICAL_DNS":  2,
	"EDS":          3,
	"ORIGINAL_DST": 4,
}

func (x Cluster_DiscoveryType) String() string {
	return proto.EnumName(Cluster_DiscoveryType_name, int32(x))
}
func (Cluster_DiscoveryType) EnumDescriptor() ([]byte, []int) { return fileDescriptorCds, []int{0, 0} }

// Refer to :ref:`load balancer type <arch_overview_load_balancing_types>` architecture
// overview section for information on each type.
type Cluster_LbPolicy int32

const (
	// Refer to the :ref:`round robin load balancing
	// policy<arch_overview_load_balancing_types_round_robin>`
	// for an explanation.
	Cluster_ROUND_ROBIN Cluster_LbPolicy = 0
	// Refer to the :ref:`least request load balancing
	// policy<arch_overview_load_balancing_types_least_request>`
	// for an explanation.
	Cluster_LEAST_REQUEST Cluster_LbPolicy = 1
	// Refer to the :ref:`ring hash load balancing
	// policy<arch_overview_load_balancing_types_ring_hash>`
	// for an explanation.
	Cluster_RING_HASH Cluster_LbPolicy = 2
	// Refer to the :ref:`random load balancing
	// policy<arch_overview_load_balancing_types_random>`
	// for an explanation.
	Cluster_RANDOM Cluster_LbPolicy = 3
	// Refer to the :ref:`original destination load balancing
	// policy<arch_overview_load_balancing_types_original_destination>`
	// for an explanation.
	Cluster_ORIGINAL_DST_LB Cluster_LbPolicy = 4
)

var Cluster_LbPolicy_name = map[int32]string{
	0: "ROUND_ROBIN",
	1: "LEAST_REQUEST",
	2: "RING_HASH",
	3: "RANDOM",
	4: "ORIGINAL_DST_LB",
}
var Cluster_LbPolicy_value = map[string]int32{
	"ROUND_ROBIN":     0,
	"LEAST_REQUEST":   1,
	"RING_HASH":       2,
	"RANDOM":          3,
	"ORIGINAL_DST_LB": 4,
}

func (x Cluster_LbPolicy) String() string {
	return proto.EnumName(Cluster_LbPolicy_name, int32(x))
}
func (Cluster_LbPolicy) EnumDescriptor() ([]byte, []int) { return fileDescriptorCds, []int{0, 1} }

// When V4_ONLY is selected, the DNS resolver will only perform a lookup for
// addresses in the IPv4 family. If V6_ONLY is selected, the DNS resolver will
// only perform a lookup for addresses in the IPv6 family. If AUTO is
// specified, the DNS resolver will first perform a lookup for addresses in
// the IPv6 family and fallback to a lookup for addresses in the IPv4 family.
// For cluster types other than
// :ref:`STRICT_DNS<envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS>` and
// :ref:`LOGICAL_DNS<envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS>`,
// this setting is
// ignored.
type Cluster_DnsLookupFamily int32

const (
	Cluster_AUTO    Cluster_DnsLookupFamily = 0
	Cluster_V4_ONLY Cluster_DnsLookupFamily = 1
	Cluster_V6_ONLY Cluster_DnsLookupFamily = 2
)

var Cluster_DnsLookupFamily_name = map[int32]string{
	0: "AUTO",
	1: "V4_ONLY",
	2: "V6_ONLY",
}
var Cluster_DnsLookupFamily_value = map[string]int32{
	"AUTO":    0,
	"V4_ONLY": 1,
	"V6_ONLY": 2,
}

func (x Cluster_DnsLookupFamily) String() string {
	return proto.EnumName(Cluster_DnsLookupFamily_name, int32(x))
}
func (Cluster_DnsLookupFamily) EnumDescriptor() ([]byte, []int) { return fileDescriptorCds, []int{0, 2} }

type Cluster_ClusterProtocolSelection int32

const (
	// Cluster can only operate on one of the possible upstream protocols (HTTP1.1, HTTP2).
	// If :ref:`http2_protocol_options <envoy_api_field_Cluster.http2_protocol_options>` are
	// present, HTTP2 will be used, otherwise HTTP1.1 will be used.
	Cluster_USE_CONFIGURED_PROTOCOL Cluster_ClusterProtocolSelection = 0
	// Use HTTP1.1 or HTTP2, depending on which one is used on the downstream connection.
	Cluster_USE_DOWNSTREAM_PROTOCOL Cluster_ClusterProtocolSelection = 1
)

var Cluster_ClusterProtocolSelection_name = map[int32]string{
	0: "USE_CONFIGURED_PROTOCOL",
	1: "USE_DOWNSTREAM_PROTOCOL",
}
var Cluster_ClusterProtocolSelection_value = map[string]int32{
	"USE_CONFIGURED_PROTOCOL": 0,
	"USE_DOWNSTREAM_PROTOCOL": 1,
}

func (x Cluster_ClusterProtocolSelection) String() string {
	return proto.EnumName(Cluster_ClusterProtocolSelection_name, int32(x))
}
func (Cluster_ClusterProtocolSelection) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorCds, []int{0, 3}
}

// If NO_FALLBACK is selected, a result
// equivalent to no healthy hosts is reported. If ANY_ENDPOINT is selected,
// any cluster endpoint may be returned (subject to policy, health checks,
// etc). If DEFAULT_SUBSET is selected, load balancing is performed over the
// endpoints matching the values from the default_subset field.
type Cluster_LbSubsetConfig_LbSubsetFallbackPolicy int32

const (
	Cluster_LbSubsetConfig_NO_FALLBACK    Cluster_LbSubsetConfig_LbSubsetFallbackPolicy = 0
	Cluster_LbSubsetConfig_ANY_ENDPOINT   Cluster_LbSubsetConfig_LbSubsetFallbackPolicy = 1
	Cluster_LbSubsetConfig_DEFAULT_SUBSET Cluster_LbSubsetConfig_LbSubsetFallbackPolicy = 2
)

var Cluster_LbSubsetConfig_LbSubsetFallbackPolicy_name = map[int32]string{
	0: "NO_FALLBACK",
	1: "ANY_ENDPOINT",
	2: "DEFAULT_SUBSET",
}
var Cluster_LbSubsetConfig_LbSubsetFallbackPolicy_value = map[string]int32{
	"NO_FALLBACK":    0,
	"ANY_ENDPOINT":   1,
	"DEFAULT_SUBSET": 2,
}

func (x Cluster_LbSubsetConfig_LbSubsetFallbackPolicy) String() string {
	return proto.EnumName(Cluster_LbSubsetConfig_LbSubsetFallbackPolicy_name, int32(x))
}
func (Cluster_LbSubsetConfig_LbSubsetFallbackPolicy) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorCds, []int{0, 2, 0}
}

type Cluster struct {
	// Supplies the name of the cluster which must be unique across all clusters.
	// The cluster name is used when emitting
	// :ref:`statistics <config_cluster_manager_cluster_stats>`.
	// Any ``:`` in the cluster name will be converted to ``_`` when emitting statistics.
	// By default, the maximum length of a cluster name is limited to 60
	// characters. This limit can be increased by setting the
	// :option:`--max-obj-name-len` command line argument to the desired value.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// The :ref:`service discovery type <arch_overview_service_discovery_types>`
	// to use for resolving the cluster.
	Type Cluster_DiscoveryType `protobuf:"varint,2,opt,name=type,proto3,enum=envoy.api.v2.Cluster_DiscoveryType" json:"type,omitempty"`
	// Configuration to use for EDS updates for the Cluster.
	EdsClusterConfig *Cluster_EdsClusterConfig `protobuf:"bytes,3,opt,name=eds_cluster_config,json=edsClusterConfig" json:"eds_cluster_config,omitempty"`
	// The timeout for new network connections to hosts in the cluster.
	ConnectTimeout time.Duration `protobuf:"bytes,4,opt,name=connect_timeout,json=connectTimeout,stdduration" json:"connect_timeout"`
	// Soft limit on size of the clusterâ€™s connections read and write buffers. If
	// unspecified, an implementation defined default is applied (1MiB).
	PerConnectionBufferLimitBytes *google_protobuf.UInt32Value `protobuf:"bytes,5,opt,name=per_connection_buffer_limit_bytes,json=perConnectionBufferLimitBytes" json:"per_connection_buffer_limit_bytes,omitempty"`
	// The :ref:`load balancer type <arch_overview_load_balancing_types>` to use
	// when picking a host in the cluster.
	LbPolicy Cluster_LbPolicy `protobuf:"varint,6,opt,name=lb_policy,json=lbPolicy,proto3,enum=envoy.api.v2.Cluster_LbPolicy" json:"lb_policy,omitempty"`
	// If the service discovery type is
	// :ref:`STATIC<envoy_api_enum_value_Cluster.DiscoveryType.STATIC>`,
	// :ref:`STRICT_DNS<envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS>`
	// or :ref:`LOGICAL_DNS<envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS>`,
	// then hosts is required.
	Hosts []*Address `protobuf:"bytes,7,rep,name=hosts" json:"hosts,omitempty"`
	// Optional :ref:`active health checking <arch_overview_health_checking>`
	// configuration for the cluster. If no
	// configuration is specified no health checking will be done and all cluster
	// members will be considered healthy at all times.
	HealthChecks []*HealthCheck `protobuf:"bytes,8,rep,name=health_checks,json=healthChecks" json:"health_checks,omitempty"`
	// Optional maximum requests for a single upstream connection. This parameter
	// is respected by both the HTTP/1.1 and HTTP/2 connection pool
	// implementations. If not specified, there is no limit. Setting this
	// parameter to 1 will effectively disable keep alive.
	MaxRequestsPerConnection *google_protobuf.UInt32Value `protobuf:"bytes,9,opt,name=max_requests_per_connection,json=maxRequestsPerConnection" json:"max_requests_per_connection,omitempty"`
	// Optional :ref:`circuit breaking <arch_overview_circuit_break>` for the cluster.
	CircuitBreakers *CircuitBreakers `protobuf:"bytes,10,opt,name=circuit_breakers,json=circuitBreakers" json:"circuit_breakers,omitempty"`
	// The TLS configuration for connections to the upstream cluster. If no TLS
	// configuration is specified, TLS will not be used for new connections.
	//
	// .. attention::
	//
	//   Server certificate verification is not enabled by default. Configure
	//   :ref:`trusted_ca<envoy_api_field_CertificateValidationContext.trusted_ca>` to enable
	//   verification.
	TlsContext *UpstreamTlsContext `protobuf:"bytes,11,opt,name=tls_context,json=tlsContext" json:"tls_context,omitempty"`
	// Additional options when handling HTTP1 requests.
	HttpProtocolOptions *Http1ProtocolOptions `protobuf:"bytes,13,opt,name=http_protocol_options,json=httpProtocolOptions" json:"http_protocol_options,omitempty"`
	// Even if default HTTP2 protocol options are desired, this field must be
	// set so that Envoy will assume that the upstream supports HTTP/2 when
	// making new HTTP connection pool connections. Currently, Envoy only
	// supports prior knowledge for upstream connections. Even if TLS is used
	// with ALPN, `http2_protocol_options` must be specified. As an aside this allows HTTP/2
	// connections to happen over plain text.
	Http2ProtocolOptions *Http2ProtocolOptions `protobuf:"bytes,14,opt,name=http2_protocol_options,json=http2ProtocolOptions" json:"http2_protocol_options,omitempty"`
	// If the DNS refresh rate is specified and the cluster type is either
	// :ref:`STRICT_DNS<envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS>`,
	// or :ref:`LOGICAL_DNS<envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS>`,
	// this value is used as the clusterâ€™s DNS refresh
	// rate. If this setting is not specified, the value defaults to 5000. For
	// cluster types other than
	// :ref:`STRICT_DNS<envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS>`
	// and :ref:`LOGICAL_DNS<envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS>`
	// this setting is ignored.
	DnsRefreshRate *time.Duration `protobuf:"bytes,16,opt,name=dns_refresh_rate,json=dnsRefreshRate,stdduration" json:"dns_refresh_rate,omitempty"`
	// The DNS IP address resolution policy. If this setting is not specified, the
	// value defaults to
	// :ref:`AUTO<envoy_api_enum_value_Cluster.DnsLookupFamily.AUTO>`.
	DnsLookupFamily Cluster_DnsLookupFamily `protobuf:"varint,17,opt,name=dns_lookup_family,json=dnsLookupFamily,proto3,enum=envoy.api.v2.Cluster_DnsLookupFamily" json:"dns_lookup_family,omitempty"`
	// If DNS resolvers are specified and the cluster type is either
	// :ref:`STRICT_DNS<envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS>`,
	// or :ref:`LOGICAL_DNS<envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS>`,
	// this value is used to specify the clusterâ€™s dns resolvers.
	// If this setting is not specified, the value defaults to the default
	// resolver, which uses /etc/resolv.conf for configuration. For cluster types
	// other than
	// :ref:`STRICT_DNS<envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS>`
	// and :ref:`LOGICAL_DNS<envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS>`
	// this setting is ignored.
	DnsResolvers []*Address `protobuf:"bytes,18,rep,name=dns_resolvers,json=dnsResolvers" json:"dns_resolvers,omitempty"`
	// If specified, outlier detection will be enabled for this upstream cluster.
	// Each of the configuration values can be overridden via
	// :ref:`runtime values <config_cluster_manager_cluster_runtime_outlier_detection>`.
	OutlierDetection *Cluster_OutlierDetection `protobuf:"bytes,19,opt,name=outlier_detection,json=outlierDetection" json:"outlier_detection,omitempty"`
	// The interval for removing stale hosts from a cluster type
	// :ref:`ORIGINAL_DST<envoy_api_enum_value_Cluster.DiscoveryType.ORIGINAL_DST>`.
	// Hosts are considered stale if they have not been used
	// as upstream destinations during this interval. New hosts are added
	// to original destination clusters on demand as new connections are
	// redirected to Envoy, causing the number of hosts in the cluster to
	// grow over time. Hosts that are not stale (they are actively used as
	// destinations) are kept in the cluster, which allows connections to
	// them remain open, saving the latency that would otherwise be spent
	// on opening new connections. If this setting is not specified, the
	// value defaults to 5000ms. For cluster types other than
	// :ref:`ORIGINAL_DST<envoy_api_enum_value_Cluster.DiscoveryType.ORIGINAL_DST>`
	// this setting is ignored.
	CleanupInterval *time.Duration `protobuf:"bytes,20,opt,name=cleanup_interval,json=cleanupInterval,stdduration" json:"cleanup_interval,omitempty"`
	// Optional configuration used to bind newly established upstream connections.
	// This overrides any bind_config specified in the bootstrap proto.
	// If the addres and port are empty, no bind will be performed.
	UpstreamBindConfig *BindConfig `protobuf:"bytes,21,opt,name=upstream_bind_config,json=upstreamBindConfig" json:"upstream_bind_config,omitempty"`
	// Configuration for load balancing subsetting.
	LbSubsetConfig *Cluster_LbSubsetConfig `protobuf:"bytes,22,opt,name=lb_subset_config,json=lbSubsetConfig" json:"lb_subset_config,omitempty"`
	// Optional configuration for the load balancing algorithm selected by
	// LbPolicy. Currently only
	// :ref:`RING_HASH<envoy_api_enum_value_Cluster.LbPolicy.RING_HASH>`
	// has additional configuration options.
	// Specifying ring_hash_lb_config without setting the LbPolicy to
	// :ref:`RING_HASH<envoy_api_enum_value_Cluster.LbPolicy.RING_HASH>`
	// will generate an error at runtime.
	//
	// Types that are valid to be assigned to LbConfig:
	//	*Cluster_RingHashLbConfig_
	LbConfig isCluster_LbConfig `protobuf_oneof:"lb_config"`
	// See :ref:`base.TransportSocket<envoy_api_msg_TransportSocket>` description.
	TransportSocket *TransportSocket `protobuf:"bytes,24,opt,name=transport_socket,json=transportSocket" json:"transport_socket,omitempty"`
	// The Metadata field can be used to provide additional information about the
	// cluster. It can be used for stats, logging, and varying filter behavior.
	// Fields should use reverse DNS notation to denote which entity within Envoy
	// will need the information. For instance, if the metadata is intended for
	// the Router filter, the filter name should be specified as *envoy.router*.
	Metadata          *Metadata                        `protobuf:"bytes,25,opt,name=metadata" json:"metadata,omitempty"`
	ProtocolSelection Cluster_ClusterProtocolSelection `protobuf:"varint,26,opt,name=protocol_selection,json=protocolSelection,proto3,enum=envoy.api.v2.Cluster_ClusterProtocolSelection" json:"protocol_selection,omitempty"`
}

func (m *Cluster) Reset()                    { *m = Cluster{} }
func (m *Cluster) String() string            { return proto.CompactTextString(m) }
func (*Cluster) ProtoMessage()               {}
func (*Cluster) Descriptor() ([]byte, []int) { return fileDescriptorCds, []int{0} }

type isCluster_LbConfig interface {
	isCluster_LbConfig()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Cluster_RingHashLbConfig_ struct {
	RingHashLbConfig *Cluster_RingHashLbConfig `protobuf:"bytes,23,opt,name=ring_hash_lb_config,json=ringHashLbConfig,oneof"`
}

func (*Cluster_RingHashLbConfig_) isCluster_LbConfig() {}

func (m *Cluster) GetLbConfig() isCluster_LbConfig {
	if m != nil {
		return m.LbConfig
	}
	return nil
}

func (m *Cluster) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Cluster) GetType() Cluster_DiscoveryType {
	if m != nil {
		return m.Type
	}
	return Cluster_STATIC
}

func (m *Cluster) GetEdsClusterConfig() *Cluster_EdsClusterConfig {
	if m != nil {
		return m.EdsClusterConfig
	}
	return nil
}

func (m *Cluster) GetConnectTimeout() time.Duration {
	if m != nil {
		return m.ConnectTimeout
	}
	return 0
}

func (m *Cluster) GetPerConnectionBufferLimitBytes() *google_protobuf.UInt32Value {
	if m != nil {
		return m.PerConnectionBufferLimitBytes
	}
	return nil
}

func (m *Cluster) GetLbPolicy() Cluster_LbPolicy {
	if m != nil {
		return m.LbPolicy
	}
	return Cluster_ROUND_ROBIN
}

func (m *Cluster) GetHosts() []*Address {
	if m != nil {
		return m.Hosts
	}
	return nil
}

func (m *Cluster) GetHealthChecks() []*HealthCheck {
	if m != nil {
		return m.HealthChecks
	}
	return nil
}

func (m *Cluster) GetMaxRequestsPerConnection() *google_protobuf.UInt32Value {
	if m != nil {
		return m.MaxRequestsPerConnection
	}
	return nil
}

func (m *Cluster) GetCircuitBreakers() *CircuitBreakers {
	if m != nil {
		return m.CircuitBreakers
	}
	return nil
}

func (m *Cluster) GetTlsContext() *UpstreamTlsContext {
	if m != nil {
		return m.TlsContext
	}
	return nil
}

func (m *Cluster) GetHttpProtocolOptions() *Http1ProtocolOptions {
	if m != nil {
		return m.HttpProtocolOptions
	}
	return nil
}

func (m *Cluster) GetHttp2ProtocolOptions() *Http2ProtocolOptions {
	if m != nil {
		return m.Http2ProtocolOptions
	}
	return nil
}

func (m *Cluster) GetDnsRefreshRate() *time.Duration {
	if m != nil {
		return m.DnsRefreshRate
	}
	return nil
}

func (m *Cluster) GetDnsLookupFamily() Cluster_DnsLookupFamily {
	if m != nil {
		return m.DnsLookupFamily
	}
	return Cluster_AUTO
}

func (m *Cluster) GetDnsResolvers() []*Address {
	if m != nil {
		return m.DnsResolvers
	}
	return nil
}

func (m *Cluster) GetOutlierDetection() *Cluster_OutlierDetection {
	if m != nil {
		return m.OutlierDetection
	}
	return nil
}

func (m *Cluster) GetCleanupInterval() *time.Duration {
	if m != nil {
		return m.CleanupInterval
	}
	return nil
}

func (m *Cluster) GetUpstreamBindConfig() *BindConfig {
	if m != nil {
		return m.UpstreamBindConfig
	}
	return nil
}

func (m *Cluster) GetLbSubsetConfig() *Cluster_LbSubsetConfig {
	if m != nil {
		return m.LbSubsetConfig
	}
	return nil
}

func (m *Cluster) GetRingHashLbConfig() *Cluster_RingHashLbConfig {
	if x, ok := m.GetLbConfig().(*Cluster_RingHashLbConfig_); ok {
		return x.RingHashLbConfig
	}
	return nil
}

func (m *Cluster) GetTransportSocket() *TransportSocket {
	if m != nil {
		return m.TransportSocket
	}
	return nil
}

func (m *Cluster) GetMetadata() *Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *Cluster) GetProtocolSelection() Cluster_ClusterProtocolSelection {
	if m != nil {
		return m.ProtocolSelection
	}
	return Cluster_USE_CONFIGURED_PROTOCOL
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Cluster) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Cluster_OneofMarshaler, _Cluster_OneofUnmarshaler, _Cluster_OneofSizer, []interface{}{
		(*Cluster_RingHashLbConfig_)(nil),
	}
}

func _Cluster_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Cluster)
	// lb_config
	switch x := m.LbConfig.(type) {
	case *Cluster_RingHashLbConfig_:
		_ = b.EncodeVarint(23<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.RingHashLbConfig); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Cluster.LbConfig has unexpected type %T", x)
	}
	return nil
}

func _Cluster_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Cluster)
	switch tag {
	case 23: // lb_config.ring_hash_lb_config
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Cluster_RingHashLbConfig)
		err := b.DecodeMessage(msg)
		m.LbConfig = &Cluster_RingHashLbConfig_{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Cluster_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Cluster)
	// lb_config
	switch x := m.LbConfig.(type) {
	case *Cluster_RingHashLbConfig_:
		s := proto.Size(x.RingHashLbConfig)
		n += proto.SizeVarint(23<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Only valid when discovery type is EDS.
type Cluster_EdsClusterConfig struct {
	// Configuration for the source of EDS updates for this Cluster.
	EdsConfig *ConfigSource `protobuf:"bytes,1,opt,name=eds_config,json=edsConfig" json:"eds_config,omitempty"`
	// Optional alternative to cluster name to present to EDS. This does not
	// have the same restrictions as cluster name, i.e. it may be arbitrary
	// length.
	ServiceName string `protobuf:"bytes,2,opt,name=service_name,json=serviceName,proto3" json:"service_name,omitempty"`
}

func (m *Cluster_EdsClusterConfig) Reset()                    { *m = Cluster_EdsClusterConfig{} }
func (m *Cluster_EdsClusterConfig) String() string            { return proto.CompactTextString(m) }
func (*Cluster_EdsClusterConfig) ProtoMessage()               {}
func (*Cluster_EdsClusterConfig) Descriptor() ([]byte, []int) { return fileDescriptorCds, []int{0, 0} }

func (m *Cluster_EdsClusterConfig) GetEdsConfig() *ConfigSource {
	if m != nil {
		return m.EdsConfig
	}
	return nil
}

func (m *Cluster_EdsClusterConfig) GetServiceName() string {
	if m != nil {
		return m.ServiceName
	}
	return ""
}

// See the :ref:`architecture overview <arch_overview_outlier_detection>` for
// more information on outlier detection.
type Cluster_OutlierDetection struct {
	// The number of consecutive 5xx responses before a consecutive 5xx ejection
	// occurs. Defaults to 5.
	Consecutive_5Xx *google_protobuf.UInt32Value `protobuf:"bytes,1,opt,name=consecutive_5xx,json=consecutive5xx" json:"consecutive_5xx,omitempty"`
	// The time interval between ejection analysis sweeps. This can result in
	// both new ejections as well as hosts being returned to service. Defaults
	// to 10000ms or 10s.
	Interval *google_protobuf2.Duration `protobuf:"bytes,2,opt,name=interval" json:"interval,omitempty"`
	// The base time that a host is ejected for. The real time is equal to the
	// base time multiplied by the number of times the host has been ejected.
	// Defaults to 30000ms or 30s.
	BaseEjectionTime *google_protobuf2.Duration `protobuf:"bytes,3,opt,name=base_ejection_time,json=baseEjectionTime" json:"base_ejection_time,omitempty"`
	// The maximum % of an upstream cluster that can be ejected due to outlier
	// detection. Defaults to 10%.
	MaxEjectionPercent *google_protobuf.UInt32Value `protobuf:"bytes,4,opt,name=max_ejection_percent,json=maxEjectionPercent" json:"max_ejection_percent,omitempty"`
	// The % chance that a host will be actually ejected when an outlier status
	// is detected through consecutive 5xx. This setting can be used to disable
	// ejection or to ramp it up slowly. Defaults to 100.
	EnforcingConsecutive_5Xx *google_protobuf.UInt32Value `protobuf:"bytes,5,opt,name=enforcing_consecutive_5xx,json=enforcingConsecutive5xx" json:"enforcing_consecutive_5xx,omitempty"`
	// The % chance that a host will be actually ejected when an outlier status
	// is detected through success rate statistics. This setting can be used to
	// disable ejection or to ramp it up slowly. Defaults to 100.
	EnforcingSuccessRate *google_protobuf.UInt32Value `protobuf:"bytes,6,opt,name=enforcing_success_rate,json=enforcingSuccessRate" json:"enforcing_success_rate,omitempty"`
	// The number of hosts in a cluster that must have enough request volume to
	// detect success rate outliers. If the number of hosts is less than this
	// setting, outlier detection via success rate statistics is not performed
	// for any host in the cluster. Defaults to 5.
	SuccessRateMinimumHosts *google_protobuf.UInt32Value `protobuf:"bytes,7,opt,name=success_rate_minimum_hosts,json=successRateMinimumHosts" json:"success_rate_minimum_hosts,omitempty"`
	// The minimum number of total requests that must be collected in one
	// interval (as defined by the interval duration above) to include this host
	// in success rate based outlier detection. If the volume is lower than this
	// setting, outlier detection via success rate statistics is not performed
	// for that host. Defaults to 100.
	SuccessRateRequestVolume *google_protobuf.UInt32Value `protobuf:"bytes,8,opt,name=success_rate_request_volume,json=successRateRequestVolume" json:"success_rate_request_volume,omitempty"`
	// This factor is used to determine the ejection threshold for success rate
	// outlier ejection. The ejection threshold is the difference between the
	// mean success rate, and the product of this factor and the standard
	// deviation of the mean success rate: mean - (stdev *
	// success_rate_stdev_factor). This factor is divided by a thousand to get a
	// double. That is, if the desired factor is 1.9, the runtime value should
	// be 1900. Defaults to 1900.
	SuccessRateStdevFactor *google_protobuf.UInt32Value `protobuf:"bytes,9,opt,name=success_rate_stdev_factor,json=successRateStdevFactor" json:"success_rate_stdev_factor,omitempty"`
	// The number of consecutive gateway failures (502, 503, 504 status or
	// connection errors that are mapped to one of those status codes) before a
	// consecutive gateway failure ejection occurs. Defaults to 5.
	ConsecutiveGatewayFailure *google_protobuf.UInt32Value `protobuf:"bytes,10,opt,name=consecutive_gateway_failure,json=consecutiveGatewayFailure" json:"consecutive_gateway_failure,omitempty"`
	// The % chance that a host will be actually ejected when an outlier status
	// is detected through consecutive gateway failures. This setting can be
	// used to disable ejection or to ramp it up slowly. Defaults to 0.
	EnforcingConsecutiveGatewayFailure *google_protobuf.UInt32Value `protobuf:"bytes,11,opt,name=enforcing_consecutive_gateway_failure,json=enforcingConsecutiveGatewayFailure" json:"enforcing_consecutive_gateway_failure,omitempty"`
}

func (m *Cluster_OutlierDetection) Reset()                    { *m = Cluster_OutlierDetection{} }
func (m *Cluster_OutlierDetection) String() string            { return proto.CompactTextString(m) }
func (*Cluster_OutlierDetection) ProtoMessage()               {}
func (*Cluster_OutlierDetection) Descriptor() ([]byte, []int) { return fileDescriptorCds, []int{0, 1} }

func (m *Cluster_OutlierDetection) GetConsecutive_5Xx() *google_protobuf.UInt32Value {
	if m != nil {
		return m.Consecutive_5Xx
	}
	return nil
}

func (m *Cluster_OutlierDetection) GetInterval() *google_protobuf2.Duration {
	if m != nil {
		return m.Interval
	}
	return nil
}

func (m *Cluster_OutlierDetection) GetBaseEjectionTime() *google_protobuf2.Duration {
	if m != nil {
		return m.BaseEjectionTime
	}
	return nil
}

func (m *Cluster_OutlierDetection) GetMaxEjectionPercent() *google_protobuf.UInt32Value {
	if m != nil {
		return m.MaxEjectionPercent
	}
	return nil
}

func (m *Cluster_OutlierDetection) GetEnforcingConsecutive_5Xx() *google_protobuf.UInt32Value {
	if m != nil {
		return m.EnforcingConsecutive_5Xx
	}
	return nil
}

func (m *Cluster_OutlierDetection) GetEnforcingSuccessRate() *google_protobuf.UInt32Value {
	if m != nil {
		return m.EnforcingSuccessRate
	}
	return nil
}

func (m *Cluster_OutlierDetection) GetSuccessRateMinimumHosts() *google_protobuf.UInt32Value {
	if m != nil {
		return m.SuccessRateMinimumHosts
	}
	return nil
}

func (m *Cluster_OutlierDetection) GetSuccessRateRequestVolume() *google_protobuf.UInt32Value {
	if m != nil {
		return m.SuccessRateRequestVolume
	}
	return nil
}

func (m *Cluster_OutlierDetection) GetSuccessRateStdevFactor() *google_protobuf.UInt32Value {
	if m != nil {
		return m.SuccessRateStdevFactor
	}
	return nil
}

func (m *Cluster_OutlierDetection) GetConsecutiveGatewayFailure() *google_protobuf.UInt32Value {
	if m != nil {
		return m.ConsecutiveGatewayFailure
	}
	return nil
}

func (m *Cluster_OutlierDetection) GetEnforcingConsecutiveGatewayFailure() *google_protobuf.UInt32Value {
	if m != nil {
		return m.EnforcingConsecutiveGatewayFailure
	}
	return nil
}

// Optionally divide the endpoints in this cluster into subsets defined by
// endpoint metadata and selected by route and weighted cluster metadata.
type Cluster_LbSubsetConfig struct {
	// The behavior used when no endpoint subset matches the selected route's
	// metadata. The value defaults to
	// :ref:`NO_FALLBACK<envoy_api_enum_value_Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.NO_FALLBACK>`.
	FallbackPolicy Cluster_LbSubsetConfig_LbSubsetFallbackPolicy `protobuf:"varint,1,opt,name=fallback_policy,json=fallbackPolicy,proto3,enum=envoy.api.v2.Cluster_LbSubsetConfig_LbSubsetFallbackPolicy" json:"fallback_policy,omitempty"`
	// Specifies the default subset of endpoints used during fallback if
	// fallback_policy is
	// :ref:`DEFAULT_SUBSET<envoy_api_enum_value_Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.DEFAULT_SUBSET>`.
	// Each field in default_subset is
	// compared to the matching LbEndpoint.Metadata under the *envoy.lb*
	// namespace. It is valid for no hosts to match, in which case the behavior
	// is the same as a fallback_policy of
	// :ref:`NO_FALLBACK<envoy_api_enum_value_Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.NO_FALLBACK>`.
	DefaultSubset *google_protobuf4.Struct `protobuf:"bytes,2,opt,name=default_subset,json=defaultSubset" json:"default_subset,omitempty"`
	// For each entry, LbEndpoint.Metadata's
	// *envoy.lb* namespace is traversed and a subset is created for each unique
	// combination of key and value. For example:
	//
	// .. code-block:: json
	//
	//   { "subset_selectors": [
	//       { "keys": [ "version" ] },
	//       { "keys": [ "stage", "hardware_type" ] }
	//   ]}
	//
	// A subset is matched when the metadata from the selected route and
	// weighted cluster contains the same keys and values as the subset's
	// metadata. The same host may appear in multiple subsets.
	SubsetSelectors []*Cluster_LbSubsetConfig_LbSubsetSelector `protobuf:"bytes,3,rep,name=subset_selectors,json=subsetSelectors" json:"subset_selectors,omitempty"`
}

func (m *Cluster_LbSubsetConfig) Reset()                    { *m = Cluster_LbSubsetConfig{} }
func (m *Cluster_LbSubsetConfig) String() string            { return proto.CompactTextString(m) }
func (*Cluster_LbSubsetConfig) ProtoMessage()               {}
func (*Cluster_LbSubsetConfig) Descriptor() ([]byte, []int) { return fileDescriptorCds, []int{0, 2} }

func (m *Cluster_LbSubsetConfig) GetFallbackPolicy() Cluster_LbSubsetConfig_LbSubsetFallbackPolicy {
	if m != nil {
		return m.FallbackPolicy
	}
	return Cluster_LbSubsetConfig_NO_FALLBACK
}

func (m *Cluster_LbSubsetConfig) GetDefaultSubset() *google_protobuf4.Struct {
	if m != nil {
		return m.DefaultSubset
	}
	return nil
}

func (m *Cluster_LbSubsetConfig) GetSubsetSelectors() []*Cluster_LbSubsetConfig_LbSubsetSelector {
	if m != nil {
		return m.SubsetSelectors
	}
	return nil
}

// Specifications for subsets.
type Cluster_LbSubsetConfig_LbSubsetSelector struct {
	// List of keys to match with the weighted cluster metadata.
	Keys []string `protobuf:"bytes,1,rep,name=keys" json:"keys,omitempty"`
}

func (m *Cluster_LbSubsetConfig_LbSubsetSelector) Reset() {
	*m = Cluster_LbSubsetConfig_LbSubsetSelector{}
}
func (m *Cluster_LbSubsetConfig_LbSubsetSelector) String() string { return proto.CompactTextString(m) }
func (*Cluster_LbSubsetConfig_LbSubsetSelector) ProtoMessage()    {}
func (*Cluster_LbSubsetConfig_LbSubsetSelector) Descriptor() ([]byte, []int) {
	return fileDescriptorCds, []int{0, 2, 0}
}

func (m *Cluster_LbSubsetConfig_LbSubsetSelector) GetKeys() []string {
	if m != nil {
		return m.Keys
	}
	return nil
}

// Specific configuration for the :ref:`RingHash<arch_overview_load_balancing_types_ring_hash>`
// load balancing policy.
type Cluster_RingHashLbConfig struct {
	// Minimum hash ring size, i.e. total virtual nodes. A larger size
	// will provide better request distribution since each host in the
	// cluster will have more virtual nodes. Defaults to 1024. In the case
	// that total number of hosts is greater than the minimum, each host will
	// be allocated a single virtual node.
	MinimumRingSize *google_protobuf.UInt64Value `protobuf:"bytes,1,opt,name=minimum_ring_size,json=minimumRingSize" json:"minimum_ring_size,omitempty"`
	// Deprecated settings from v1 config.
	DeprecatedV1 *Cluster_RingHashLbConfig_DeprecatedV1 `protobuf:"bytes,2,opt,name=deprecated_v1,json=deprecatedV1" json:"deprecated_v1,omitempty"`
}

func (m *Cluster_RingHashLbConfig) Reset()                    { *m = Cluster_RingHashLbConfig{} }
func (m *Cluster_RingHashLbConfig) String() string            { return proto.CompactTextString(m) }
func (*Cluster_RingHashLbConfig) ProtoMessage()               {}
func (*Cluster_RingHashLbConfig) Descriptor() ([]byte, []int) { return fileDescriptorCds, []int{0, 3} }

func (m *Cluster_RingHashLbConfig) GetMinimumRingSize() *google_protobuf.UInt64Value {
	if m != nil {
		return m.MinimumRingSize
	}
	return nil
}

func (m *Cluster_RingHashLbConfig) GetDeprecatedV1() *Cluster_RingHashLbConfig_DeprecatedV1 {
	if m != nil {
		return m.DeprecatedV1
	}
	return nil
}

type Cluster_RingHashLbConfig_DeprecatedV1 struct {
	// Defaults to true, meaning that std::hash is used to hash hosts onto
	// the ketama ring. std::hash can vary by platform. For this reason,
	// Envoy will eventually use `xxHash <https://github.com/Cyan4973/xxHash>`_
	// by default. This field exists for
	// migration purposes and will eventually be deprecated. Set it to false
	// to use `xxHash <https://github.com/Cyan4973/xxHash>`_ now.
	UseStdHash *google_protobuf.BoolValue `protobuf:"bytes,1,opt,name=use_std_hash,json=useStdHash" json:"use_std_hash,omitempty"`
}

func (m *Cluster_RingHashLbConfig_DeprecatedV1) Reset()         { *m = Cluster_RingHashLbConfig_DeprecatedV1{} }
func (m *Cluster_RingHashLbConfig_DeprecatedV1) String() string { return proto.CompactTextString(m) }
func (*Cluster_RingHashLbConfig_DeprecatedV1) ProtoMessage()    {}
func (*Cluster_RingHashLbConfig_DeprecatedV1) Descriptor() ([]byte, []int) {
	return fileDescriptorCds, []int{0, 3, 0}
}

func (m *Cluster_RingHashLbConfig_DeprecatedV1) GetUseStdHash() *google_protobuf.BoolValue {
	if m != nil {
		return m.UseStdHash
	}
	return nil
}

// An extensible structure containing the address Envoy should bind to when
// establishing upstream connections.
type UpstreamBindConfig struct {
	// The address Envoy should bind to when establishing upstream connections.
	SourceAddress *Address `protobuf:"bytes,1,opt,name=source_address,json=sourceAddress" json:"source_address,omitempty"`
}

func (m *UpstreamBindConfig) Reset()                    { *m = UpstreamBindConfig{} }
func (m *UpstreamBindConfig) String() string            { return proto.CompactTextString(m) }
func (*UpstreamBindConfig) ProtoMessage()               {}
func (*UpstreamBindConfig) Descriptor() ([]byte, []int) { return fileDescriptorCds, []int{1} }

func (m *UpstreamBindConfig) GetSourceAddress() *Address {
	if m != nil {
		return m.SourceAddress
	}
	return nil
}

// :ref:`Circuit breaking<arch_overview_circuit_break>` settings can be
// specified individually for each defined priority.
type CircuitBreakers struct {
	// If multiple :ref:`Thresholds<envoy_api_msg_CircuitBreakers.Thresholds>`
	// are defined with the same :ref:`RoutingPriority<envoy_api_enum_RoutingPriority>`,
	// the first one in the list is used. If no Thresholds is defined for a given
	// :ref:`RoutingPriority<envoy_api_enum_RoutingPriority>`, the default values
	// are used.
	Thresholds []*CircuitBreakers_Thresholds `protobuf:"bytes,1,rep,name=thresholds" json:"thresholds,omitempty"`
}

func (m *CircuitBreakers) Reset()                    { *m = CircuitBreakers{} }
func (m *CircuitBreakers) String() string            { return proto.CompactTextString(m) }
func (*CircuitBreakers) ProtoMessage()               {}
func (*CircuitBreakers) Descriptor() ([]byte, []int) { return fileDescriptorCds, []int{2} }

func (m *CircuitBreakers) GetThresholds() []*CircuitBreakers_Thresholds {
	if m != nil {
		return m.Thresholds
	}
	return nil
}

// A Thresholds defines CircuitBreaker settings for a
// :ref:`RoutingPriority<envoy_api_enum_RoutingPriority>`.
type CircuitBreakers_Thresholds struct {
	// The :ref:`RoutingPriority<envoy_api_enum_RoutingPriority>`
	// the specified CircuitBreaker settings apply to.
	// [#comment:TODO(htuch): add (validate.rules).enum.defined_only = true once
	// https://github.com/lyft/protoc-gen-validate/issues/42 is resolved.]
	Priority RoutingPriority `protobuf:"varint,1,opt,name=priority,proto3,enum=envoy.api.v2.RoutingPriority" json:"priority,omitempty"`
	// The maximum number of connections that Envoy will make to the upstream
	// cluster. If not specified, the default is 1024.
	MaxConnections *google_protobuf.UInt32Value `protobuf:"bytes,2,opt,name=max_connections,json=maxConnections" json:"max_connections,omitempty"`
	// The maximum number of pending requests that Envoy will allow to the
	// upstream cluster. If not specified, the default is 1024.
	MaxPendingRequests *google_protobuf.UInt32Value `protobuf:"bytes,3,opt,name=max_pending_requests,json=maxPendingRequests" json:"max_pending_requests,omitempty"`
	// The maximum number of parallel requests that Envoy will make to the
	// upstream cluster. If not specified, the default is 1024.
	MaxRequests *google_protobuf.UInt32Value `protobuf:"bytes,4,opt,name=max_requests,json=maxRequests" json:"max_requests,omitempty"`
	// The maximum number of parallel retries that Envoy will allow to the
	// upstream cluster. If not specified, the default is 3.
	MaxRetries *google_protobuf.UInt32Value `protobuf:"bytes,5,opt,name=max_retries,json=maxRetries" json:"max_retries,omitempty"`
}

func (m *CircuitBreakers_Thresholds) Reset()                    { *m = CircuitBreakers_Thresholds{} }
func (m *CircuitBreakers_Thresholds) String() string            { return proto.CompactTextString(m) }
func (*CircuitBreakers_Thresholds) ProtoMessage()               {}
func (*CircuitBreakers_Thresholds) Descriptor() ([]byte, []int) { return fileDescriptorCds, []int{2, 0} }

func (m *CircuitBreakers_Thresholds) GetPriority() RoutingPriority {
	if m != nil {
		return m.Priority
	}
	return RoutingPriority_DEFAULT
}

func (m *CircuitBreakers_Thresholds) GetMaxConnections() *google_protobuf.UInt32Value {
	if m != nil {
		return m.MaxConnections
	}
	return nil
}

func (m *CircuitBreakers_Thresholds) GetMaxPendingRequests() *google_protobuf.UInt32Value {
	if m != nil {
		return m.MaxPendingRequests
	}
	return nil
}

func (m *CircuitBreakers_Thresholds) GetMaxRequests() *google_protobuf.UInt32Value {
	if m != nil {
		return m.MaxRequests
	}
	return nil
}

func (m *CircuitBreakers_Thresholds) GetMaxRetries() *google_protobuf.UInt32Value {
	if m != nil {
		return m.MaxRetries
	}
	return nil
}

func init() {
	proto.RegisterType((*Cluster)(nil), "envoy.api.v2.Cluster")
	proto.RegisterType((*Cluster_EdsClusterConfig)(nil), "envoy.api.v2.Cluster.EdsClusterConfig")
	proto.RegisterType((*Cluster_OutlierDetection)(nil), "envoy.api.v2.Cluster.OutlierDetection")
	proto.RegisterType((*Cluster_LbSubsetConfig)(nil), "envoy.api.v2.Cluster.LbSubsetConfig")
	proto.RegisterType((*Cluster_LbSubsetConfig_LbSubsetSelector)(nil), "envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector")
	proto.RegisterType((*Cluster_RingHashLbConfig)(nil), "envoy.api.v2.Cluster.RingHashLbConfig")
	proto.RegisterType((*Cluster_RingHashLbConfig_DeprecatedV1)(nil), "envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1")
	proto.RegisterType((*UpstreamBindConfig)(nil), "envoy.api.v2.UpstreamBindConfig")
	proto.RegisterType((*CircuitBreakers)(nil), "envoy.api.v2.CircuitBreakers")
	proto.RegisterType((*CircuitBreakers_Thresholds)(nil), "envoy.api.v2.CircuitBreakers.Thresholds")
	proto.RegisterEnum("envoy.api.v2.Cluster_DiscoveryType", Cluster_DiscoveryType_name, Cluster_DiscoveryType_value)
	proto.RegisterEnum("envoy.api.v2.Cluster_LbPolicy", Cluster_LbPolicy_name, Cluster_LbPolicy_value)
	proto.RegisterEnum("envoy.api.v2.Cluster_DnsLookupFamily", Cluster_DnsLookupFamily_name, Cluster_DnsLookupFamily_value)
	proto.RegisterEnum("envoy.api.v2.Cluster_ClusterProtocolSelection", Cluster_ClusterProtocolSelection_name, Cluster_ClusterProtocolSelection_value)
	proto.RegisterEnum("envoy.api.v2.Cluster_LbSubsetConfig_LbSubsetFallbackPolicy", Cluster_LbSubsetConfig_LbSubsetFallbackPolicy_name, Cluster_LbSubsetConfig_LbSubsetFallbackPolicy_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for ClusterDiscoveryService service

type ClusterDiscoveryServiceClient interface {
	StreamClusters(ctx context.Context, opts ...grpc.CallOption) (ClusterDiscoveryService_StreamClustersClient, error)
	FetchClusters(ctx context.Context, in *DiscoveryRequest, opts ...grpc.CallOption) (*DiscoveryResponse, error)
}

type clusterDiscoveryServiceClient struct {
	cc *grpc.ClientConn
}

func NewClusterDiscoveryServiceClient(cc *grpc.ClientConn) ClusterDiscoveryServiceClient {
	return &clusterDiscoveryServiceClient{cc}
}

func (c *clusterDiscoveryServiceClient) StreamClusters(ctx context.Context, opts ...grpc.CallOption) (ClusterDiscoveryService_StreamClustersClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_ClusterDiscoveryService_serviceDesc.Streams[0], c.cc, "/envoy.api.v2.ClusterDiscoveryService/StreamClusters", opts...)
	if err != nil {
		return nil, err
	}
	x := &clusterDiscoveryServiceStreamClustersClient{stream}
	return x, nil
}

type ClusterDiscoveryService_StreamClustersClient interface {
	Send(*DiscoveryRequest) error
	Recv() (*DiscoveryResponse, error)
	grpc.ClientStream
}

type clusterDiscoveryServiceStreamClustersClient struct {
	grpc.ClientStream
}

func (x *clusterDiscoveryServiceStreamClustersClient) Send(m *DiscoveryRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *clusterDiscoveryServiceStreamClustersClient) Recv() (*DiscoveryResponse, error) {
	m := new(DiscoveryResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *clusterDiscoveryServiceClient) FetchClusters(ctx context.Context, in *DiscoveryRequest, opts ...grpc.CallOption) (*DiscoveryResponse, error) {
	out := new(DiscoveryResponse)
	err := grpc.Invoke(ctx, "/envoy.api.v2.ClusterDiscoveryService/FetchClusters", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for ClusterDiscoveryService service

type ClusterDiscoveryServiceServer interface {
	StreamClusters(ClusterDiscoveryService_StreamClustersServer) error
	FetchClusters(context.Context, *DiscoveryRequest) (*DiscoveryResponse, error)
}

func RegisterClusterDiscoveryServiceServer(s *grpc.Server, srv ClusterDiscoveryServiceServer) {
	s.RegisterService(&_ClusterDiscoveryService_serviceDesc, srv)
}

func _ClusterDiscoveryService_StreamClusters_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ClusterDiscoveryServiceServer).StreamClusters(&clusterDiscoveryServiceStreamClustersServer{stream})
}

type ClusterDiscoveryService_StreamClustersServer interface {
	Send(*DiscoveryResponse) error
	Recv() (*DiscoveryRequest, error)
	grpc.ServerStream
}

type clusterDiscoveryServiceStreamClustersServer struct {
	grpc.ServerStream
}

func (x *clusterDiscoveryServiceStreamClustersServer) Send(m *DiscoveryResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *clusterDiscoveryServiceStreamClustersServer) Recv() (*DiscoveryRequest, error) {
	m := new(DiscoveryRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _ClusterDiscoveryService_FetchClusters_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DiscoveryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterDiscoveryServiceServer).FetchClusters(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/envoy.api.v2.ClusterDiscoveryService/FetchClusters",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterDiscoveryServiceServer).FetchClusters(ctx, req.(*DiscoveryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ClusterDiscoveryService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "envoy.api.v2.ClusterDiscoveryService",
	HandlerType: (*ClusterDiscoveryServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "FetchClusters",
			Handler:    _ClusterDiscoveryService_FetchClusters_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamClusters",
			Handler:       _ClusterDiscoveryService_StreamClusters_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "api/cds.proto",
}

func (m *Cluster) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Cluster) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCds(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCds(dAtA, i, uint64(m.Type))
	}
	if m.EdsClusterConfig != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCds(dAtA, i, uint64(m.EdsClusterConfig.Size()))
		n1, err := m.EdsClusterConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	dAtA[i] = 0x22
	i++
	i = encodeVarintCds(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdDuration(m.ConnectTimeout)))
	n2, err := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.ConnectTimeout, dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	if m.PerConnectionBufferLimitBytes != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCds(dAtA, i, uint64(m.PerConnectionBufferLimitBytes.Size()))
		n3, err := m.PerConnectionBufferLimitBytes.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.LbPolicy != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintCds(dAtA, i, uint64(m.LbPolicy))
	}
	if len(m.Hosts) > 0 {
		for _, msg := range m.Hosts {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintCds(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.HealthChecks) > 0 {
		for _, msg := range m.HealthChecks {
			dAtA[i] = 0x42
			i++
			i = encodeVarintCds(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.MaxRequestsPerConnection != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintCds(dAtA, i, uint64(m.MaxRequestsPerConnection.Size()))
		n4, err := m.MaxRequestsPerConnection.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.CircuitBreakers != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintCds(dAtA, i, uint64(m.CircuitBreakers.Size()))
		n5, err := m.CircuitBreakers.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.TlsContext != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintCds(dAtA, i, uint64(m.TlsContext.Size()))
		n6, err := m.TlsContext.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.HttpProtocolOptions != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintCds(dAtA, i, uint64(m.HttpProtocolOptions.Size()))
		n7, err := m.HttpProtocolOptions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.Http2ProtocolOptions != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintCds(dAtA, i, uint64(m.Http2ProtocolOptions.Size()))
		n8, err := m.Http2ProtocolOptions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.DnsRefreshRate != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCds(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdDuration(*m.DnsRefreshRate)))
		n9, err := github_com_gogo_protobuf_types.StdDurationMarshalTo(*m.DnsRefreshRate, dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.DnsLookupFamily != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCds(dAtA, i, uint64(m.DnsLookupFamily))
	}
	if len(m.DnsResolvers) > 0 {
		for _, msg := range m.DnsResolvers {
			dAtA[i] = 0x92
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintCds(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.OutlierDetection != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCds(dAtA, i, uint64(m.OutlierDetection.Size()))
		n10, err := m.OutlierDetection.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.CleanupInterval != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCds(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdDuration(*m.CleanupInterval)))
		n11, err := github_com_gogo_protobuf_types.StdDurationMarshalTo(*m.CleanupInterval, dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.UpstreamBindConfig != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCds(dAtA, i, uint64(m.UpstreamBindConfig.Size()))
		n12, err := m.UpstreamBindConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.LbSubsetConfig != nil {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCds(dAtA, i, uint64(m.LbSubsetConfig.Size()))
		n13, err := m.LbSubsetConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.LbConfig != nil {
		nn14, err := m.LbConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn14
	}
	if m.TransportSocket != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCds(dAtA, i, uint64(m.TransportSocket.Size()))
		n15, err := m.TransportSocket.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.Metadata != nil {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCds(dAtA, i, uint64(m.Metadata.Size()))
		n16, err := m.Metadata.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.ProtocolSelection != 0 {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCds(dAtA, i, uint64(m.ProtocolSelection))
	}
	return i, nil
}

func (m *Cluster_RingHashLbConfig_) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.RingHashLbConfig != nil {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCds(dAtA, i, uint64(m.RingHashLbConfig.Size()))
		n17, err := m.RingHashLbConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	return i, nil
}
func (m *Cluster_EdsClusterConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Cluster_EdsClusterConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EdsConfig != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCds(dAtA, i, uint64(m.EdsConfig.Size()))
		n18, err := m.EdsConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if len(m.ServiceName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCds(dAtA, i, uint64(len(m.ServiceName)))
		i += copy(dAtA[i:], m.ServiceName)
	}
	return i, nil
}

func (m *Cluster_OutlierDetection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Cluster_OutlierDetection) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Consecutive_5Xx != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCds(dAtA, i, uint64(m.Consecutive_5Xx.Size()))
		n19, err := m.Consecutive_5Xx.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if m.Interval != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCds(dAtA, i, uint64(m.Interval.Size()))
		n20, err := m.Interval.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if m.BaseEjectionTime != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCds(dAtA, i, uint64(m.BaseEjectionTime.Size()))
		n21, err := m.BaseEjectionTime.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if m.MaxEjectionPercent != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCds(dAtA, i, uint64(m.MaxEjectionPercent.Size()))
		n22, err := m.MaxEjectionPercent.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	if m.EnforcingConsecutive_5Xx != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCds(dAtA, i, uint64(m.EnforcingConsecutive_5Xx.Size()))
		n23, err := m.EnforcingConsecutive_5Xx.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	if m.EnforcingSuccessRate != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintCds(dAtA, i, uint64(m.EnforcingSuccessRate.Size()))
		n24, err := m.EnforcingSuccessRate.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	if m.SuccessRateMinimumHosts != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintCds(dAtA, i, uint64(m.SuccessRateMinimumHosts.Size()))
		n25, err := m.SuccessRateMinimumHosts.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	if m.SuccessRateRequestVolume != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintCds(dAtA, i, uint64(m.SuccessRateRequestVolume.Size()))
		n26, err := m.SuccessRateRequestVolume.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	if m.SuccessRateStdevFactor != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintCds(dAtA, i, uint64(m.SuccessRateStdevFactor.Size()))
		n27, err := m.SuccessRateStdevFactor.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	if m.ConsecutiveGatewayFailure != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintCds(dAtA, i, uint64(m.ConsecutiveGatewayFailure.Size()))
		n28, err := m.ConsecutiveGatewayFailure.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	if m.EnforcingConsecutiveGatewayFailure != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintCds(dAtA, i, uint64(m.EnforcingConsecutiveGatewayFailure.Size()))
		n29, err := m.EnforcingConsecutiveGatewayFailure.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	return i, nil
}

func (m *Cluster_LbSubsetConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Cluster_LbSubsetConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FallbackPolicy != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCds(dAtA, i, uint64(m.FallbackPolicy))
	}
	if m.DefaultSubset != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCds(dAtA, i, uint64(m.DefaultSubset.Size()))
		n30, err := m.DefaultSubset.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	if len(m.SubsetSelectors) > 0 {
		for _, msg := range m.SubsetSelectors {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintCds(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Cluster_LbSubsetConfig_LbSubsetSelector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Cluster_LbSubsetConfig_LbSubsetSelector) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for _, s := range m.Keys {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *Cluster_RingHashLbConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Cluster_RingHashLbConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MinimumRingSize != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCds(dAtA, i, uint64(m.MinimumRingSize.Size()))
		n31, err := m.MinimumRingSize.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	if m.DeprecatedV1 != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCds(dAtA, i, uint64(m.DeprecatedV1.Size()))
		n32, err := m.DeprecatedV1.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	return i, nil
}

func (m *Cluster_RingHashLbConfig_DeprecatedV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Cluster_RingHashLbConfig_DeprecatedV1) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UseStdHash != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCds(dAtA, i, uint64(m.UseStdHash.Size()))
		n33, err := m.UseStdHash.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	return i, nil
}

func (m *UpstreamBindConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpstreamBindConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SourceAddress != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCds(dAtA, i, uint64(m.SourceAddress.Size()))
		n34, err := m.SourceAddress.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n34
	}
	return i, nil
}

func (m *CircuitBreakers) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CircuitBreakers) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Thresholds) > 0 {
		for _, msg := range m.Thresholds {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCds(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CircuitBreakers_Thresholds) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CircuitBreakers_Thresholds) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Priority != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCds(dAtA, i, uint64(m.Priority))
	}
	if m.MaxConnections != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCds(dAtA, i, uint64(m.MaxConnections.Size()))
		n35, err := m.MaxConnections.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n35
	}
	if m.MaxPendingRequests != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCds(dAtA, i, uint64(m.MaxPendingRequests.Size()))
		n36, err := m.MaxPendingRequests.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n36
	}
	if m.MaxRequests != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCds(dAtA, i, uint64(m.MaxRequests.Size()))
		n37, err := m.MaxRequests.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n37
	}
	if m.MaxRetries != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCds(dAtA, i, uint64(m.MaxRetries.Size()))
		n38, err := m.MaxRetries.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n38
	}
	return i, nil
}

func encodeVarintCds(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Cluster) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCds(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovCds(uint64(m.Type))
	}
	if m.EdsClusterConfig != nil {
		l = m.EdsClusterConfig.Size()
		n += 1 + l + sovCds(uint64(l))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.ConnectTimeout)
	n += 1 + l + sovCds(uint64(l))
	if m.PerConnectionBufferLimitBytes != nil {
		l = m.PerConnectionBufferLimitBytes.Size()
		n += 1 + l + sovCds(uint64(l))
	}
	if m.LbPolicy != 0 {
		n += 1 + sovCds(uint64(m.LbPolicy))
	}
	if len(m.Hosts) > 0 {
		for _, e := range m.Hosts {
			l = e.Size()
			n += 1 + l + sovCds(uint64(l))
		}
	}
	if len(m.HealthChecks) > 0 {
		for _, e := range m.HealthChecks {
			l = e.Size()
			n += 1 + l + sovCds(uint64(l))
		}
	}
	if m.MaxRequestsPerConnection != nil {
		l = m.MaxRequestsPerConnection.Size()
		n += 1 + l + sovCds(uint64(l))
	}
	if m.CircuitBreakers != nil {
		l = m.CircuitBreakers.Size()
		n += 1 + l + sovCds(uint64(l))
	}
	if m.TlsContext != nil {
		l = m.TlsContext.Size()
		n += 1 + l + sovCds(uint64(l))
	}
	if m.HttpProtocolOptions != nil {
		l = m.HttpProtocolOptions.Size()
		n += 1 + l + sovCds(uint64(l))
	}
	if m.Http2ProtocolOptions != nil {
		l = m.Http2ProtocolOptions.Size()
		n += 1 + l + sovCds(uint64(l))
	}
	if m.DnsRefreshRate != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdDuration(*m.DnsRefreshRate)
		n += 2 + l + sovCds(uint64(l))
	}
	if m.DnsLookupFamily != 0 {
		n += 2 + sovCds(uint64(m.DnsLookupFamily))
	}
	if len(m.DnsResolvers) > 0 {
		for _, e := range m.DnsResolvers {
			l = e.Size()
			n += 2 + l + sovCds(uint64(l))
		}
	}
	if m.OutlierDetection != nil {
		l = m.OutlierDetection.Size()
		n += 2 + l + sovCds(uint64(l))
	}
	if m.CleanupInterval != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdDuration(*m.CleanupInterval)
		n += 2 + l + sovCds(uint64(l))
	}
	if m.UpstreamBindConfig != nil {
		l = m.UpstreamBindConfig.Size()
		n += 2 + l + sovCds(uint64(l))
	}
	if m.LbSubsetConfig != nil {
		l = m.LbSubsetConfig.Size()
		n += 2 + l + sovCds(uint64(l))
	}
	if m.LbConfig != nil {
		n += m.LbConfig.Size()
	}
	if m.TransportSocket != nil {
		l = m.TransportSocket.Size()
		n += 2 + l + sovCds(uint64(l))
	}
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 2 + l + sovCds(uint64(l))
	}
	if m.ProtocolSelection != 0 {
		n += 2 + sovCds(uint64(m.ProtocolSelection))
	}
	return n
}

func (m *Cluster_RingHashLbConfig_) Size() (n int) {
	var l int
	_ = l
	if m.RingHashLbConfig != nil {
		l = m.RingHashLbConfig.Size()
		n += 2 + l + sovCds(uint64(l))
	}
	return n
}
func (m *Cluster_EdsClusterConfig) Size() (n int) {
	var l int
	_ = l
	if m.EdsConfig != nil {
		l = m.EdsConfig.Size()
		n += 1 + l + sovCds(uint64(l))
	}
	l = len(m.ServiceName)
	if l > 0 {
		n += 1 + l + sovCds(uint64(l))
	}
	return n
}

func (m *Cluster_OutlierDetection) Size() (n int) {
	var l int
	_ = l
	if m.Consecutive_5Xx != nil {
		l = m.Consecutive_5Xx.Size()
		n += 1 + l + sovCds(uint64(l))
	}
	if m.Interval != nil {
		l = m.Interval.Size()
		n += 1 + l + sovCds(uint64(l))
	}
	if m.BaseEjectionTime != nil {
		l = m.BaseEjectionTime.Size()
		n += 1 + l + sovCds(uint64(l))
	}
	if m.MaxEjectionPercent != nil {
		l = m.MaxEjectionPercent.Size()
		n += 1 + l + sovCds(uint64(l))
	}
	if m.EnforcingConsecutive_5Xx != nil {
		l = m.EnforcingConsecutive_5Xx.Size()
		n += 1 + l + sovCds(uint64(l))
	}
	if m.EnforcingSuccessRate != nil {
		l = m.EnforcingSuccessRate.Size()
		n += 1 + l + sovCds(uint64(l))
	}
	if m.SuccessRateMinimumHosts != nil {
		l = m.SuccessRateMinimumHosts.Size()
		n += 1 + l + sovCds(uint64(l))
	}
	if m.SuccessRateRequestVolume != nil {
		l = m.SuccessRateRequestVolume.Size()
		n += 1 + l + sovCds(uint64(l))
	}
	if m.SuccessRateStdevFactor != nil {
		l = m.SuccessRateStdevFactor.Size()
		n += 1 + l + sovCds(uint64(l))
	}
	if m.ConsecutiveGatewayFailure != nil {
		l = m.ConsecutiveGatewayFailure.Size()
		n += 1 + l + sovCds(uint64(l))
	}
	if m.EnforcingConsecutiveGatewayFailure != nil {
		l = m.EnforcingConsecutiveGatewayFailure.Size()
		n += 1 + l + sovCds(uint64(l))
	}
	return n
}

func (m *Cluster_LbSubsetConfig) Size() (n int) {
	var l int
	_ = l
	if m.FallbackPolicy != 0 {
		n += 1 + sovCds(uint64(m.FallbackPolicy))
	}
	if m.DefaultSubset != nil {
		l = m.DefaultSubset.Size()
		n += 1 + l + sovCds(uint64(l))
	}
	if len(m.SubsetSelectors) > 0 {
		for _, e := range m.SubsetSelectors {
			l = e.Size()
			n += 1 + l + sovCds(uint64(l))
		}
	}
	return n
}

func (m *Cluster_LbSubsetConfig_LbSubsetSelector) Size() (n int) {
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for _, s := range m.Keys {
			l = len(s)
			n += 1 + l + sovCds(uint64(l))
		}
	}
	return n
}

func (m *Cluster_RingHashLbConfig) Size() (n int) {
	var l int
	_ = l
	if m.MinimumRingSize != nil {
		l = m.MinimumRingSize.Size()
		n += 1 + l + sovCds(uint64(l))
	}
	if m.DeprecatedV1 != nil {
		l = m.DeprecatedV1.Size()
		n += 1 + l + sovCds(uint64(l))
	}
	return n
}

func (m *Cluster_RingHashLbConfig_DeprecatedV1) Size() (n int) {
	var l int
	_ = l
	if m.UseStdHash != nil {
		l = m.UseStdHash.Size()
		n += 1 + l + sovCds(uint64(l))
	}
	return n
}

func (m *UpstreamBindConfig) Size() (n int) {
	var l int
	_ = l
	if m.SourceAddress != nil {
		l = m.SourceAddress.Size()
		n += 1 + l + sovCds(uint64(l))
	}
	return n
}

func (m *CircuitBreakers) Size() (n int) {
	var l int
	_ = l
	if len(m.Thresholds) > 0 {
		for _, e := range m.Thresholds {
			l = e.Size()
			n += 1 + l + sovCds(uint64(l))
		}
	}
	return n
}

func (m *CircuitBreakers_Thresholds) Size() (n int) {
	var l int
	_ = l
	if m.Priority != 0 {
		n += 1 + sovCds(uint64(m.Priority))
	}
	if m.MaxConnections != nil {
		l = m.MaxConnections.Size()
		n += 1 + l + sovCds(uint64(l))
	}
	if m.MaxPendingRequests != nil {
		l = m.MaxPendingRequests.Size()
		n += 1 + l + sovCds(uint64(l))
	}
	if m.MaxRequests != nil {
		l = m.MaxRequests.Size()
		n += 1 + l + sovCds(uint64(l))
	}
	if m.MaxRetries != nil {
		l = m.MaxRetries.Size()
		n += 1 + l + sovCds(uint64(l))
	}
	return n
}

func sovCds(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozCds(x uint64) (n int) {
	return sovCds(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Cluster) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCds
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Cluster: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Cluster: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCds
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (Cluster_DiscoveryType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EdsClusterConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EdsClusterConfig == nil {
				m.EdsClusterConfig = &Cluster_EdsClusterConfig{}
			}
			if err := m.EdsClusterConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectTimeout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.ConnectTimeout, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerConnectionBufferLimitBytes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PerConnectionBufferLimitBytes == nil {
				m.PerConnectionBufferLimitBytes = &google_protobuf.UInt32Value{}
			}
			if err := m.PerConnectionBufferLimitBytes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LbPolicy", wireType)
			}
			m.LbPolicy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LbPolicy |= (Cluster_LbPolicy(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hosts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hosts = append(m.Hosts, &Address{})
			if err := m.Hosts[len(m.Hosts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HealthChecks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HealthChecks = append(m.HealthChecks, &HealthCheck{})
			if err := m.HealthChecks[len(m.HealthChecks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRequestsPerConnection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaxRequestsPerConnection == nil {
				m.MaxRequestsPerConnection = &google_protobuf.UInt32Value{}
			}
			if err := m.MaxRequestsPerConnection.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CircuitBreakers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CircuitBreakers == nil {
				m.CircuitBreakers = &CircuitBreakers{}
			}
			if err := m.CircuitBreakers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsContext", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TlsContext == nil {
				m.TlsContext = &UpstreamTlsContext{}
			}
			if err := m.TlsContext.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpProtocolOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HttpProtocolOptions == nil {
				m.HttpProtocolOptions = &Http1ProtocolOptions{}
			}
			if err := m.HttpProtocolOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Http2ProtocolOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Http2ProtocolOptions == nil {
				m.Http2ProtocolOptions = &Http2ProtocolOptions{}
			}
			if err := m.Http2ProtocolOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsRefreshRate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DnsRefreshRate == nil {
				m.DnsRefreshRate = new(time.Duration)
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(m.DnsRefreshRate, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsLookupFamily", wireType)
			}
			m.DnsLookupFamily = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DnsLookupFamily |= (Cluster_DnsLookupFamily(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsResolvers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DnsResolvers = append(m.DnsResolvers, &Address{})
			if err := m.DnsResolvers[len(m.DnsResolvers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutlierDetection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OutlierDetection == nil {
				m.OutlierDetection = &Cluster_OutlierDetection{}
			}
			if err := m.OutlierDetection.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CleanupInterval", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CleanupInterval == nil {
				m.CleanupInterval = new(time.Duration)
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(m.CleanupInterval, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpstreamBindConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpstreamBindConfig == nil {
				m.UpstreamBindConfig = &BindConfig{}
			}
			if err := m.UpstreamBindConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LbSubsetConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LbSubsetConfig == nil {
				m.LbSubsetConfig = &Cluster_LbSubsetConfig{}
			}
			if err := m.LbSubsetConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RingHashLbConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Cluster_RingHashLbConfig{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LbConfig = &Cluster_RingHashLbConfig_{v}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransportSocket", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TransportSocket == nil {
				m.TransportSocket = &TransportSocket{}
			}
			if err := m.TransportSocket.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &Metadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtocolSelection", wireType)
			}
			m.ProtocolSelection = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProtocolSelection |= (Cluster_ClusterProtocolSelection(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCds(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCds
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Cluster_EdsClusterConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCds
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EdsClusterConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EdsClusterConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EdsConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EdsConfig == nil {
				m.EdsConfig = &ConfigSource{}
			}
			if err := m.EdsConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCds
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCds(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCds
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Cluster_OutlierDetection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCds
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OutlierDetection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OutlierDetection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Consecutive_5Xx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Consecutive_5Xx == nil {
				m.Consecutive_5Xx = &google_protobuf.UInt32Value{}
			}
			if err := m.Consecutive_5Xx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interval", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Interval == nil {
				m.Interval = &google_protobuf2.Duration{}
			}
			if err := m.Interval.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseEjectionTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BaseEjectionTime == nil {
				m.BaseEjectionTime = &google_protobuf2.Duration{}
			}
			if err := m.BaseEjectionTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxEjectionPercent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaxEjectionPercent == nil {
				m.MaxEjectionPercent = &google_protobuf.UInt32Value{}
			}
			if err := m.MaxEjectionPercent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnforcingConsecutive_5Xx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EnforcingConsecutive_5Xx == nil {
				m.EnforcingConsecutive_5Xx = &google_protobuf.UInt32Value{}
			}
			if err := m.EnforcingConsecutive_5Xx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnforcingSuccessRate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EnforcingSuccessRate == nil {
				m.EnforcingSuccessRate = &google_protobuf.UInt32Value{}
			}
			if err := m.EnforcingSuccessRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuccessRateMinimumHosts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SuccessRateMinimumHosts == nil {
				m.SuccessRateMinimumHosts = &google_protobuf.UInt32Value{}
			}
			if err := m.SuccessRateMinimumHosts.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuccessRateRequestVolume", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SuccessRateRequestVolume == nil {
				m.SuccessRateRequestVolume = &google_protobuf.UInt32Value{}
			}
			if err := m.SuccessRateRequestVolume.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuccessRateStdevFactor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SuccessRateStdevFactor == nil {
				m.SuccessRateStdevFactor = &google_protobuf.UInt32Value{}
			}
			if err := m.SuccessRateStdevFactor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsecutiveGatewayFailure", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConsecutiveGatewayFailure == nil {
				m.ConsecutiveGatewayFailure = &google_protobuf.UInt32Value{}
			}
			if err := m.ConsecutiveGatewayFailure.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnforcingConsecutiveGatewayFailure", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EnforcingConsecutiveGatewayFailure == nil {
				m.EnforcingConsecutiveGatewayFailure = &google_protobuf.UInt32Value{}
			}
			if err := m.EnforcingConsecutiveGatewayFailure.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCds(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCds
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Cluster_LbSubsetConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCds
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LbSubsetConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LbSubsetConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FallbackPolicy", wireType)
			}
			m.FallbackPolicy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FallbackPolicy |= (Cluster_LbSubsetConfig_LbSubsetFallbackPolicy(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultSubset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefaultSubset == nil {
				m.DefaultSubset = &google_protobuf4.Struct{}
			}
			if err := m.DefaultSubset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubsetSelectors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubsetSelectors = append(m.SubsetSelectors, &Cluster_LbSubsetConfig_LbSubsetSelector{})
			if err := m.SubsetSelectors[len(m.SubsetSelectors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCds(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCds
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Cluster_LbSubsetConfig_LbSubsetSelector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCds
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LbSubsetSelector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LbSubsetSelector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCds
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCds(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCds
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Cluster_RingHashLbConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCds
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RingHashLbConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RingHashLbConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinimumRingSize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MinimumRingSize == nil {
				m.MinimumRingSize = &google_protobuf.UInt64Value{}
			}
			if err := m.MinimumRingSize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeprecatedV1", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeprecatedV1 == nil {
				m.DeprecatedV1 = &Cluster_RingHashLbConfig_DeprecatedV1{}
			}
			if err := m.DeprecatedV1.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCds(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCds
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Cluster_RingHashLbConfig_DeprecatedV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCds
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeprecatedV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeprecatedV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseStdHash", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UseStdHash == nil {
				m.UseStdHash = &google_protobuf.BoolValue{}
			}
			if err := m.UseStdHash.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCds(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCds
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpstreamBindConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCds
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpstreamBindConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpstreamBindConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SourceAddress == nil {
				m.SourceAddress = &Address{}
			}
			if err := m.SourceAddress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCds(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCds
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CircuitBreakers) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCds
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CircuitBreakers: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CircuitBreakers: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Thresholds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Thresholds = append(m.Thresholds, &CircuitBreakers_Thresholds{})
			if err := m.Thresholds[len(m.Thresholds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCds(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCds
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CircuitBreakers_Thresholds) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCds
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Thresholds: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Thresholds: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= (RoutingPriority(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxConnections", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaxConnections == nil {
				m.MaxConnections = &google_protobuf.UInt32Value{}
			}
			if err := m.MaxConnections.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxPendingRequests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaxPendingRequests == nil {
				m.MaxPendingRequests = &google_protobuf.UInt32Value{}
			}
			if err := m.MaxPendingRequests.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRequests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaxRequests == nil {
				m.MaxRequests = &google_protobuf.UInt32Value{}
			}
			if err := m.MaxRequests.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRetries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaxRetries == nil {
				m.MaxRetries = &google_protobuf.UInt32Value{}
			}
			if err := m.MaxRetries.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCds(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCds
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCds(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCds
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCds
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCds
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthCds
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowCds
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipCds(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthCds = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCds   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("api/cds.proto", fileDescriptorCds) }

var fileDescriptorCds = []byte{
	// 2032 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x58, 0xdf, 0x6f, 0xdb, 0xc8,
	0xf1, 0x37, 0x65, 0x27, 0xb1, 0x47, 0xbf, 0xe8, 0x8d, 0x63, 0xd3, 0xca, 0x25, 0x71, 0xf4, 0xfd,
	0xde, 0xc1, 0x48, 0x01, 0xb9, 0x51, 0x2e, 0x07, 0x5c, 0x7a, 0xbd, 0x42, 0xbf, 0x6c, 0x2b, 0x55,
	0x24, 0x97, 0x94, 0x9d, 0x0b, 0xae, 0xe9, 0x96, 0x22, 0x57, 0x16, 0x6b, 0x8a, 0x64, 0xb9, 0x4b,
	0x9d, 0x9d, 0xc7, 0x43, 0xff, 0x83, 0xbe, 0xf4, 0xa5, 0xff, 0x40, 0xff, 0x82, 0xa2, 0xe8, 0x43,
	0x1f, 0xef, 0xb1, 0x40, 0xdf, 0xaf, 0x45, 0x50, 0xa0, 0xe8, 0xdf, 0xd0, 0x97, 0x62, 0x97, 0x4b,
	0x59, 0x62, 0x6c, 0xc7, 0x01, 0xfa, 0x24, 0xee, 0xcc, 0x67, 0x3e, 0x3b, 0x1a, 0xce, 0xec, 0xcc,
	0x12, 0xf2, 0x66, 0xe0, 0xec, 0x58, 0x36, 0xad, 0x04, 0xa1, 0xcf, 0x7c, 0x94, 0x23, 0xde, 0xc4,
	0x3f, 0xab, 0x98, 0x81, 0x53, 0x99, 0x54, 0x4b, 0xab, 0x5c, 0x69, 0xda, 0x76, 0x48, 0xa8, 0x04,
	0x94, 0x0a, 0x5c, 0x34, 0x30, 0x29, 0x91, 0xeb, 0x0d, 0x61, 0xef, 0x7b, 0x43, 0xe7, 0x18, 0x53,
	0x3f, 0x0a, 0xad, 0x44, 0x71, 0x9b, 0x2b, 0x6c, 0x87, 0x5a, 0xfe, 0x84, 0x84, 0x67, 0x52, 0xb8,
	0xce, 0x85, 0x23, 0x62, 0xba, 0x6c, 0x84, 0xad, 0x11, 0xb1, 0x4e, 0xa4, 0x1c, 0x71, 0xb9, 0x78,
	0xb4, 0x7c, 0x57, 0xca, 0x84, 0x67, 0x34, 0xf1, 0xac, 0xf4, 0xd1, 0xb1, 0xef, 0x1f, 0xbb, 0x64,
	0x47, 0xb8, 0xe4, 0x79, 0x3e, 0x33, 0x99, 0xe3, 0x7b, 0x89, 0xf6, 0xbe, 0xd4, 0x8a, 0xd5, 0x20,
	0x1a, 0xee, 0xd8, 0x51, 0x28, 0x00, 0x29, 0xeb, 0xa9, 0x9e, 0xb2, 0x30, 0xb2, 0xd8, 0x65, 0xd6,
	0xdf, 0x84, 0x66, 0x10, 0x90, 0x30, 0x61, 0xdf, 0x98, 0x98, 0xae, 0x63, 0x9b, 0x8c, 0xec, 0x24,
	0x0f, 0x52, 0xb1, 0x76, 0xec, 0x1f, 0xfb, 0xe2, 0x71, 0x87, 0x3f, 0xc5, 0xd2, 0xf2, 0x1f, 0x1f,
	0xc0, 0xad, 0x86, 0x1b, 0x51, 0x46, 0x42, 0x74, 0x0f, 0x96, 0x3c, 0x73, 0x4c, 0x34, 0x65, 0x4b,
	0xd9, 0x5e, 0xa9, 0xaf, 0xfc, 0xe9, 0xdf, 0x7f, 0x59, 0x5c, 0x0a, 0x33, 0x5b, 0x8a, 0x2e, 0xc4,
	0xa8, 0x01, 0x4b, 0xec, 0x2c, 0x20, 0x5a, 0x66, 0x4b, 0xd9, 0x2e, 0x54, 0xff, 0xaf, 0x32, 0x1b,
	0xfe, 0x8a, 0xe4, 0xa8, 0x34, 0x93, 0x28, 0xf6, 0xcf, 0x02, 0x52, 0x07, 0xce, 0x71, 0xe3, 0x5b,
	0x25, 0xa3, 0x2a, 0xba, 0x30, 0x46, 0x7d, 0x40, 0xc4, 0xa6, 0xd8, 0x8a, 0xe1, 0x38, 0x7e, 0x1b,
	0xda, 0xe2, 0x96, 0xb2, 0x9d, 0xad, 0x7e, 0x72, 0x31, 0x65, 0xcb, 0xa6, 0xf2, 0xb1, 0x21, 0xd0,
	0xba, 0x4a, 0x52, 0x12, 0x74, 0x04, 0x45, 0xcb, 0xf7, 0x3c, 0x62, 0x31, 0xcc, 0x9c, 0x31, 0xf1,
	0x23, 0xa6, 0x2d, 0x09, 0xca, 0xcd, 0x4a, 0x1c, 0xae, 0x4a, 0x12, 0xae, 0x4a, 0x53, 0x06, 0xbb,
	0x8e, 0xbe, 0xfb, 0xfe, 0xc1, 0xc2, 0xef, 0xfe, 0xfe, 0x40, 0x11, 0x3e, 0xfe, 0x41, 0xc9, 0x3c,
	0x5a, 0xd0, 0x0b, 0x92, 0xa5, 0x1f, 0x93, 0xa0, 0x21, 0x3c, 0x0c, 0x62, 0x2f, 0xb9, 0xd4, 0xf1,
	0x3d, 0x3c, 0x88, 0x86, 0x43, 0x12, 0x62, 0xd7, 0x19, 0x3b, 0x0c, 0x0f, 0xce, 0x18, 0xa1, 0xda,
	0x0d, 0xb1, 0xd3, 0x47, 0xef, 0xec, 0x74, 0xd8, 0xf6, 0xd8, 0x93, 0xea, 0x91, 0xe9, 0x46, 0x44,
	0xbf, 0x17, 0x08, 0x5f, 0x25, 0x4b, 0x5d, 0x90, 0x74, 0x38, 0x47, 0x9d, 0x53, 0xa0, 0x3d, 0x58,
	0x71, 0x07, 0x38, 0xf0, 0x5d, 0xc7, 0x3a, 0xd3, 0x6e, 0x8a, 0xf8, 0xde, 0xbf, 0x38, 0x18, 0x9d,
	0xc1, 0x81, 0x40, 0xcd, 0x85, 0x76, 0xd9, 0x95, 0x52, 0xf4, 0x03, 0xb8, 0x31, 0xf2, 0x29, 0xa3,
	0xda, 0xad, 0xad, 0xc5, 0xed, 0x6c, 0xf5, 0xce, 0x3c, 0x49, 0x2d, 0x2e, 0x0f, 0x3d, 0xc6, 0xa0,
	0x2f, 0x21, 0x3f, 0x9b, 0xdf, 0x54, 0x5b, 0x16, 0x46, 0x9b, 0xf3, 0x46, 0xfb, 0x02, 0xd2, 0xe0,
	0x08, 0x3d, 0x37, 0x3a, 0x5f, 0x50, 0xf4, 0x35, 0xdc, 0x1d, 0x9b, 0xa7, 0x38, 0x24, 0xbf, 0x8e,
	0x08, 0x65, 0x14, 0xcf, 0x87, 0x4a, 0x5b, 0xb9, 0x46, 0x5c, 0xb4, 0xb1, 0x79, 0xaa, 0x4b, 0xfb,
	0x83, 0xd9, 0x10, 0xa1, 0x7d, 0x50, 0x2d, 0x27, 0xb4, 0x22, 0x1e, 0xe6, 0x90, 0x98, 0x27, 0x24,
	0xa4, 0x1a, 0x08, 0xc6, 0x7b, 0xa9, 0xc8, 0xc4, 0xa8, 0xba, 0x04, 0xe9, 0x45, 0x6b, 0x5e, 0x80,
	0x6a, 0x90, 0x65, 0x2e, 0xe5, 0x9e, 0x31, 0x72, 0xca, 0xb4, 0xac, 0x20, 0xd9, 0x9a, 0x27, 0x39,
	0x0c, 0x28, 0x0b, 0x89, 0x39, 0xee, 0xbb, 0xb4, 0x11, 0xe3, 0x74, 0x60, 0xd3, 0x67, 0x74, 0x04,
	0x77, 0x46, 0x8c, 0x05, 0x38, 0x29, 0x7b, 0xec, 0x07, 0xa2, 0xa2, 0xb5, 0xbc, 0x20, 0x2b, 0xa7,
	0x22, 0xc6, 0x58, 0xf0, 0xf8, 0x40, 0x42, 0x7b, 0x31, 0x52, 0xbf, 0xcd, 0x09, 0x52, 0x42, 0xf4,
	0x15, 0xac, 0x73, 0x71, 0xf5, 0x5d, 0xe2, 0xc2, 0x65, 0xc4, 0xd5, 0x34, 0xf1, 0xda, 0xe8, 0x02,
	0x29, 0x32, 0x40, 0xb5, 0x3d, 0x8a, 0x43, 0x32, 0x0c, 0x09, 0x1d, 0xe1, 0xd0, 0x64, 0x44, 0x53,
	0xdf, 0x57, 0x12, 0x85, 0x74, 0x39, 0xd8, 0x1e, 0xd5, 0x63, 0x06, 0xdd, 0x64, 0x04, 0xbd, 0x86,
	0x55, 0x4e, 0xea, 0xfa, 0xfe, 0x49, 0x14, 0xe0, 0xa1, 0x39, 0x76, 0xdc, 0x33, 0x6d, 0x55, 0xa4,
	0xeb, 0xc7, 0x97, 0x1c, 0x07, 0x1e, 0xed, 0x08, 0xf4, 0xae, 0x00, 0xcf, 0x65, 0x6d, 0xd1, 0x9e,
	0x57, 0xa2, 0x67, 0x90, 0x8f, 0x7d, 0xa6, 0xbe, 0x3b, 0xe1, 0xef, 0x1b, 0x5d, 0x95, 0xc4, 0x39,
	0xe1, 0x9c, 0x84, 0x22, 0x03, 0x56, 0xfd, 0x88, 0xb9, 0x0e, 0x09, 0xb1, 0x4d, 0x98, 0xcc, 0xc0,
	0xdb, 0x57, 0x1d, 0x2b, 0xbd, 0x18, 0xde, 0x4c, 0xd0, 0xba, 0xea, 0xa7, 0x24, 0xa8, 0x0f, 0xaa,
	0xe5, 0x12, 0xd3, 0x8b, 0x02, 0xec, 0x78, 0x8c, 0x84, 0x13, 0xd3, 0xd5, 0xd6, 0x3e, 0x34, 0x88,
	0x45, 0x49, 0xd1, 0x96, 0x0c, 0xe8, 0x39, 0xac, 0x45, 0x32, 0xdd, 0xf0, 0xc0, 0xf1, 0xec, 0xe4,
	0x10, 0xbc, 0x23, 0x98, 0xb5, 0x79, 0x6f, 0xeb, 0x8e, 0x67, 0xcb, 0x63, 0x0f, 0x25, 0x56, 0xe7,
	0x32, 0xd4, 0x05, 0xd5, 0x1d, 0x60, 0x1a, 0x0d, 0x28, 0x61, 0x09, 0xcf, 0xba, 0xe0, 0xf9, 0xff,
	0xcb, 0xce, 0x0f, 0x43, 0x80, 0x25, 0x67, 0xc1, 0x9d, 0x5b, 0xa3, 0x97, 0x70, 0x3b, 0x74, 0xbc,
	0x63, 0x3c, 0x32, 0xe9, 0x08, 0xbb, 0x83, 0x84, 0x72, 0xe3, 0xaa, 0x40, 0xea, 0x8e, 0x77, 0xbc,
	0x6f, 0xd2, 0x51, 0x67, 0x10, 0x93, 0xec, 0x2f, 0xe8, 0x6a, 0x98, 0x92, 0xf1, 0x72, 0x66, 0xa1,
	0xe9, 0xd1, 0xc0, 0x0f, 0x19, 0xa6, 0xbe, 0x75, 0x42, 0x98, 0xa6, 0x5d, 0x54, 0xce, 0xfd, 0x04,
	0x65, 0x08, 0x90, 0x5e, 0x64, 0xf3, 0x02, 0x54, 0x85, 0xe5, 0x31, 0x61, 0xa6, 0x6d, 0x32, 0x53,
	0xdb, 0x14, 0x0c, 0xeb, 0xf3, 0x0c, 0x2f, 0xa4, 0x56, 0x9f, 0xe2, 0xd0, 0x6b, 0x40, 0xd3, 0x0a,
	0xa3, 0xc4, 0x95, 0xe9, 0x51, 0x12, 0x99, 0x5b, 0xb9, 0xf8, 0x5f, 0xc9, 0xdf, 0xa4, 0xae, 0x8c,
	0xc4, 0x4a, 0x5f, 0x0d, 0xd2, 0xa2, 0x52, 0x00, 0x6a, 0xba, 0x49, 0xa1, 0xcf, 0x01, 0x44, 0xa3,
	0x8b, 0x03, 0xa8, 0x08, 0x47, 0x4b, 0xa9, 0xad, 0x84, 0xce, 0x10, 0x93, 0x88, 0xbe, 0xc2, 0x9b,
	0x5a, 0x6c, 0xfa, 0x10, 0x72, 0x94, 0x84, 0x13, 0xc7, 0x22, 0x58, 0xf4, 0x63, 0xde, 0x70, 0x57,
	0xf4, 0xac, 0x94, 0x75, 0xcd, 0x31, 0x29, 0xfd, 0xe7, 0x16, 0xa8, 0xe9, 0x04, 0x46, 0x2d, 0xd1,
	0x05, 0x29, 0xb1, 0x22, 0xe6, 0x4c, 0x08, 0x7e, 0x7a, 0x7a, 0x2a, 0xf7, 0xbd, 0xfa, 0x0c, 0x2e,
	0xcc, 0x18, 0x3d, 0x3d, 0x3d, 0x45, 0x35, 0x58, 0x9e, 0x66, 0x7b, 0xe6, 0x7d, 0xd9, 0x0e, 0x33,
	0x99, 0x3e, 0x35, 0x43, 0x06, 0x20, 0x3e, 0x77, 0x61, 0xf2, 0x2b, 0xd9, 0x36, 0x79, 0x57, 0x96,
	0x5d, 0xfe, 0x9a, 0x64, 0x2a, 0x27, 0x68, 0x49, 0x7b, 0xde, 0x8f, 0xd1, 0x2b, 0x58, 0xe3, 0xed,
	0x66, 0xca, 0x19, 0x90, 0xd0, 0x22, 0x5e, 0xd2, 0xe9, 0xaf, 0xfc, 0x8f, 0x72, 0x98, 0x79, 0x94,
	0xd1, 0x6c, 0x1d, 0x8d, 0xcd, 0xd3, 0x84, 0xf7, 0x20, 0xa6, 0x40, 0x16, 0x6c, 0x12, 0x6f, 0xe8,
	0x87, 0x16, 0xcf, 0xfd, 0x74, 0x0c, 0x6f, 0x7c, 0x18, 0xff, 0xc6, 0x94, 0xa9, 0x31, 0x1f, 0xd7,
	0xd7, 0xb0, 0x7e, 0xbe, 0x09, 0x8d, 0x2c, 0x8b, 0x50, 0x1a, 0x1f, 0xcc, 0x37, 0x3f, 0x6c, 0x87,
	0xb5, 0x29, 0x8d, 0x11, 0xb3, 0x88, 0xc3, 0xf9, 0x15, 0x94, 0x66, 0x49, 0xf1, 0xd8, 0xf1, 0x9c,
	0x71, 0x34, 0xc6, 0xc9, 0x3c, 0xf0, 0xfe, 0x44, 0xd8, 0xa0, 0xe7, 0x74, 0x2f, 0x62, 0xeb, 0x7d,
	0x31, 0x28, 0x7c, 0x0d, 0x77, 0xe7, 0xa8, 0x65, 0xc7, 0xc7, 0x13, 0xdf, 0x8d, 0xc6, 0x44, 0x5b,
	0xbe, 0x4e, 0xa3, 0x9f, 0xe1, 0x96, 0x0d, 0xff, 0x48, 0x58, 0xa3, 0x97, 0xb0, 0x39, 0x47, 0x4e,
	0x99, 0x4d, 0x26, 0x78, 0x68, 0x5a, 0xcc, 0x0f, 0xaf, 0x35, 0x43, 0xac, 0xcf, 0x50, 0x1b, 0xdc,
	0x78, 0x57, 0xd8, 0xa2, 0x9f, 0xc3, 0xdd, 0xd9, 0x57, 0x79, 0x6c, 0x32, 0xf2, 0x8d, 0x79, 0x86,
	0x87, 0xa6, 0xe3, 0x46, 0x21, 0x91, 0xc3, 0xc4, 0xd5, 0xd4, 0x9b, 0x33, 0x04, 0x7b, 0xb1, 0xfd,
	0x6e, 0x6c, 0x8e, 0xde, 0xc0, 0xc7, 0x17, 0xa7, 0x4c, 0x7a, 0x9f, 0xec, 0x87, 0xbd, 0xdc, 0xf2,
	0x45, 0xe9, 0x33, 0xbf, 0x77, 0xe9, 0xf7, 0x8b, 0x50, 0x98, 0x3f, 0xc8, 0x51, 0x00, 0xc5, 0xa1,
	0xe9, 0xba, 0x03, 0xd3, 0x3a, 0x49, 0xe6, 0x48, 0x45, 0x1c, 0x6f, 0x3f, 0xba, 0x4e, 0x1f, 0x98,
	0x2e, 0x77, 0x25, 0xc7, 0x05, 0x43, 0x66, 0x61, 0x38, 0xa7, 0x43, 0x5f, 0x42, 0xc1, 0x26, 0x43,
	0x33, 0x72, 0x99, 0xec, 0x3f, 0xf2, 0xb0, 0xd8, 0x78, 0xe7, 0x9f, 0x1a, 0xe2, 0xfe, 0xa2, 0xe7,
	0x25, 0x3c, 0xde, 0x09, 0xfd, 0x12, 0x54, 0xd9, 0xb7, 0xe2, 0x13, 0xd9, 0x0f, 0xa9, 0xb6, 0x28,
	0x1a, 0xfe, 0xd3, 0x0f, 0x72, 0xd9, 0x90, 0xd6, 0x7a, 0x91, 0xce, 0xad, 0x69, 0xe9, 0x13, 0x50,
	0xd3, 0x20, 0x84, 0x60, 0xe9, 0x84, 0x9c, 0x51, 0x4d, 0xd9, 0x5a, 0xdc, 0x5e, 0xd1, 0xc5, 0x73,
	0xb9, 0x07, 0xeb, 0x17, 0xff, 0x7f, 0x54, 0x84, 0x6c, 0xb7, 0x87, 0x77, 0x6b, 0x9d, 0x4e, 0xbd,
	0xd6, 0xf8, 0xa9, 0xba, 0x80, 0x54, 0xc8, 0xd5, 0xba, 0xaf, 0x70, 0xab, 0xdb, 0x3c, 0xe8, 0xb5,
	0xbb, 0x7d, 0x55, 0x41, 0x08, 0x0a, 0xcd, 0xd6, 0x6e, 0xed, 0xb0, 0xd3, 0xc7, 0xc6, 0x61, 0xdd,
	0x68, 0xf5, 0xd5, 0x4c, 0xe9, 0x37, 0x19, 0x50, 0xf5, 0x77, 0x3b, 0xe0, 0x6a, 0x52, 0x92, 0xa2,
	0xc5, 0x52, 0xe7, 0x0d, 0xb9, 0xf2, 0x7c, 0xfe, 0xec, 0xd3, 0x38, 0x09, 0x8b, 0xd2, 0x8c, 0x33,
	0x1a, 0xce, 0x1b, 0x82, 0xbe, 0x82, 0xbc, 0x4d, 0x82, 0x90, 0x58, 0x26, 0x23, 0x36, 0x9e, 0x3c,
	0x96, 0x81, 0x7f, 0x72, 0xbd, 0xf6, 0x5c, 0x69, 0x4e, 0x6d, 0x8f, 0x1e, 0xeb, 0x39, 0x7b, 0x66,
	0x55, 0xea, 0x40, 0x6e, 0x56, 0x8b, 0xbe, 0x80, 0x5c, 0x44, 0x45, 0x49, 0x8a, 0x89, 0x60, 0xda,
	0xc6, 0xd2, 0xee, 0xd6, 0x7d, 0xdf, 0x8d, 0x9d, 0x85, 0x88, 0xf2, 0x22, 0xe4, 0x1b, 0x96, 0x5f,
	0x42, 0x7e, 0xee, 0x3a, 0x88, 0x00, 0x6e, 0x1a, 0xfd, 0x5a, 0xbf, 0xdd, 0x50, 0x17, 0x50, 0x01,
	0xc0, 0xe8, 0xeb, 0xed, 0x46, 0x1f, 0x37, 0xbb, 0x86, 0xaa, 0xf0, 0x50, 0x77, 0x7a, 0x7b, 0xed,
	0x46, 0xad, 0x23, 0x04, 0x19, 0x74, 0x0b, 0x16, 0x5b, 0x4d, 0x43, 0x5d, 0xe4, 0x31, 0xef, 0xe9,
	0xed, 0xbd, 0x76, 0x97, 0xab, 0x8c, 0xbe, 0xba, 0x54, 0xfe, 0x05, 0x2c, 0x27, 0xf7, 0x20, 0x6e,
	0xa7, 0xf7, 0x0e, 0xbb, 0x4d, 0xac, 0xf7, 0xea, 0xed, 0xae, 0xba, 0x80, 0x56, 0x21, 0xdf, 0x69,
	0xd5, 0x8c, 0x3e, 0xd6, 0x5b, 0x3f, 0x3b, 0x6c, 0x19, 0xfc, 0x1d, 0xe5, 0x61, 0x45, 0x6f, 0x77,
	0xf7, 0xf0, 0x7e, 0xcd, 0xd8, 0x57, 0x33, 0xdc, 0x0d, 0xbd, 0xd6, 0x6d, 0xf6, 0x5e, 0xa8, 0x8b,
	0xe8, 0x36, 0x14, 0x67, 0xc9, 0x71, 0xa7, 0xae, 0x2e, 0x95, 0x9f, 0x42, 0x31, 0x35, 0xb8, 0xa2,
	0x65, 0x58, 0xaa, 0x1d, 0xf6, 0x7b, 0xea, 0x02, 0xca, 0xc2, 0xad, 0xa3, 0x4f, 0x71, 0xaf, 0xdb,
	0x79, 0xa5, 0x2a, 0x62, 0xf1, 0x59, 0xbc, 0xc8, 0x94, 0xfb, 0xa0, 0x5d, 0x36, 0x35, 0xa0, 0xbb,
	0xb0, 0x71, 0x68, 0xb4, 0x70, 0xa3, 0xd7, 0xdd, 0x6d, 0xef, 0x1d, 0xea, 0xad, 0x26, 0x3e, 0xd0,
	0x7b, 0xfd, 0x5e, 0xa3, 0xd7, 0x51, 0x17, 0x12, 0x65, 0xb3, 0xf7, 0xb2, 0x6b, 0xf4, 0xf5, 0x56,
	0xed, 0xc5, 0xb9, 0x52, 0xa9, 0x67, 0xc5, 0xdd, 0x30, 0x9e, 0x23, 0x9e, 0x2f, 0x2d, 0xe7, 0xd4,
	0xfc, 0xf3, 0xa5, 0xe5, 0xa2, 0xaa, 0x96, 0x75, 0x40, 0x87, 0xef, 0x4e, 0x84, 0x5f, 0x40, 0x21,
	0xfe, 0xb6, 0x81, 0xe5, 0xc7, 0x10, 0xf9, 0xd2, 0x2e, 0x99, 0xa2, 0xf3, 0x31, 0x58, 0x2e, 0xcb,
	0x7f, 0x5e, 0x84, 0x62, 0xea, 0x42, 0x85, 0xf6, 0x01, 0xd8, 0x88, 0xdf, 0x01, 0x7c, 0xd7, 0x8e,
	0x0b, 0x27, 0x5b, 0xdd, 0xbe, 0xf2, 0x0e, 0x56, 0xe9, 0x4f, 0xf1, 0xfa, 0x8c, 0x6d, 0xe9, 0xfb,
	0x0c, 0xc0, 0xb9, 0x0a, 0x7d, 0x0e, 0xcb, 0x41, 0xe8, 0xf8, 0xa1, 0xc3, 0x92, 0xc3, 0x2a, 0x35,
	0x0b, 0xea, 0x7e, 0xc4, 0x1c, 0xef, 0xf8, 0x40, 0x82, 0xf4, 0x29, 0x9c, 0x8f, 0x3a, 0x7c, 0x16,
	0x38, 0xbf, 0x6d, 0x52, 0x59, 0x04, 0xef, 0x19, 0x75, 0xc6, 0xe6, 0xe9, 0xf9, 0x1d, 0x93, 0xa2,
	0x6e, 0x3c, 0x52, 0x04, 0xc4, 0xb3, 0x79, 0x49, 0x26, 0x37, 0x59, 0x39, 0xa9, 0x5c, 0xcd, 0xc5,
	0xe7, 0x88, 0x83, 0xd8, 0x30, 0xb9, 0xc1, 0xa2, 0x9f, 0x40, 0x6e, 0xf6, 0x46, 0x7c, 0x9d, 0xd1,
	0x44, 0xcf, 0xce, 0x5c, 0x81, 0xd1, 0x8f, 0x21, 0x1b, 0x13, 0xb0, 0xd0, 0xb9, 0xe6, 0xa7, 0x05,
	0x10, 0xf6, 0x02, 0x5f, 0xfd, 0x97, 0x02, 0x1b, 0x32, 0x05, 0xa7, 0x95, 0x67, 0xc4, 0x63, 0x23,
	0x7a, 0x09, 0x05, 0x43, 0x24, 0x8b, 0x04, 0x50, 0x94, 0xfa, 0xc4, 0x30, 0xb5, 0x90, 0xde, 0x94,
	0x1e, 0x5c, 0xaa, 0xa7, 0x01, 0xef, 0x4d, 0xe5, 0x85, 0x6d, 0xe5, 0x87, 0x0a, 0xa2, 0x90, 0xdf,
	0x25, 0xcc, 0x1a, 0xfd, 0xef, 0x78, 0x1f, 0x7e, 0xfb, 0xb7, 0x7f, 0xfe, 0x36, 0x73, 0xb7, 0xbc,
	0xbe, 0x33, 0xa9, 0x9e, 0x7f, 0x97, 0x7b, 0x26, 0x3f, 0x1a, 0xd1, 0x67, 0xca, 0xa3, 0x7a, 0xee,
	0xbb, 0xb7, 0xf7, 0x95, 0xbf, 0xbe, 0xbd, 0xaf, 0xfc, 0xe3, 0xed, 0x7d, 0x65, 0x70, 0x53, 0x44,
	0xe6, 0xc9, 0x7f, 0x03, 0x00, 0x00, 0xff, 0xff, 0xab, 0xd9, 0x7f, 0xd3, 0x22, 0x14, 0x00, 0x00,
}
