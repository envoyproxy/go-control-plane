// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: api/filter/accesslog/accesslog.proto

/*
	Package accesslog is a generated protocol buffer package.

	It is generated from these files:
		api/filter/accesslog/accesslog.proto

	It has these top-level messages:
		AccessLogCommon
		ResponseFlags
		TLSProperties
		TCPAccessLogEntry
		HTTPRequestProperties
		HTTPResponseProperties
		HTTPAccessLogEntry
		AccessLog
		AccessLogFilter
		ComparisonFilter
		StatusCodeFilter
		DurationFilter
		NotHealthCheckFilter
		TraceableFilter
		RuntimeFilter
		AndFilter
		OrFilter
		FileAccessLog
		AccessLogServiceConfig
		StreamAccessLogsMessage
		StreamAccessLogsResponse
*/
package accesslog

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import envoy_api_v2 "github.com/envoyproxy/go-control-plane/api"
import envoy_api_v21 "github.com/envoyproxy/go-control-plane/api"
import google_protobuf2 "github.com/gogo/protobuf/types"
import google_protobuf4 "github.com/gogo/protobuf/types"
import google_protobuf3 "github.com/gogo/protobuf/types"
import google_protobuf "github.com/gogo/protobuf/types"
import _ "github.com/lyft/protoc-gen-validate/validate"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import encoding_binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type TLSProperties_TLSVersion int32

const (
	TLSProperties_VERSION_UNSPECIFIED TLSProperties_TLSVersion = 0
	TLSProperties_TLSv1               TLSProperties_TLSVersion = 1
	TLSProperties_TLSv1_1             TLSProperties_TLSVersion = 2
	TLSProperties_TLSv1_2             TLSProperties_TLSVersion = 3
	TLSProperties_TLSv1_3             TLSProperties_TLSVersion = 4
)

var TLSProperties_TLSVersion_name = map[int32]string{
	0: "VERSION_UNSPECIFIED",
	1: "TLSv1",
	2: "TLSv1_1",
	3: "TLSv1_2",
	4: "TLSv1_3",
}
var TLSProperties_TLSVersion_value = map[string]int32{
	"VERSION_UNSPECIFIED": 0,
	"TLSv1":               1,
	"TLSv1_1":             2,
	"TLSv1_2":             3,
	"TLSv1_3":             4,
}

func (x TLSProperties_TLSVersion) String() string {
	return proto.EnumName(TLSProperties_TLSVersion_name, int32(x))
}
func (TLSProperties_TLSVersion) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorAccesslog, []int{2, 0}
}

// HTTP version
type HTTPAccessLogEntry_HTTPVersion int32

const (
	HTTPAccessLogEntry_PROTOCOL_UNSPECIFIED HTTPAccessLogEntry_HTTPVersion = 0
	HTTPAccessLogEntry_HTTP10               HTTPAccessLogEntry_HTTPVersion = 1
	HTTPAccessLogEntry_HTTP11               HTTPAccessLogEntry_HTTPVersion = 2
	HTTPAccessLogEntry_HTTP2                HTTPAccessLogEntry_HTTPVersion = 3
)

var HTTPAccessLogEntry_HTTPVersion_name = map[int32]string{
	0: "PROTOCOL_UNSPECIFIED",
	1: "HTTP10",
	2: "HTTP11",
	3: "HTTP2",
}
var HTTPAccessLogEntry_HTTPVersion_value = map[string]int32{
	"PROTOCOL_UNSPECIFIED": 0,
	"HTTP10":               1,
	"HTTP11":               2,
	"HTTP2":                3,
}

func (x HTTPAccessLogEntry_HTTPVersion) String() string {
	return proto.EnumName(HTTPAccessLogEntry_HTTPVersion_name, int32(x))
}
func (HTTPAccessLogEntry_HTTPVersion) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorAccesslog, []int{6, 0}
}

type ComparisonFilter_Op int32

const (
	// =
	ComparisonFilter_EQ ComparisonFilter_Op = 0
	// >=
	ComparisonFilter_GE ComparisonFilter_Op = 1
)

var ComparisonFilter_Op_name = map[int32]string{
	0: "EQ",
	1: "GE",
}
var ComparisonFilter_Op_value = map[string]int32{
	"EQ": 0,
	"GE": 1,
}

func (x ComparisonFilter_Op) String() string {
	return proto.EnumName(ComparisonFilter_Op_name, int32(x))
}
func (ComparisonFilter_Op) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorAccesslog, []int{9, 0}
}

// Defines fields that are shared by all Envoy access logs.
// [#proto-status: draft]
// [#not-implemented-hide:] Not configuration. TBD how to doc proto APIs.
type AccessLogCommon struct {
	// This field indicates the rate at which this log entry was sampled.
	// Valid range is (0.0, 1.0].
	SampleRate float64 `protobuf:"fixed64,1,opt,name=sample_rate,json=sampleRate,proto3" json:"sample_rate,omitempty"`
	// This field is the IP and port on which the request from the user was
	// received.
	DestinationHost *envoy_api_v2.SocketAddress `protobuf:"bytes,2,opt,name=destination_host,json=destinationHost" json:"destination_host,omitempty"`
	// If the connection is secure, this field will contain TLS properties.
	TlsProperties *TLSProperties `protobuf:"bytes,3,opt,name=tls_properties,json=tlsProperties" json:"tls_properties,omitempty"`
	// The time that Envoy started servicing this request
	StartTime *google_protobuf3.Timestamp `protobuf:"bytes,4,opt,name=start_time,json=startTime" json:"start_time,omitempty"`
	// Interval between the first downstream byte received and the last
	// downstream byte received (i.e. time it takes to receive a request).
	TimeToLastRxByte *google_protobuf2.Duration `protobuf:"bytes,5,opt,name=time_to_last_rx_byte,json=timeToLastRxByte" json:"time_to_last_rx_byte,omitempty"`
	// Interval between the first downstream byte received and the first upstream
	// byte received (i.e. time it takes to start receiving a response).
	TimeToFirstUpstreamRxByte *google_protobuf2.Duration `protobuf:"bytes,6,opt,name=time_to_first_upstream_rx_byte,json=timeToFirstUpstreamRxByte" json:"time_to_first_upstream_rx_byte,omitempty"`
	// Interval between the first downstream byte received and the last upstream
	// byte received (i.e. time it takes to receive a complete response).
	TimeToLastUpstreamRxByte *google_protobuf2.Duration `protobuf:"bytes,7,opt,name=time_to_last_upstream_rx_byte,json=timeToLastUpstreamRxByte" json:"time_to_last_upstream_rx_byte,omitempty"`
	// The (primary) upstream host that handles this exchange.
	UpstreamHost *envoy_api_v2.SocketAddress `protobuf:"bytes,8,opt,name=upstream_host,json=upstreamHost" json:"upstream_host,omitempty"`
	// The upstream cluster that ``upstream_host`` belongs to.
	UpstreamCluster string `protobuf:"bytes,9,opt,name=upstream_cluster,json=upstreamCluster,proto3" json:"upstream_cluster,omitempty"`
	// Flags indicating occurences during request/response processing.
	ResponseFlags *ResponseFlags `protobuf:"bytes,10,opt,name=response_flags,json=responseFlags" json:"response_flags,omitempty"`
	// All metadata encountered during request processing, including endpoint
	// selection.
	//
	// This can be used to associate IDs attached to the various configurations
	// used to process this request with the access log entry. For example, a
	// route created from a higher level forwarding rule with some ID can place
	// that ID in this field and cross reference later. It can also be used to
	// determine if a canary endpoint was used or not.
	Metadata *envoy_api_v21.Metadata `protobuf:"bytes,11,opt,name=metadata" json:"metadata,omitempty"`
}

func (m *AccessLogCommon) Reset()                    { *m = AccessLogCommon{} }
func (m *AccessLogCommon) String() string            { return proto.CompactTextString(m) }
func (*AccessLogCommon) ProtoMessage()               {}
func (*AccessLogCommon) Descriptor() ([]byte, []int) { return fileDescriptorAccesslog, []int{0} }

func (m *AccessLogCommon) GetSampleRate() float64 {
	if m != nil {
		return m.SampleRate
	}
	return 0
}

func (m *AccessLogCommon) GetDestinationHost() *envoy_api_v2.SocketAddress {
	if m != nil {
		return m.DestinationHost
	}
	return nil
}

func (m *AccessLogCommon) GetTlsProperties() *TLSProperties {
	if m != nil {
		return m.TlsProperties
	}
	return nil
}

func (m *AccessLogCommon) GetStartTime() *google_protobuf3.Timestamp {
	if m != nil {
		return m.StartTime
	}
	return nil
}

func (m *AccessLogCommon) GetTimeToLastRxByte() *google_protobuf2.Duration {
	if m != nil {
		return m.TimeToLastRxByte
	}
	return nil
}

func (m *AccessLogCommon) GetTimeToFirstUpstreamRxByte() *google_protobuf2.Duration {
	if m != nil {
		return m.TimeToFirstUpstreamRxByte
	}
	return nil
}

func (m *AccessLogCommon) GetTimeToLastUpstreamRxByte() *google_protobuf2.Duration {
	if m != nil {
		return m.TimeToLastUpstreamRxByte
	}
	return nil
}

func (m *AccessLogCommon) GetUpstreamHost() *envoy_api_v2.SocketAddress {
	if m != nil {
		return m.UpstreamHost
	}
	return nil
}

func (m *AccessLogCommon) GetUpstreamCluster() string {
	if m != nil {
		return m.UpstreamCluster
	}
	return ""
}

func (m *AccessLogCommon) GetResponseFlags() *ResponseFlags {
	if m != nil {
		return m.ResponseFlags
	}
	return nil
}

func (m *AccessLogCommon) GetMetadata() *envoy_api_v21.Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

// [#proto-status: draft]
// [#not-implemented-hide:] Not configuration. TBD how to doc proto APIs.
// Flags indicating occurences during request/response processing.
type ResponseFlags struct {
	// Indicates local server healthcheck failed.
	FailedLocalHealthcheck bool `protobuf:"varint,1,opt,name=failed_local_healthcheck,json=failedLocalHealthcheck,proto3" json:"failed_local_healthcheck,omitempty"`
	// Indicates there was no healthy upstream.
	NoHealthyUpstream bool `protobuf:"varint,2,opt,name=no_healthy_upstream,json=noHealthyUpstream,proto3" json:"no_healthy_upstream,omitempty"`
	// Indicates an there was an upstream request timeout.
	UpstreamRequestTimeout bool `protobuf:"varint,3,opt,name=upstream_request_timeout,json=upstreamRequestTimeout,proto3" json:"upstream_request_timeout,omitempty"`
	// Indicates local codec level reset was sent on the stream.
	LocalReset bool `protobuf:"varint,4,opt,name=local_reset,json=localReset,proto3" json:"local_reset,omitempty"`
	// Indicates remote codec level reset was received on the stream.
	UpstreamRemoteReset bool `protobuf:"varint,5,opt,name=upstream_remote_reset,json=upstreamRemoteReset,proto3" json:"upstream_remote_reset,omitempty"`
	// Indicates there was a local reset by a connection pool due to an initial connection failure.
	UpstreamConnectionFailure bool `protobuf:"varint,6,opt,name=upstream_connection_failure,json=upstreamConnectionFailure,proto3" json:"upstream_connection_failure,omitempty"`
	// Indicates the stream was reset locally due to connection termination.
	UpstreamConnectionTermination bool `protobuf:"varint,7,opt,name=upstream_connection_termination,json=upstreamConnectionTermination,proto3" json:"upstream_connection_termination,omitempty"`
	// Indicates the stream was reset because of a resource overflow.
	UpstreamOverflow bool `protobuf:"varint,8,opt,name=upstream_overflow,json=upstreamOverflow,proto3" json:"upstream_overflow,omitempty"`
	// Indicates no route was found for the request.
	NoRouteFound bool `protobuf:"varint,9,opt,name=no_route_found,json=noRouteFound,proto3" json:"no_route_found,omitempty"`
	// Indicates that the request was delayed before proxying.
	DelayInjected bool `protobuf:"varint,10,opt,name=delay_injected,json=delayInjected,proto3" json:"delay_injected,omitempty"`
	// Indicates that the request was aborted with an injected error code.
	FaultInjected bool `protobuf:"varint,11,opt,name=fault_injected,json=faultInjected,proto3" json:"fault_injected,omitempty"`
	// Indicates that the request was rate-limited locally.
	RateLimited bool `protobuf:"varint,12,opt,name=rate_limited,json=rateLimited,proto3" json:"rate_limited,omitempty"`
}

func (m *ResponseFlags) Reset()                    { *m = ResponseFlags{} }
func (m *ResponseFlags) String() string            { return proto.CompactTextString(m) }
func (*ResponseFlags) ProtoMessage()               {}
func (*ResponseFlags) Descriptor() ([]byte, []int) { return fileDescriptorAccesslog, []int{1} }

func (m *ResponseFlags) GetFailedLocalHealthcheck() bool {
	if m != nil {
		return m.FailedLocalHealthcheck
	}
	return false
}

func (m *ResponseFlags) GetNoHealthyUpstream() bool {
	if m != nil {
		return m.NoHealthyUpstream
	}
	return false
}

func (m *ResponseFlags) GetUpstreamRequestTimeout() bool {
	if m != nil {
		return m.UpstreamRequestTimeout
	}
	return false
}

func (m *ResponseFlags) GetLocalReset() bool {
	if m != nil {
		return m.LocalReset
	}
	return false
}

func (m *ResponseFlags) GetUpstreamRemoteReset() bool {
	if m != nil {
		return m.UpstreamRemoteReset
	}
	return false
}

func (m *ResponseFlags) GetUpstreamConnectionFailure() bool {
	if m != nil {
		return m.UpstreamConnectionFailure
	}
	return false
}

func (m *ResponseFlags) GetUpstreamConnectionTermination() bool {
	if m != nil {
		return m.UpstreamConnectionTermination
	}
	return false
}

func (m *ResponseFlags) GetUpstreamOverflow() bool {
	if m != nil {
		return m.UpstreamOverflow
	}
	return false
}

func (m *ResponseFlags) GetNoRouteFound() bool {
	if m != nil {
		return m.NoRouteFound
	}
	return false
}

func (m *ResponseFlags) GetDelayInjected() bool {
	if m != nil {
		return m.DelayInjected
	}
	return false
}

func (m *ResponseFlags) GetFaultInjected() bool {
	if m != nil {
		return m.FaultInjected
	}
	return false
}

func (m *ResponseFlags) GetRateLimited() bool {
	if m != nil {
		return m.RateLimited
	}
	return false
}

// [#proto-status: draft]
// [#not-implemented-hide:] Not configuration. TBD how to doc proto APIs.
// Properties of a negotiated TLS connection.
type TLSProperties struct {
	// Version of TLS that was negotiated.
	TlsVersion TLSProperties_TLSVersion `protobuf:"varint,1,opt,name=tls_version,json=tlsVersion,proto3,enum=envoy.api.v2.filter.accesslog.TLSProperties_TLSVersion" json:"tls_version,omitempty"`
	// TLS cipher suite negotiated during handshake. The value is a
	// four-digit hex code defined by the IANA TLS Cipher Suite Registry
	// (e.g. ``009C`` for ``TLS_RSA_WITH_AES_128_GCM_SHA256``).
	//
	// Here it is expressed as an integer.
	TlsCipherSuite *google_protobuf.UInt32Value `protobuf:"bytes,2,opt,name=tls_cipher_suite,json=tlsCipherSuite" json:"tls_cipher_suite,omitempty"`
	// SNI hostname from handshake.
	TlsSniHostname string `protobuf:"bytes,3,opt,name=tls_sni_hostname,json=tlsSniHostname,proto3" json:"tls_sni_hostname,omitempty"`
}

func (m *TLSProperties) Reset()                    { *m = TLSProperties{} }
func (m *TLSProperties) String() string            { return proto.CompactTextString(m) }
func (*TLSProperties) ProtoMessage()               {}
func (*TLSProperties) Descriptor() ([]byte, []int) { return fileDescriptorAccesslog, []int{2} }

func (m *TLSProperties) GetTlsVersion() TLSProperties_TLSVersion {
	if m != nil {
		return m.TlsVersion
	}
	return TLSProperties_VERSION_UNSPECIFIED
}

func (m *TLSProperties) GetTlsCipherSuite() *google_protobuf.UInt32Value {
	if m != nil {
		return m.TlsCipherSuite
	}
	return nil
}

func (m *TLSProperties) GetTlsSniHostname() string {
	if m != nil {
		return m.TlsSniHostname
	}
	return ""
}

// [#proto-status: draft]
// [#not-implemented-hide:] Not configuration. TBD how to doc proto APIs.
type TCPAccessLogEntry struct {
	// Common properties shared by all Envoy access logs.
	CommonProperties *AccessLogCommon `protobuf:"bytes,1,opt,name=common_properties,json=commonProperties" json:"common_properties,omitempty"`
}

func (m *TCPAccessLogEntry) Reset()                    { *m = TCPAccessLogEntry{} }
func (m *TCPAccessLogEntry) String() string            { return proto.CompactTextString(m) }
func (*TCPAccessLogEntry) ProtoMessage()               {}
func (*TCPAccessLogEntry) Descriptor() ([]byte, []int) { return fileDescriptorAccesslog, []int{3} }

func (m *TCPAccessLogEntry) GetCommonProperties() *AccessLogCommon {
	if m != nil {
		return m.CommonProperties
	}
	return nil
}

// [#proto-status: draft]
// [#not-implemented-hide:] Not configuration. TBD how to doc proto APIs.
type HTTPRequestProperties struct {
	// The request method (RFC 7231/2616).
	// [#comment:TODO(htuch): add (validate.rules).enum.defined_only = true once
	// https://github.com/lyft/protoc-gen-validate/issues/42 is resolved.]
	RequestMethod envoy_api_v21.RequestMethod `protobuf:"varint,1,opt,name=request_method,json=requestMethod,proto3,enum=envoy.api.v2.RequestMethod" json:"request_method,omitempty"`
	// The scheme portion of the incoming request URI.
	Scheme string `protobuf:"bytes,2,opt,name=scheme,proto3" json:"scheme,omitempty"`
	// HTTP/2 ``:authority`` or HTTP/1.1 ``Host`` header value.
	Authority string `protobuf:"bytes,3,opt,name=authority,proto3" json:"authority,omitempty"`
	// The port of the incoming request URI
	// (unused currently, as port is composed onto authority).
	Port *google_protobuf.UInt32Value `protobuf:"bytes,4,opt,name=port" json:"port,omitempty"`
	// The path portion from the incoming request URI.
	Path string `protobuf:"bytes,5,opt,name=path,proto3" json:"path,omitempty"`
	// Value of the ``User-Agent`` request header.
	UserAgent string `protobuf:"bytes,6,opt,name=user_agent,json=userAgent,proto3" json:"user_agent,omitempty"`
	// Value of the ``Referer`` request header.
	Referer string `protobuf:"bytes,7,opt,name=referer,proto3" json:"referer,omitempty"`
	// Value of the ``X-Forwarded-For`` request header.
	ForwardedFor string `protobuf:"bytes,8,opt,name=forwarded_for,json=forwardedFor,proto3" json:"forwarded_for,omitempty"`
	// Value of the ``X-Request-Id`` request header
	//
	// This header is used by Envoy to uniquely identify a request.
	// It will be generated for all external requests and internal requests that
	// do not already have a request ID.
	RequestId string `protobuf:"bytes,9,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	// Value of the ``X-Envoy-Original-Path`` request header.
	OriginalPath string `protobuf:"bytes,10,opt,name=original_path,json=originalPath,proto3" json:"original_path,omitempty"`
	// Size of the HTTP request headers in bytes.
	//
	// This value is captured from the OSI layer 7 perspective, i.e. it does not
	// include overhead from framing or encoding at other networking layers.
	RequestHeadersBytes uint64 `protobuf:"varint,11,opt,name=request_headers_bytes,json=requestHeadersBytes,proto3" json:"request_headers_bytes,omitempty"`
	// Size of the HTTP request body in bytes.
	//
	// This value is captured from the OSI layer 7 perspective, i.e. it does not
	// include overhead from framing or encoding at other networking layers.
	RequestBodyBytes uint64 `protobuf:"varint,12,opt,name=request_body_bytes,json=requestBodyBytes,proto3" json:"request_body_bytes,omitempty"`
	// Map of additional headers that have been configured to be logged.
	RequestHeaders map[string]string `protobuf:"bytes,13,rep,name=request_headers,json=requestHeaders" json:"request_headers,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *HTTPRequestProperties) Reset()                    { *m = HTTPRequestProperties{} }
func (m *HTTPRequestProperties) String() string            { return proto.CompactTextString(m) }
func (*HTTPRequestProperties) ProtoMessage()               {}
func (*HTTPRequestProperties) Descriptor() ([]byte, []int) { return fileDescriptorAccesslog, []int{4} }

func (m *HTTPRequestProperties) GetRequestMethod() envoy_api_v21.RequestMethod {
	if m != nil {
		return m.RequestMethod
	}
	return envoy_api_v21.RequestMethod_METHOD_UNSPECIFIED
}

func (m *HTTPRequestProperties) GetScheme() string {
	if m != nil {
		return m.Scheme
	}
	return ""
}

func (m *HTTPRequestProperties) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *HTTPRequestProperties) GetPort() *google_protobuf.UInt32Value {
	if m != nil {
		return m.Port
	}
	return nil
}

func (m *HTTPRequestProperties) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *HTTPRequestProperties) GetUserAgent() string {
	if m != nil {
		return m.UserAgent
	}
	return ""
}

func (m *HTTPRequestProperties) GetReferer() string {
	if m != nil {
		return m.Referer
	}
	return ""
}

func (m *HTTPRequestProperties) GetForwardedFor() string {
	if m != nil {
		return m.ForwardedFor
	}
	return ""
}

func (m *HTTPRequestProperties) GetRequestId() string {
	if m != nil {
		return m.RequestId
	}
	return ""
}

func (m *HTTPRequestProperties) GetOriginalPath() string {
	if m != nil {
		return m.OriginalPath
	}
	return ""
}

func (m *HTTPRequestProperties) GetRequestHeadersBytes() uint64 {
	if m != nil {
		return m.RequestHeadersBytes
	}
	return 0
}

func (m *HTTPRequestProperties) GetRequestBodyBytes() uint64 {
	if m != nil {
		return m.RequestBodyBytes
	}
	return 0
}

func (m *HTTPRequestProperties) GetRequestHeaders() map[string]string {
	if m != nil {
		return m.RequestHeaders
	}
	return nil
}

// [#proto-status: draft]
// [#not-implemented-hide:] Not configuration. TBD how to doc proto APIs.
type HTTPResponseProperties struct {
	// The HTTP response code returned by Envoy.
	ResponseCode *google_protobuf.UInt32Value `protobuf:"bytes,1,opt,name=response_code,json=responseCode" json:"response_code,omitempty"`
	// Size of the HTTP response headers in bytes.
	//
	// This value is captured from the OSI layer 7 perspective, i.e. it does not
	// include overhead from framing or encoding at other networking layers.
	ResponseHeadersBytes uint64 `protobuf:"varint,2,opt,name=response_headers_bytes,json=responseHeadersBytes,proto3" json:"response_headers_bytes,omitempty"`
	// Size of the HTTP response body in bytes.
	//
	// This value is captured from the OSI layer 7 perspective, i.e. it does not
	// include overhead from framing or encoding at other networking layers.
	ResponseBodyBytes uint64 `protobuf:"varint,3,opt,name=response_body_bytes,json=responseBodyBytes,proto3" json:"response_body_bytes,omitempty"`
	// Map of additional headers configured to be logged.
	ResponseHeaders map[string]string `protobuf:"bytes,4,rep,name=response_headers,json=responseHeaders" json:"response_headers,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *HTTPResponseProperties) Reset()                    { *m = HTTPResponseProperties{} }
func (m *HTTPResponseProperties) String() string            { return proto.CompactTextString(m) }
func (*HTTPResponseProperties) ProtoMessage()               {}
func (*HTTPResponseProperties) Descriptor() ([]byte, []int) { return fileDescriptorAccesslog, []int{5} }

func (m *HTTPResponseProperties) GetResponseCode() *google_protobuf.UInt32Value {
	if m != nil {
		return m.ResponseCode
	}
	return nil
}

func (m *HTTPResponseProperties) GetResponseHeadersBytes() uint64 {
	if m != nil {
		return m.ResponseHeadersBytes
	}
	return 0
}

func (m *HTTPResponseProperties) GetResponseBodyBytes() uint64 {
	if m != nil {
		return m.ResponseBodyBytes
	}
	return 0
}

func (m *HTTPResponseProperties) GetResponseHeaders() map[string]string {
	if m != nil {
		return m.ResponseHeaders
	}
	return nil
}

// [#proto-status: draft]
// [#not-implemented-hide:] Not configuration. TBD how to doc proto APIs.
type HTTPAccessLogEntry struct {
	// Common properties shared by all Envoy access logs.
	CommonProperties *AccessLogCommon               `protobuf:"bytes,1,opt,name=common_properties,json=commonProperties" json:"common_properties,omitempty"`
	ProtocolVersion  HTTPAccessLogEntry_HTTPVersion `protobuf:"varint,2,opt,name=protocol_version,json=protocolVersion,proto3,enum=envoy.api.v2.filter.accesslog.HTTPAccessLogEntry_HTTPVersion" json:"protocol_version,omitempty"`
	// Description of the incoming HTTP request.
	Request *HTTPRequestProperties `protobuf:"bytes,3,opt,name=request" json:"request,omitempty"`
	// Description of the outgoing HTTP response.
	Response *HTTPResponseProperties `protobuf:"bytes,4,opt,name=response" json:"response,omitempty"`
}

func (m *HTTPAccessLogEntry) Reset()                    { *m = HTTPAccessLogEntry{} }
func (m *HTTPAccessLogEntry) String() string            { return proto.CompactTextString(m) }
func (*HTTPAccessLogEntry) ProtoMessage()               {}
func (*HTTPAccessLogEntry) Descriptor() ([]byte, []int) { return fileDescriptorAccesslog, []int{6} }

func (m *HTTPAccessLogEntry) GetCommonProperties() *AccessLogCommon {
	if m != nil {
		return m.CommonProperties
	}
	return nil
}

func (m *HTTPAccessLogEntry) GetProtocolVersion() HTTPAccessLogEntry_HTTPVersion {
	if m != nil {
		return m.ProtocolVersion
	}
	return HTTPAccessLogEntry_PROTOCOL_UNSPECIFIED
}

func (m *HTTPAccessLogEntry) GetRequest() *HTTPRequestProperties {
	if m != nil {
		return m.Request
	}
	return nil
}

func (m *HTTPAccessLogEntry) GetResponse() *HTTPResponseProperties {
	if m != nil {
		return m.Response
	}
	return nil
}

type AccessLog struct {
	// The name of the access log implementation to instantiate. The name must
	// match a statically registered access log. Current built-in loggers include:
	// 1) "envoy.file_access_log"
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Filter which is used to determine if the access log needs to be written.
	Filter *AccessLogFilter `protobuf:"bytes,2,opt,name=filter" json:"filter,omitempty"`
	// Custom configuration that depends on the access log being instantiated. built-in configurations
	// include:
	// 1) "envoy.file_access_log": :ref:`FileAccessLog <envoy_api_msg_filter.accesslog.FileAccessLog>`
	Config *google_protobuf4.Struct `protobuf:"bytes,3,opt,name=config" json:"config,omitempty"`
}

func (m *AccessLog) Reset()                    { *m = AccessLog{} }
func (m *AccessLog) String() string            { return proto.CompactTextString(m) }
func (*AccessLog) ProtoMessage()               {}
func (*AccessLog) Descriptor() ([]byte, []int) { return fileDescriptorAccesslog, []int{7} }

func (m *AccessLog) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *AccessLog) GetFilter() *AccessLogFilter {
	if m != nil {
		return m.Filter
	}
	return nil
}

func (m *AccessLog) GetConfig() *google_protobuf4.Struct {
	if m != nil {
		return m.Config
	}
	return nil
}

type AccessLogFilter struct {
	// Types that are valid to be assigned to FilterSpecifier:
	//	*AccessLogFilter_StatusCodeFilter
	//	*AccessLogFilter_DurationFilter
	//	*AccessLogFilter_NotHealthCheckFilter
	//	*AccessLogFilter_TraceableFilter
	//	*AccessLogFilter_RuntimeFilter
	//	*AccessLogFilter_AndFilter
	//	*AccessLogFilter_OrFilter
	FilterSpecifier isAccessLogFilter_FilterSpecifier `protobuf_oneof:"filter_specifier"`
}

func (m *AccessLogFilter) Reset()                    { *m = AccessLogFilter{} }
func (m *AccessLogFilter) String() string            { return proto.CompactTextString(m) }
func (*AccessLogFilter) ProtoMessage()               {}
func (*AccessLogFilter) Descriptor() ([]byte, []int) { return fileDescriptorAccesslog, []int{8} }

type isAccessLogFilter_FilterSpecifier interface {
	isAccessLogFilter_FilterSpecifier()
	MarshalTo([]byte) (int, error)
	Size() int
}

type AccessLogFilter_StatusCodeFilter struct {
	StatusCodeFilter *StatusCodeFilter `protobuf:"bytes,1,opt,name=status_code_filter,json=statusCodeFilter,oneof"`
}
type AccessLogFilter_DurationFilter struct {
	DurationFilter *DurationFilter `protobuf:"bytes,2,opt,name=duration_filter,json=durationFilter,oneof"`
}
type AccessLogFilter_NotHealthCheckFilter struct {
	NotHealthCheckFilter *NotHealthCheckFilter `protobuf:"bytes,3,opt,name=not_health_check_filter,json=notHealthCheckFilter,oneof"`
}
type AccessLogFilter_TraceableFilter struct {
	TraceableFilter *TraceableFilter `protobuf:"bytes,4,opt,name=traceable_filter,json=traceableFilter,oneof"`
}
type AccessLogFilter_RuntimeFilter struct {
	RuntimeFilter *RuntimeFilter `protobuf:"bytes,5,opt,name=runtime_filter,json=runtimeFilter,oneof"`
}
type AccessLogFilter_AndFilter struct {
	AndFilter *AndFilter `protobuf:"bytes,6,opt,name=and_filter,json=andFilter,oneof"`
}
type AccessLogFilter_OrFilter struct {
	OrFilter *OrFilter `protobuf:"bytes,7,opt,name=or_filter,json=orFilter,oneof"`
}

func (*AccessLogFilter_StatusCodeFilter) isAccessLogFilter_FilterSpecifier()     {}
func (*AccessLogFilter_DurationFilter) isAccessLogFilter_FilterSpecifier()       {}
func (*AccessLogFilter_NotHealthCheckFilter) isAccessLogFilter_FilterSpecifier() {}
func (*AccessLogFilter_TraceableFilter) isAccessLogFilter_FilterSpecifier()      {}
func (*AccessLogFilter_RuntimeFilter) isAccessLogFilter_FilterSpecifier()        {}
func (*AccessLogFilter_AndFilter) isAccessLogFilter_FilterSpecifier()            {}
func (*AccessLogFilter_OrFilter) isAccessLogFilter_FilterSpecifier()             {}

func (m *AccessLogFilter) GetFilterSpecifier() isAccessLogFilter_FilterSpecifier {
	if m != nil {
		return m.FilterSpecifier
	}
	return nil
}

func (m *AccessLogFilter) GetStatusCodeFilter() *StatusCodeFilter {
	if x, ok := m.GetFilterSpecifier().(*AccessLogFilter_StatusCodeFilter); ok {
		return x.StatusCodeFilter
	}
	return nil
}

func (m *AccessLogFilter) GetDurationFilter() *DurationFilter {
	if x, ok := m.GetFilterSpecifier().(*AccessLogFilter_DurationFilter); ok {
		return x.DurationFilter
	}
	return nil
}

func (m *AccessLogFilter) GetNotHealthCheckFilter() *NotHealthCheckFilter {
	if x, ok := m.GetFilterSpecifier().(*AccessLogFilter_NotHealthCheckFilter); ok {
		return x.NotHealthCheckFilter
	}
	return nil
}

func (m *AccessLogFilter) GetTraceableFilter() *TraceableFilter {
	if x, ok := m.GetFilterSpecifier().(*AccessLogFilter_TraceableFilter); ok {
		return x.TraceableFilter
	}
	return nil
}

func (m *AccessLogFilter) GetRuntimeFilter() *RuntimeFilter {
	if x, ok := m.GetFilterSpecifier().(*AccessLogFilter_RuntimeFilter); ok {
		return x.RuntimeFilter
	}
	return nil
}

func (m *AccessLogFilter) GetAndFilter() *AndFilter {
	if x, ok := m.GetFilterSpecifier().(*AccessLogFilter_AndFilter); ok {
		return x.AndFilter
	}
	return nil
}

func (m *AccessLogFilter) GetOrFilter() *OrFilter {
	if x, ok := m.GetFilterSpecifier().(*AccessLogFilter_OrFilter); ok {
		return x.OrFilter
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*AccessLogFilter) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _AccessLogFilter_OneofMarshaler, _AccessLogFilter_OneofUnmarshaler, _AccessLogFilter_OneofSizer, []interface{}{
		(*AccessLogFilter_StatusCodeFilter)(nil),
		(*AccessLogFilter_DurationFilter)(nil),
		(*AccessLogFilter_NotHealthCheckFilter)(nil),
		(*AccessLogFilter_TraceableFilter)(nil),
		(*AccessLogFilter_RuntimeFilter)(nil),
		(*AccessLogFilter_AndFilter)(nil),
		(*AccessLogFilter_OrFilter)(nil),
	}
}

func _AccessLogFilter_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*AccessLogFilter)
	// filter_specifier
	switch x := m.FilterSpecifier.(type) {
	case *AccessLogFilter_StatusCodeFilter:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.StatusCodeFilter); err != nil {
			return err
		}
	case *AccessLogFilter_DurationFilter:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DurationFilter); err != nil {
			return err
		}
	case *AccessLogFilter_NotHealthCheckFilter:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NotHealthCheckFilter); err != nil {
			return err
		}
	case *AccessLogFilter_TraceableFilter:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TraceableFilter); err != nil {
			return err
		}
	case *AccessLogFilter_RuntimeFilter:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.RuntimeFilter); err != nil {
			return err
		}
	case *AccessLogFilter_AndFilter:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AndFilter); err != nil {
			return err
		}
	case *AccessLogFilter_OrFilter:
		_ = b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.OrFilter); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("AccessLogFilter.FilterSpecifier has unexpected type %T", x)
	}
	return nil
}

func _AccessLogFilter_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*AccessLogFilter)
	switch tag {
	case 1: // filter_specifier.status_code_filter
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(StatusCodeFilter)
		err := b.DecodeMessage(msg)
		m.FilterSpecifier = &AccessLogFilter_StatusCodeFilter{msg}
		return true, err
	case 2: // filter_specifier.duration_filter
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DurationFilter)
		err := b.DecodeMessage(msg)
		m.FilterSpecifier = &AccessLogFilter_DurationFilter{msg}
		return true, err
	case 3: // filter_specifier.not_health_check_filter
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(NotHealthCheckFilter)
		err := b.DecodeMessage(msg)
		m.FilterSpecifier = &AccessLogFilter_NotHealthCheckFilter{msg}
		return true, err
	case 4: // filter_specifier.traceable_filter
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TraceableFilter)
		err := b.DecodeMessage(msg)
		m.FilterSpecifier = &AccessLogFilter_TraceableFilter{msg}
		return true, err
	case 5: // filter_specifier.runtime_filter
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RuntimeFilter)
		err := b.DecodeMessage(msg)
		m.FilterSpecifier = &AccessLogFilter_RuntimeFilter{msg}
		return true, err
	case 6: // filter_specifier.and_filter
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AndFilter)
		err := b.DecodeMessage(msg)
		m.FilterSpecifier = &AccessLogFilter_AndFilter{msg}
		return true, err
	case 7: // filter_specifier.or_filter
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(OrFilter)
		err := b.DecodeMessage(msg)
		m.FilterSpecifier = &AccessLogFilter_OrFilter{msg}
		return true, err
	default:
		return false, nil
	}
}

func _AccessLogFilter_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*AccessLogFilter)
	// filter_specifier
	switch x := m.FilterSpecifier.(type) {
	case *AccessLogFilter_StatusCodeFilter:
		s := proto.Size(x.StatusCodeFilter)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AccessLogFilter_DurationFilter:
		s := proto.Size(x.DurationFilter)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AccessLogFilter_NotHealthCheckFilter:
		s := proto.Size(x.NotHealthCheckFilter)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AccessLogFilter_TraceableFilter:
		s := proto.Size(x.TraceableFilter)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AccessLogFilter_RuntimeFilter:
		s := proto.Size(x.RuntimeFilter)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AccessLogFilter_AndFilter:
		s := proto.Size(x.AndFilter)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AccessLogFilter_OrFilter:
		s := proto.Size(x.OrFilter)
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Filter on an integer comparison.
type ComparisonFilter struct {
	// Comparison operator.
	Op ComparisonFilter_Op `protobuf:"varint,1,opt,name=op,proto3,enum=envoy.api.v2.filter.accesslog.ComparisonFilter_Op" json:"op,omitempty"`
	// Value to compare against.
	Value *envoy_api_v21.RuntimeUInt32 `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
}

func (m *ComparisonFilter) Reset()                    { *m = ComparisonFilter{} }
func (m *ComparisonFilter) String() string            { return proto.CompactTextString(m) }
func (*ComparisonFilter) ProtoMessage()               {}
func (*ComparisonFilter) Descriptor() ([]byte, []int) { return fileDescriptorAccesslog, []int{9} }

func (m *ComparisonFilter) GetOp() ComparisonFilter_Op {
	if m != nil {
		return m.Op
	}
	return ComparisonFilter_EQ
}

func (m *ComparisonFilter) GetValue() *envoy_api_v21.RuntimeUInt32 {
	if m != nil {
		return m.Value
	}
	return nil
}

// Filters on HTTP response/status code.
type StatusCodeFilter struct {
	// Comparison.
	Comparison *ComparisonFilter `protobuf:"bytes,1,opt,name=comparison" json:"comparison,omitempty"`
}

func (m *StatusCodeFilter) Reset()                    { *m = StatusCodeFilter{} }
func (m *StatusCodeFilter) String() string            { return proto.CompactTextString(m) }
func (*StatusCodeFilter) ProtoMessage()               {}
func (*StatusCodeFilter) Descriptor() ([]byte, []int) { return fileDescriptorAccesslog, []int{10} }

func (m *StatusCodeFilter) GetComparison() *ComparisonFilter {
	if m != nil {
		return m.Comparison
	}
	return nil
}

// Filters on total request duration in milliseconds.
type DurationFilter struct {
	// Comparison.
	Comparison *ComparisonFilter `protobuf:"bytes,1,opt,name=comparison" json:"comparison,omitempty"`
}

func (m *DurationFilter) Reset()                    { *m = DurationFilter{} }
func (m *DurationFilter) String() string            { return proto.CompactTextString(m) }
func (*DurationFilter) ProtoMessage()               {}
func (*DurationFilter) Descriptor() ([]byte, []int) { return fileDescriptorAccesslog, []int{11} }

func (m *DurationFilter) GetComparison() *ComparisonFilter {
	if m != nil {
		return m.Comparison
	}
	return nil
}

// Filters for requests that are not health check requests. A health check
// request is marked by the health check filter.
type NotHealthCheckFilter struct {
}

func (m *NotHealthCheckFilter) Reset()                    { *m = NotHealthCheckFilter{} }
func (m *NotHealthCheckFilter) String() string            { return proto.CompactTextString(m) }
func (*NotHealthCheckFilter) ProtoMessage()               {}
func (*NotHealthCheckFilter) Descriptor() ([]byte, []int) { return fileDescriptorAccesslog, []int{12} }

// Filters for requests that are traceable. See the tracing overview for more
// information on how a request becomes traceable.
type TraceableFilter struct {
}

func (m *TraceableFilter) Reset()                    { *m = TraceableFilter{} }
func (m *TraceableFilter) String() string            { return proto.CompactTextString(m) }
func (*TraceableFilter) ProtoMessage()               {}
func (*TraceableFilter) Descriptor() ([]byte, []int) { return fileDescriptorAccesslog, []int{13} }

// Filters for random sampling of requests. Sampling pivots on the header
// :ref:`x-request-id<config_http_conn_man_headers_x-request-id>` being present. If
// :ref:`x-request-id<config_http_conn_man_headers_x-request-id>` is present, the filter will
// consistently sample across multiple hosts based on the runtime key value and the value extracted
// from :ref:`x-request-id<config_http_conn_man_headers_x-request-id>`. If it is missing, the
// filter will randomly sample based on the runtime key value.
type RuntimeFilter struct {
	// Runtime key to get the percentage of requests to be sampled. This runtime
	// control is specified in the range 0-100 and defaults to 0.
	RuntimeKey string `protobuf:"bytes,1,opt,name=runtime_key,json=runtimeKey,proto3" json:"runtime_key,omitempty"`
}

func (m *RuntimeFilter) Reset()                    { *m = RuntimeFilter{} }
func (m *RuntimeFilter) String() string            { return proto.CompactTextString(m) }
func (*RuntimeFilter) ProtoMessage()               {}
func (*RuntimeFilter) Descriptor() ([]byte, []int) { return fileDescriptorAccesslog, []int{14} }

func (m *RuntimeFilter) GetRuntimeKey() string {
	if m != nil {
		return m.RuntimeKey
	}
	return ""
}

// Performs a logical “and” operation on the result of each filter in filters.
// Filters are evaluated sequentially and if one of them returns false, the
// filter returns false immediately.
type AndFilter struct {
	Filters []*AccessLogFilter `protobuf:"bytes,1,rep,name=filters" json:"filters,omitempty"`
}

func (m *AndFilter) Reset()                    { *m = AndFilter{} }
func (m *AndFilter) String() string            { return proto.CompactTextString(m) }
func (*AndFilter) ProtoMessage()               {}
func (*AndFilter) Descriptor() ([]byte, []int) { return fileDescriptorAccesslog, []int{15} }

func (m *AndFilter) GetFilters() []*AccessLogFilter {
	if m != nil {
		return m.Filters
	}
	return nil
}

// Performs a logical “or” operation on the result of each individual filter.
// Filters are evaluated sequentially and if one of them returns true, the
// filter returns true immediately.
type OrFilter struct {
	Filters []*AccessLogFilter `protobuf:"bytes,2,rep,name=filters" json:"filters,omitempty"`
}

func (m *OrFilter) Reset()                    { *m = OrFilter{} }
func (m *OrFilter) String() string            { return proto.CompactTextString(m) }
func (*OrFilter) ProtoMessage()               {}
func (*OrFilter) Descriptor() ([]byte, []int) { return fileDescriptorAccesslog, []int{16} }

func (m *OrFilter) GetFilters() []*AccessLogFilter {
	if m != nil {
		return m.Filters
	}
	return nil
}

// Custom configuration for an AccessLog that writes log entries directly to a file.
// Configures the built-in *envoy.file_access_log* AccessLog.
type FileAccessLog struct {
	// A path to a local file to which to write the access log entries.
	Path string `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	// Access log format. Envoy supports :ref:`custom access log formats
	// <config_access_log_format>` as well as a :ref:`default format
	// <config_access_log_default_format>`.
	Format string `protobuf:"bytes,2,opt,name=format,proto3" json:"format,omitempty"`
}

func (m *FileAccessLog) Reset()                    { *m = FileAccessLog{} }
func (m *FileAccessLog) String() string            { return proto.CompactTextString(m) }
func (*FileAccessLog) ProtoMessage()               {}
func (*FileAccessLog) Descriptor() ([]byte, []int) { return fileDescriptorAccesslog, []int{17} }

func (m *FileAccessLog) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *FileAccessLog) GetFormat() string {
	if m != nil {
		return m.Format
	}
	return ""
}

// Configuration for the built-in "envoy.grpc_access_log" access log type.
// [#not-implemented-hide:]
type AccessLogServiceConfig struct {
	// The friendly name of the access log to be returned in StreamAccessLogsMessage.Identifier. This
	// allows the access log server to differentiate between different access logs coming from the
	// same Envoy.
	LogName string `protobuf:"bytes,1,opt,name=log_name,json=logName,proto3" json:"log_name,omitempty"`
	// The name of the upstream cluster that hosts the access log service. The cluster must be
	// configured in the cluster manager.
	ClusterName string `protobuf:"bytes,2,opt,name=cluster_name,json=clusterName,proto3" json:"cluster_name,omitempty"`
}

func (m *AccessLogServiceConfig) Reset()                    { *m = AccessLogServiceConfig{} }
func (m *AccessLogServiceConfig) String() string            { return proto.CompactTextString(m) }
func (*AccessLogServiceConfig) ProtoMessage()               {}
func (*AccessLogServiceConfig) Descriptor() ([]byte, []int) { return fileDescriptorAccesslog, []int{18} }

func (m *AccessLogServiceConfig) GetLogName() string {
	if m != nil {
		return m.LogName
	}
	return ""
}

func (m *AccessLogServiceConfig) GetClusterName() string {
	if m != nil {
		return m.ClusterName
	}
	return ""
}

// [#proto-status: experimental]
// [#not-implemented-hide:] Not configuration. TBD how to doc proto APIs.
// Stream message for the StreamAccessLogs API. Envoy will open a stream to the server and stream
// access logs without ever expecting a response.
type StreamAccessLogsMessage struct {
	// Identifier data that will only be sent in the first message on the stream. This is effectively
	// structured metadata and is a performance optimization.
	Identifier *StreamAccessLogsMessage_Identifier `protobuf:"bytes,1,opt,name=identifier" json:"identifier,omitempty"`
	// Batches of log entries of a single type. Generally speaking, a given stream should only
	// ever incude one type of log entry.
	//
	// Types that are valid to be assigned to LogEntries:
	//	*StreamAccessLogsMessage_HttpLogs
	//	*StreamAccessLogsMessage_TcpLogs
	LogEntries isStreamAccessLogsMessage_LogEntries `protobuf_oneof:"log_entries"`
}

func (m *StreamAccessLogsMessage) Reset()         { *m = StreamAccessLogsMessage{} }
func (m *StreamAccessLogsMessage) String() string { return proto.CompactTextString(m) }
func (*StreamAccessLogsMessage) ProtoMessage()    {}
func (*StreamAccessLogsMessage) Descriptor() ([]byte, []int) {
	return fileDescriptorAccesslog, []int{19}
}

type isStreamAccessLogsMessage_LogEntries interface {
	isStreamAccessLogsMessage_LogEntries()
	MarshalTo([]byte) (int, error)
	Size() int
}

type StreamAccessLogsMessage_HttpLogs struct {
	HttpLogs *StreamAccessLogsMessage_HTTPAccessLogEntries `protobuf:"bytes,2,opt,name=http_logs,json=httpLogs,oneof"`
}
type StreamAccessLogsMessage_TcpLogs struct {
	TcpLogs *StreamAccessLogsMessage_TCPAccessLogEntries `protobuf:"bytes,3,opt,name=tcp_logs,json=tcpLogs,oneof"`
}

func (*StreamAccessLogsMessage_HttpLogs) isStreamAccessLogsMessage_LogEntries() {}
func (*StreamAccessLogsMessage_TcpLogs) isStreamAccessLogsMessage_LogEntries()  {}

func (m *StreamAccessLogsMessage) GetLogEntries() isStreamAccessLogsMessage_LogEntries {
	if m != nil {
		return m.LogEntries
	}
	return nil
}

func (m *StreamAccessLogsMessage) GetIdentifier() *StreamAccessLogsMessage_Identifier {
	if m != nil {
		return m.Identifier
	}
	return nil
}

func (m *StreamAccessLogsMessage) GetHttpLogs() *StreamAccessLogsMessage_HTTPAccessLogEntries {
	if x, ok := m.GetLogEntries().(*StreamAccessLogsMessage_HttpLogs); ok {
		return x.HttpLogs
	}
	return nil
}

func (m *StreamAccessLogsMessage) GetTcpLogs() *StreamAccessLogsMessage_TCPAccessLogEntries {
	if x, ok := m.GetLogEntries().(*StreamAccessLogsMessage_TcpLogs); ok {
		return x.TcpLogs
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*StreamAccessLogsMessage) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _StreamAccessLogsMessage_OneofMarshaler, _StreamAccessLogsMessage_OneofUnmarshaler, _StreamAccessLogsMessage_OneofSizer, []interface{}{
		(*StreamAccessLogsMessage_HttpLogs)(nil),
		(*StreamAccessLogsMessage_TcpLogs)(nil),
	}
}

func _StreamAccessLogsMessage_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*StreamAccessLogsMessage)
	// log_entries
	switch x := m.LogEntries.(type) {
	case *StreamAccessLogsMessage_HttpLogs:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.HttpLogs); err != nil {
			return err
		}
	case *StreamAccessLogsMessage_TcpLogs:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TcpLogs); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("StreamAccessLogsMessage.LogEntries has unexpected type %T", x)
	}
	return nil
}

func _StreamAccessLogsMessage_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*StreamAccessLogsMessage)
	switch tag {
	case 2: // log_entries.http_logs
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(StreamAccessLogsMessage_HTTPAccessLogEntries)
		err := b.DecodeMessage(msg)
		m.LogEntries = &StreamAccessLogsMessage_HttpLogs{msg}
		return true, err
	case 3: // log_entries.tcp_logs
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(StreamAccessLogsMessage_TCPAccessLogEntries)
		err := b.DecodeMessage(msg)
		m.LogEntries = &StreamAccessLogsMessage_TcpLogs{msg}
		return true, err
	default:
		return false, nil
	}
}

func _StreamAccessLogsMessage_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*StreamAccessLogsMessage)
	// log_entries
	switch x := m.LogEntries.(type) {
	case *StreamAccessLogsMessage_HttpLogs:
		s := proto.Size(x.HttpLogs)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *StreamAccessLogsMessage_TcpLogs:
		s := proto.Size(x.TcpLogs)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type StreamAccessLogsMessage_Identifier struct {
	// The node sending the access log messages over the stream.
	Node *envoy_api_v21.Node `protobuf:"bytes,1,opt,name=node" json:"node,omitempty"`
	// The friendly name of the log configured in AccessLogServiceConfig.
	LogName string `protobuf:"bytes,2,opt,name=log_name,json=logName,proto3" json:"log_name,omitempty"`
}

func (m *StreamAccessLogsMessage_Identifier) Reset()         { *m = StreamAccessLogsMessage_Identifier{} }
func (m *StreamAccessLogsMessage_Identifier) String() string { return proto.CompactTextString(m) }
func (*StreamAccessLogsMessage_Identifier) ProtoMessage()    {}
func (*StreamAccessLogsMessage_Identifier) Descriptor() ([]byte, []int) {
	return fileDescriptorAccesslog, []int{19, 0}
}

func (m *StreamAccessLogsMessage_Identifier) GetNode() *envoy_api_v21.Node {
	if m != nil {
		return m.Node
	}
	return nil
}

func (m *StreamAccessLogsMessage_Identifier) GetLogName() string {
	if m != nil {
		return m.LogName
	}
	return ""
}

// Wrapper for batches of HTTP access log entries.
type StreamAccessLogsMessage_HTTPAccessLogEntries struct {
	LogEntry []*HTTPAccessLogEntry `protobuf:"bytes,1,rep,name=log_entry,json=logEntry" json:"log_entry,omitempty"`
}

func (m *StreamAccessLogsMessage_HTTPAccessLogEntries) Reset() {
	*m = StreamAccessLogsMessage_HTTPAccessLogEntries{}
}
func (m *StreamAccessLogsMessage_HTTPAccessLogEntries) String() string {
	return proto.CompactTextString(m)
}
func (*StreamAccessLogsMessage_HTTPAccessLogEntries) ProtoMessage() {}
func (*StreamAccessLogsMessage_HTTPAccessLogEntries) Descriptor() ([]byte, []int) {
	return fileDescriptorAccesslog, []int{19, 1}
}

func (m *StreamAccessLogsMessage_HTTPAccessLogEntries) GetLogEntry() []*HTTPAccessLogEntry {
	if m != nil {
		return m.LogEntry
	}
	return nil
}

// Wrapper for batches of TCP access log entries.
type StreamAccessLogsMessage_TCPAccessLogEntries struct {
	LogEntry []*TCPAccessLogEntry `protobuf:"bytes,1,rep,name=log_entry,json=logEntry" json:"log_entry,omitempty"`
}

func (m *StreamAccessLogsMessage_TCPAccessLogEntries) Reset() {
	*m = StreamAccessLogsMessage_TCPAccessLogEntries{}
}
func (m *StreamAccessLogsMessage_TCPAccessLogEntries) String() string {
	return proto.CompactTextString(m)
}
func (*StreamAccessLogsMessage_TCPAccessLogEntries) ProtoMessage() {}
func (*StreamAccessLogsMessage_TCPAccessLogEntries) Descriptor() ([]byte, []int) {
	return fileDescriptorAccesslog, []int{19, 2}
}

func (m *StreamAccessLogsMessage_TCPAccessLogEntries) GetLogEntry() []*TCPAccessLogEntry {
	if m != nil {
		return m.LogEntry
	}
	return nil
}

// Empty response for the StreamAccessLogs API. Will never be sent. See below.
// [#not-implemented-hide:] Not configuration. TBD how to doc proto APIs.
type StreamAccessLogsResponse struct {
}

func (m *StreamAccessLogsResponse) Reset()         { *m = StreamAccessLogsResponse{} }
func (m *StreamAccessLogsResponse) String() string { return proto.CompactTextString(m) }
func (*StreamAccessLogsResponse) ProtoMessage()    {}
func (*StreamAccessLogsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorAccesslog, []int{20}
}

func init() {
	proto.RegisterType((*AccessLogCommon)(nil), "envoy.api.v2.filter.accesslog.AccessLogCommon")
	proto.RegisterType((*ResponseFlags)(nil), "envoy.api.v2.filter.accesslog.ResponseFlags")
	proto.RegisterType((*TLSProperties)(nil), "envoy.api.v2.filter.accesslog.TLSProperties")
	proto.RegisterType((*TCPAccessLogEntry)(nil), "envoy.api.v2.filter.accesslog.TCPAccessLogEntry")
	proto.RegisterType((*HTTPRequestProperties)(nil), "envoy.api.v2.filter.accesslog.HTTPRequestProperties")
	proto.RegisterType((*HTTPResponseProperties)(nil), "envoy.api.v2.filter.accesslog.HTTPResponseProperties")
	proto.RegisterType((*HTTPAccessLogEntry)(nil), "envoy.api.v2.filter.accesslog.HTTPAccessLogEntry")
	proto.RegisterType((*AccessLog)(nil), "envoy.api.v2.filter.accesslog.AccessLog")
	proto.RegisterType((*AccessLogFilter)(nil), "envoy.api.v2.filter.accesslog.AccessLogFilter")
	proto.RegisterType((*ComparisonFilter)(nil), "envoy.api.v2.filter.accesslog.ComparisonFilter")
	proto.RegisterType((*StatusCodeFilter)(nil), "envoy.api.v2.filter.accesslog.StatusCodeFilter")
	proto.RegisterType((*DurationFilter)(nil), "envoy.api.v2.filter.accesslog.DurationFilter")
	proto.RegisterType((*NotHealthCheckFilter)(nil), "envoy.api.v2.filter.accesslog.NotHealthCheckFilter")
	proto.RegisterType((*TraceableFilter)(nil), "envoy.api.v2.filter.accesslog.TraceableFilter")
	proto.RegisterType((*RuntimeFilter)(nil), "envoy.api.v2.filter.accesslog.RuntimeFilter")
	proto.RegisterType((*AndFilter)(nil), "envoy.api.v2.filter.accesslog.AndFilter")
	proto.RegisterType((*OrFilter)(nil), "envoy.api.v2.filter.accesslog.OrFilter")
	proto.RegisterType((*FileAccessLog)(nil), "envoy.api.v2.filter.accesslog.FileAccessLog")
	proto.RegisterType((*AccessLogServiceConfig)(nil), "envoy.api.v2.filter.accesslog.AccessLogServiceConfig")
	proto.RegisterType((*StreamAccessLogsMessage)(nil), "envoy.api.v2.filter.accesslog.StreamAccessLogsMessage")
	proto.RegisterType((*StreamAccessLogsMessage_Identifier)(nil), "envoy.api.v2.filter.accesslog.StreamAccessLogsMessage.Identifier")
	proto.RegisterType((*StreamAccessLogsMessage_HTTPAccessLogEntries)(nil), "envoy.api.v2.filter.accesslog.StreamAccessLogsMessage.HTTPAccessLogEntries")
	proto.RegisterType((*StreamAccessLogsMessage_TCPAccessLogEntries)(nil), "envoy.api.v2.filter.accesslog.StreamAccessLogsMessage.TCPAccessLogEntries")
	proto.RegisterType((*StreamAccessLogsResponse)(nil), "envoy.api.v2.filter.accesslog.StreamAccessLogsResponse")
	proto.RegisterEnum("envoy.api.v2.filter.accesslog.TLSProperties_TLSVersion", TLSProperties_TLSVersion_name, TLSProperties_TLSVersion_value)
	proto.RegisterEnum("envoy.api.v2.filter.accesslog.HTTPAccessLogEntry_HTTPVersion", HTTPAccessLogEntry_HTTPVersion_name, HTTPAccessLogEntry_HTTPVersion_value)
	proto.RegisterEnum("envoy.api.v2.filter.accesslog.ComparisonFilter_Op", ComparisonFilter_Op_name, ComparisonFilter_Op_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for AccessLogService service

type AccessLogServiceClient interface {
	// Envoy will connect and send StreamAccessLogsMessage messages forever. It does not expect any
	// response to be sent as nothing would be done in the case of failure. The server should
	// disconnect if it expects Envoy to reconnect. In the future we may decide to add a different
	// API for "critical" access logs in which Envoy will buffer access logs for some period of time
	// until it gets an ACK so it could then retry. This API is designed for high throughput with the
	// expectation that it might be lossy.
	StreamAccessLogs(ctx context.Context, opts ...grpc.CallOption) (AccessLogService_StreamAccessLogsClient, error)
}

type accessLogServiceClient struct {
	cc *grpc.ClientConn
}

func NewAccessLogServiceClient(cc *grpc.ClientConn) AccessLogServiceClient {
	return &accessLogServiceClient{cc}
}

func (c *accessLogServiceClient) StreamAccessLogs(ctx context.Context, opts ...grpc.CallOption) (AccessLogService_StreamAccessLogsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_AccessLogService_serviceDesc.Streams[0], c.cc, "/envoy.api.v2.filter.accesslog.AccessLogService/StreamAccessLogs", opts...)
	if err != nil {
		return nil, err
	}
	x := &accessLogServiceStreamAccessLogsClient{stream}
	return x, nil
}

type AccessLogService_StreamAccessLogsClient interface {
	Send(*StreamAccessLogsMessage) error
	CloseAndRecv() (*StreamAccessLogsResponse, error)
	grpc.ClientStream
}

type accessLogServiceStreamAccessLogsClient struct {
	grpc.ClientStream
}

func (x *accessLogServiceStreamAccessLogsClient) Send(m *StreamAccessLogsMessage) error {
	return x.ClientStream.SendMsg(m)
}

func (x *accessLogServiceStreamAccessLogsClient) CloseAndRecv() (*StreamAccessLogsResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(StreamAccessLogsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for AccessLogService service

type AccessLogServiceServer interface {
	// Envoy will connect and send StreamAccessLogsMessage messages forever. It does not expect any
	// response to be sent as nothing would be done in the case of failure. The server should
	// disconnect if it expects Envoy to reconnect. In the future we may decide to add a different
	// API for "critical" access logs in which Envoy will buffer access logs for some period of time
	// until it gets an ACK so it could then retry. This API is designed for high throughput with the
	// expectation that it might be lossy.
	StreamAccessLogs(AccessLogService_StreamAccessLogsServer) error
}

func RegisterAccessLogServiceServer(s *grpc.Server, srv AccessLogServiceServer) {
	s.RegisterService(&_AccessLogService_serviceDesc, srv)
}

func _AccessLogService_StreamAccessLogs_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(AccessLogServiceServer).StreamAccessLogs(&accessLogServiceStreamAccessLogsServer{stream})
}

type AccessLogService_StreamAccessLogsServer interface {
	SendAndClose(*StreamAccessLogsResponse) error
	Recv() (*StreamAccessLogsMessage, error)
	grpc.ServerStream
}

type accessLogServiceStreamAccessLogsServer struct {
	grpc.ServerStream
}

func (x *accessLogServiceStreamAccessLogsServer) SendAndClose(m *StreamAccessLogsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *accessLogServiceStreamAccessLogsServer) Recv() (*StreamAccessLogsMessage, error) {
	m := new(StreamAccessLogsMessage)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _AccessLogService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "envoy.api.v2.filter.accesslog.AccessLogService",
	HandlerType: (*AccessLogServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamAccessLogs",
			Handler:       _AccessLogService_StreamAccessLogs_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "api/filter/accesslog/accesslog.proto",
}

func (m *AccessLogCommon) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccessLogCommon) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SampleRate != 0 {
		dAtA[i] = 0x9
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.SampleRate))))
		i += 8
	}
	if m.DestinationHost != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(m.DestinationHost.Size()))
		n1, err := m.DestinationHost.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.TlsProperties != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(m.TlsProperties.Size()))
		n2, err := m.TlsProperties.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.StartTime != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(m.StartTime.Size()))
		n3, err := m.StartTime.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.TimeToLastRxByte != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(m.TimeToLastRxByte.Size()))
		n4, err := m.TimeToLastRxByte.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.TimeToFirstUpstreamRxByte != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(m.TimeToFirstUpstreamRxByte.Size()))
		n5, err := m.TimeToFirstUpstreamRxByte.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.TimeToLastUpstreamRxByte != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(m.TimeToLastUpstreamRxByte.Size()))
		n6, err := m.TimeToLastUpstreamRxByte.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.UpstreamHost != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(m.UpstreamHost.Size()))
		n7, err := m.UpstreamHost.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if len(m.UpstreamCluster) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(len(m.UpstreamCluster)))
		i += copy(dAtA[i:], m.UpstreamCluster)
	}
	if m.ResponseFlags != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(m.ResponseFlags.Size()))
		n8, err := m.ResponseFlags.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.Metadata != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(m.Metadata.Size()))
		n9, err := m.Metadata.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}

func (m *ResponseFlags) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponseFlags) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FailedLocalHealthcheck {
		dAtA[i] = 0x8
		i++
		if m.FailedLocalHealthcheck {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.NoHealthyUpstream {
		dAtA[i] = 0x10
		i++
		if m.NoHealthyUpstream {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.UpstreamRequestTimeout {
		dAtA[i] = 0x18
		i++
		if m.UpstreamRequestTimeout {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.LocalReset {
		dAtA[i] = 0x20
		i++
		if m.LocalReset {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.UpstreamRemoteReset {
		dAtA[i] = 0x28
		i++
		if m.UpstreamRemoteReset {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.UpstreamConnectionFailure {
		dAtA[i] = 0x30
		i++
		if m.UpstreamConnectionFailure {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.UpstreamConnectionTermination {
		dAtA[i] = 0x38
		i++
		if m.UpstreamConnectionTermination {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.UpstreamOverflow {
		dAtA[i] = 0x40
		i++
		if m.UpstreamOverflow {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.NoRouteFound {
		dAtA[i] = 0x48
		i++
		if m.NoRouteFound {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DelayInjected {
		dAtA[i] = 0x50
		i++
		if m.DelayInjected {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.FaultInjected {
		dAtA[i] = 0x58
		i++
		if m.FaultInjected {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.RateLimited {
		dAtA[i] = 0x60
		i++
		if m.RateLimited {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *TLSProperties) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLSProperties) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TlsVersion != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(m.TlsVersion))
	}
	if m.TlsCipherSuite != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(m.TlsCipherSuite.Size()))
		n10, err := m.TlsCipherSuite.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if len(m.TlsSniHostname) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(len(m.TlsSniHostname)))
		i += copy(dAtA[i:], m.TlsSniHostname)
	}
	return i, nil
}

func (m *TCPAccessLogEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TCPAccessLogEntry) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CommonProperties != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(m.CommonProperties.Size()))
		n11, err := m.CommonProperties.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}

func (m *HTTPRequestProperties) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HTTPRequestProperties) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RequestMethod != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(m.RequestMethod))
	}
	if len(m.Scheme) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(len(m.Scheme)))
		i += copy(dAtA[i:], m.Scheme)
	}
	if len(m.Authority) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(len(m.Authority)))
		i += copy(dAtA[i:], m.Authority)
	}
	if m.Port != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(m.Port.Size()))
		n12, err := m.Port.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if len(m.Path) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(len(m.Path)))
		i += copy(dAtA[i:], m.Path)
	}
	if len(m.UserAgent) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(len(m.UserAgent)))
		i += copy(dAtA[i:], m.UserAgent)
	}
	if len(m.Referer) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(len(m.Referer)))
		i += copy(dAtA[i:], m.Referer)
	}
	if len(m.ForwardedFor) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(len(m.ForwardedFor)))
		i += copy(dAtA[i:], m.ForwardedFor)
	}
	if len(m.RequestId) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(len(m.RequestId)))
		i += copy(dAtA[i:], m.RequestId)
	}
	if len(m.OriginalPath) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(len(m.OriginalPath)))
		i += copy(dAtA[i:], m.OriginalPath)
	}
	if m.RequestHeadersBytes != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(m.RequestHeadersBytes))
	}
	if m.RequestBodyBytes != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(m.RequestBodyBytes))
	}
	if len(m.RequestHeaders) > 0 {
		for k, _ := range m.RequestHeaders {
			dAtA[i] = 0x6a
			i++
			v := m.RequestHeaders[k]
			mapSize := 1 + len(k) + sovAccesslog(uint64(len(k))) + 1 + len(v) + sovAccesslog(uint64(len(v)))
			i = encodeVarintAccesslog(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintAccesslog(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintAccesslog(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	return i, nil
}

func (m *HTTPResponseProperties) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HTTPResponseProperties) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ResponseCode != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(m.ResponseCode.Size()))
		n13, err := m.ResponseCode.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.ResponseHeadersBytes != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(m.ResponseHeadersBytes))
	}
	if m.ResponseBodyBytes != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(m.ResponseBodyBytes))
	}
	if len(m.ResponseHeaders) > 0 {
		for k, _ := range m.ResponseHeaders {
			dAtA[i] = 0x22
			i++
			v := m.ResponseHeaders[k]
			mapSize := 1 + len(k) + sovAccesslog(uint64(len(k))) + 1 + len(v) + sovAccesslog(uint64(len(v)))
			i = encodeVarintAccesslog(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintAccesslog(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintAccesslog(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	return i, nil
}

func (m *HTTPAccessLogEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HTTPAccessLogEntry) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CommonProperties != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(m.CommonProperties.Size()))
		n14, err := m.CommonProperties.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.ProtocolVersion != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(m.ProtocolVersion))
	}
	if m.Request != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(m.Request.Size()))
		n15, err := m.Request.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.Response != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(m.Response.Size()))
		n16, err := m.Response.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	return i, nil
}

func (m *AccessLog) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccessLog) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Filter != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(m.Filter.Size()))
		n17, err := m.Filter.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if m.Config != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(m.Config.Size()))
		n18, err := m.Config.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	return i, nil
}

func (m *AccessLogFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccessLogFilter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FilterSpecifier != nil {
		nn19, err := m.FilterSpecifier.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn19
	}
	return i, nil
}

func (m *AccessLogFilter_StatusCodeFilter) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.StatusCodeFilter != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(m.StatusCodeFilter.Size()))
		n20, err := m.StatusCodeFilter.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	return i, nil
}
func (m *AccessLogFilter_DurationFilter) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DurationFilter != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(m.DurationFilter.Size()))
		n21, err := m.DurationFilter.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	return i, nil
}
func (m *AccessLogFilter_NotHealthCheckFilter) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NotHealthCheckFilter != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(m.NotHealthCheckFilter.Size()))
		n22, err := m.NotHealthCheckFilter.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	return i, nil
}
func (m *AccessLogFilter_TraceableFilter) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.TraceableFilter != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(m.TraceableFilter.Size()))
		n23, err := m.TraceableFilter.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	return i, nil
}
func (m *AccessLogFilter_RuntimeFilter) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.RuntimeFilter != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(m.RuntimeFilter.Size()))
		n24, err := m.RuntimeFilter.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	return i, nil
}
func (m *AccessLogFilter_AndFilter) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.AndFilter != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(m.AndFilter.Size()))
		n25, err := m.AndFilter.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	return i, nil
}
func (m *AccessLogFilter_OrFilter) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.OrFilter != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(m.OrFilter.Size()))
		n26, err := m.OrFilter.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	return i, nil
}
func (m *ComparisonFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ComparisonFilter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Op != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(m.Op))
	}
	if m.Value != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(m.Value.Size()))
		n27, err := m.Value.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	return i, nil
}

func (m *StatusCodeFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatusCodeFilter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Comparison != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(m.Comparison.Size()))
		n28, err := m.Comparison.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	return i, nil
}

func (m *DurationFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DurationFilter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Comparison != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(m.Comparison.Size()))
		n29, err := m.Comparison.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	return i, nil
}

func (m *NotHealthCheckFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NotHealthCheckFilter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *TraceableFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TraceableFilter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *RuntimeFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RuntimeFilter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RuntimeKey) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(len(m.RuntimeKey)))
		i += copy(dAtA[i:], m.RuntimeKey)
	}
	return i, nil
}

func (m *AndFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AndFilter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Filters) > 0 {
		for _, msg := range m.Filters {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAccesslog(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *OrFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrFilter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Filters) > 0 {
		for _, msg := range m.Filters {
			dAtA[i] = 0x12
			i++
			i = encodeVarintAccesslog(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *FileAccessLog) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileAccessLog) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Path) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(len(m.Path)))
		i += copy(dAtA[i:], m.Path)
	}
	if len(m.Format) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(len(m.Format)))
		i += copy(dAtA[i:], m.Format)
	}
	return i, nil
}

func (m *AccessLogServiceConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccessLogServiceConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.LogName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(len(m.LogName)))
		i += copy(dAtA[i:], m.LogName)
	}
	if len(m.ClusterName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(len(m.ClusterName)))
		i += copy(dAtA[i:], m.ClusterName)
	}
	return i, nil
}

func (m *StreamAccessLogsMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamAccessLogsMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Identifier != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(m.Identifier.Size()))
		n30, err := m.Identifier.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	if m.LogEntries != nil {
		nn31, err := m.LogEntries.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn31
	}
	return i, nil
}

func (m *StreamAccessLogsMessage_HttpLogs) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.HttpLogs != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(m.HttpLogs.Size()))
		n32, err := m.HttpLogs.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	return i, nil
}
func (m *StreamAccessLogsMessage_TcpLogs) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.TcpLogs != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(m.TcpLogs.Size()))
		n33, err := m.TcpLogs.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	return i, nil
}
func (m *StreamAccessLogsMessage_Identifier) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamAccessLogsMessage_Identifier) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Node != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(m.Node.Size()))
		n34, err := m.Node.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n34
	}
	if len(m.LogName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(len(m.LogName)))
		i += copy(dAtA[i:], m.LogName)
	}
	return i, nil
}

func (m *StreamAccessLogsMessage_HTTPAccessLogEntries) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamAccessLogsMessage_HTTPAccessLogEntries) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.LogEntry) > 0 {
		for _, msg := range m.LogEntry {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAccesslog(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *StreamAccessLogsMessage_TCPAccessLogEntries) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamAccessLogsMessage_TCPAccessLogEntries) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.LogEntry) > 0 {
		for _, msg := range m.LogEntry {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAccesslog(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *StreamAccessLogsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamAccessLogsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func encodeVarintAccesslog(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *AccessLogCommon) Size() (n int) {
	var l int
	_ = l
	if m.SampleRate != 0 {
		n += 9
	}
	if m.DestinationHost != nil {
		l = m.DestinationHost.Size()
		n += 1 + l + sovAccesslog(uint64(l))
	}
	if m.TlsProperties != nil {
		l = m.TlsProperties.Size()
		n += 1 + l + sovAccesslog(uint64(l))
	}
	if m.StartTime != nil {
		l = m.StartTime.Size()
		n += 1 + l + sovAccesslog(uint64(l))
	}
	if m.TimeToLastRxByte != nil {
		l = m.TimeToLastRxByte.Size()
		n += 1 + l + sovAccesslog(uint64(l))
	}
	if m.TimeToFirstUpstreamRxByte != nil {
		l = m.TimeToFirstUpstreamRxByte.Size()
		n += 1 + l + sovAccesslog(uint64(l))
	}
	if m.TimeToLastUpstreamRxByte != nil {
		l = m.TimeToLastUpstreamRxByte.Size()
		n += 1 + l + sovAccesslog(uint64(l))
	}
	if m.UpstreamHost != nil {
		l = m.UpstreamHost.Size()
		n += 1 + l + sovAccesslog(uint64(l))
	}
	l = len(m.UpstreamCluster)
	if l > 0 {
		n += 1 + l + sovAccesslog(uint64(l))
	}
	if m.ResponseFlags != nil {
		l = m.ResponseFlags.Size()
		n += 1 + l + sovAccesslog(uint64(l))
	}
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovAccesslog(uint64(l))
	}
	return n
}

func (m *ResponseFlags) Size() (n int) {
	var l int
	_ = l
	if m.FailedLocalHealthcheck {
		n += 2
	}
	if m.NoHealthyUpstream {
		n += 2
	}
	if m.UpstreamRequestTimeout {
		n += 2
	}
	if m.LocalReset {
		n += 2
	}
	if m.UpstreamRemoteReset {
		n += 2
	}
	if m.UpstreamConnectionFailure {
		n += 2
	}
	if m.UpstreamConnectionTermination {
		n += 2
	}
	if m.UpstreamOverflow {
		n += 2
	}
	if m.NoRouteFound {
		n += 2
	}
	if m.DelayInjected {
		n += 2
	}
	if m.FaultInjected {
		n += 2
	}
	if m.RateLimited {
		n += 2
	}
	return n
}

func (m *TLSProperties) Size() (n int) {
	var l int
	_ = l
	if m.TlsVersion != 0 {
		n += 1 + sovAccesslog(uint64(m.TlsVersion))
	}
	if m.TlsCipherSuite != nil {
		l = m.TlsCipherSuite.Size()
		n += 1 + l + sovAccesslog(uint64(l))
	}
	l = len(m.TlsSniHostname)
	if l > 0 {
		n += 1 + l + sovAccesslog(uint64(l))
	}
	return n
}

func (m *TCPAccessLogEntry) Size() (n int) {
	var l int
	_ = l
	if m.CommonProperties != nil {
		l = m.CommonProperties.Size()
		n += 1 + l + sovAccesslog(uint64(l))
	}
	return n
}

func (m *HTTPRequestProperties) Size() (n int) {
	var l int
	_ = l
	if m.RequestMethod != 0 {
		n += 1 + sovAccesslog(uint64(m.RequestMethod))
	}
	l = len(m.Scheme)
	if l > 0 {
		n += 1 + l + sovAccesslog(uint64(l))
	}
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovAccesslog(uint64(l))
	}
	if m.Port != nil {
		l = m.Port.Size()
		n += 1 + l + sovAccesslog(uint64(l))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovAccesslog(uint64(l))
	}
	l = len(m.UserAgent)
	if l > 0 {
		n += 1 + l + sovAccesslog(uint64(l))
	}
	l = len(m.Referer)
	if l > 0 {
		n += 1 + l + sovAccesslog(uint64(l))
	}
	l = len(m.ForwardedFor)
	if l > 0 {
		n += 1 + l + sovAccesslog(uint64(l))
	}
	l = len(m.RequestId)
	if l > 0 {
		n += 1 + l + sovAccesslog(uint64(l))
	}
	l = len(m.OriginalPath)
	if l > 0 {
		n += 1 + l + sovAccesslog(uint64(l))
	}
	if m.RequestHeadersBytes != 0 {
		n += 1 + sovAccesslog(uint64(m.RequestHeadersBytes))
	}
	if m.RequestBodyBytes != 0 {
		n += 1 + sovAccesslog(uint64(m.RequestBodyBytes))
	}
	if len(m.RequestHeaders) > 0 {
		for k, v := range m.RequestHeaders {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAccesslog(uint64(len(k))) + 1 + len(v) + sovAccesslog(uint64(len(v)))
			n += mapEntrySize + 1 + sovAccesslog(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *HTTPResponseProperties) Size() (n int) {
	var l int
	_ = l
	if m.ResponseCode != nil {
		l = m.ResponseCode.Size()
		n += 1 + l + sovAccesslog(uint64(l))
	}
	if m.ResponseHeadersBytes != 0 {
		n += 1 + sovAccesslog(uint64(m.ResponseHeadersBytes))
	}
	if m.ResponseBodyBytes != 0 {
		n += 1 + sovAccesslog(uint64(m.ResponseBodyBytes))
	}
	if len(m.ResponseHeaders) > 0 {
		for k, v := range m.ResponseHeaders {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAccesslog(uint64(len(k))) + 1 + len(v) + sovAccesslog(uint64(len(v)))
			n += mapEntrySize + 1 + sovAccesslog(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *HTTPAccessLogEntry) Size() (n int) {
	var l int
	_ = l
	if m.CommonProperties != nil {
		l = m.CommonProperties.Size()
		n += 1 + l + sovAccesslog(uint64(l))
	}
	if m.ProtocolVersion != 0 {
		n += 1 + sovAccesslog(uint64(m.ProtocolVersion))
	}
	if m.Request != nil {
		l = m.Request.Size()
		n += 1 + l + sovAccesslog(uint64(l))
	}
	if m.Response != nil {
		l = m.Response.Size()
		n += 1 + l + sovAccesslog(uint64(l))
	}
	return n
}

func (m *AccessLog) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAccesslog(uint64(l))
	}
	if m.Filter != nil {
		l = m.Filter.Size()
		n += 1 + l + sovAccesslog(uint64(l))
	}
	if m.Config != nil {
		l = m.Config.Size()
		n += 1 + l + sovAccesslog(uint64(l))
	}
	return n
}

func (m *AccessLogFilter) Size() (n int) {
	var l int
	_ = l
	if m.FilterSpecifier != nil {
		n += m.FilterSpecifier.Size()
	}
	return n
}

func (m *AccessLogFilter_StatusCodeFilter) Size() (n int) {
	var l int
	_ = l
	if m.StatusCodeFilter != nil {
		l = m.StatusCodeFilter.Size()
		n += 1 + l + sovAccesslog(uint64(l))
	}
	return n
}
func (m *AccessLogFilter_DurationFilter) Size() (n int) {
	var l int
	_ = l
	if m.DurationFilter != nil {
		l = m.DurationFilter.Size()
		n += 1 + l + sovAccesslog(uint64(l))
	}
	return n
}
func (m *AccessLogFilter_NotHealthCheckFilter) Size() (n int) {
	var l int
	_ = l
	if m.NotHealthCheckFilter != nil {
		l = m.NotHealthCheckFilter.Size()
		n += 1 + l + sovAccesslog(uint64(l))
	}
	return n
}
func (m *AccessLogFilter_TraceableFilter) Size() (n int) {
	var l int
	_ = l
	if m.TraceableFilter != nil {
		l = m.TraceableFilter.Size()
		n += 1 + l + sovAccesslog(uint64(l))
	}
	return n
}
func (m *AccessLogFilter_RuntimeFilter) Size() (n int) {
	var l int
	_ = l
	if m.RuntimeFilter != nil {
		l = m.RuntimeFilter.Size()
		n += 1 + l + sovAccesslog(uint64(l))
	}
	return n
}
func (m *AccessLogFilter_AndFilter) Size() (n int) {
	var l int
	_ = l
	if m.AndFilter != nil {
		l = m.AndFilter.Size()
		n += 1 + l + sovAccesslog(uint64(l))
	}
	return n
}
func (m *AccessLogFilter_OrFilter) Size() (n int) {
	var l int
	_ = l
	if m.OrFilter != nil {
		l = m.OrFilter.Size()
		n += 1 + l + sovAccesslog(uint64(l))
	}
	return n
}
func (m *ComparisonFilter) Size() (n int) {
	var l int
	_ = l
	if m.Op != 0 {
		n += 1 + sovAccesslog(uint64(m.Op))
	}
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovAccesslog(uint64(l))
	}
	return n
}

func (m *StatusCodeFilter) Size() (n int) {
	var l int
	_ = l
	if m.Comparison != nil {
		l = m.Comparison.Size()
		n += 1 + l + sovAccesslog(uint64(l))
	}
	return n
}

func (m *DurationFilter) Size() (n int) {
	var l int
	_ = l
	if m.Comparison != nil {
		l = m.Comparison.Size()
		n += 1 + l + sovAccesslog(uint64(l))
	}
	return n
}

func (m *NotHealthCheckFilter) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *TraceableFilter) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *RuntimeFilter) Size() (n int) {
	var l int
	_ = l
	l = len(m.RuntimeKey)
	if l > 0 {
		n += 1 + l + sovAccesslog(uint64(l))
	}
	return n
}

func (m *AndFilter) Size() (n int) {
	var l int
	_ = l
	if len(m.Filters) > 0 {
		for _, e := range m.Filters {
			l = e.Size()
			n += 1 + l + sovAccesslog(uint64(l))
		}
	}
	return n
}

func (m *OrFilter) Size() (n int) {
	var l int
	_ = l
	if len(m.Filters) > 0 {
		for _, e := range m.Filters {
			l = e.Size()
			n += 1 + l + sovAccesslog(uint64(l))
		}
	}
	return n
}

func (m *FileAccessLog) Size() (n int) {
	var l int
	_ = l
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovAccesslog(uint64(l))
	}
	l = len(m.Format)
	if l > 0 {
		n += 1 + l + sovAccesslog(uint64(l))
	}
	return n
}

func (m *AccessLogServiceConfig) Size() (n int) {
	var l int
	_ = l
	l = len(m.LogName)
	if l > 0 {
		n += 1 + l + sovAccesslog(uint64(l))
	}
	l = len(m.ClusterName)
	if l > 0 {
		n += 1 + l + sovAccesslog(uint64(l))
	}
	return n
}

func (m *StreamAccessLogsMessage) Size() (n int) {
	var l int
	_ = l
	if m.Identifier != nil {
		l = m.Identifier.Size()
		n += 1 + l + sovAccesslog(uint64(l))
	}
	if m.LogEntries != nil {
		n += m.LogEntries.Size()
	}
	return n
}

func (m *StreamAccessLogsMessage_HttpLogs) Size() (n int) {
	var l int
	_ = l
	if m.HttpLogs != nil {
		l = m.HttpLogs.Size()
		n += 1 + l + sovAccesslog(uint64(l))
	}
	return n
}
func (m *StreamAccessLogsMessage_TcpLogs) Size() (n int) {
	var l int
	_ = l
	if m.TcpLogs != nil {
		l = m.TcpLogs.Size()
		n += 1 + l + sovAccesslog(uint64(l))
	}
	return n
}
func (m *StreamAccessLogsMessage_Identifier) Size() (n int) {
	var l int
	_ = l
	if m.Node != nil {
		l = m.Node.Size()
		n += 1 + l + sovAccesslog(uint64(l))
	}
	l = len(m.LogName)
	if l > 0 {
		n += 1 + l + sovAccesslog(uint64(l))
	}
	return n
}

func (m *StreamAccessLogsMessage_HTTPAccessLogEntries) Size() (n int) {
	var l int
	_ = l
	if len(m.LogEntry) > 0 {
		for _, e := range m.LogEntry {
			l = e.Size()
			n += 1 + l + sovAccesslog(uint64(l))
		}
	}
	return n
}

func (m *StreamAccessLogsMessage_TCPAccessLogEntries) Size() (n int) {
	var l int
	_ = l
	if len(m.LogEntry) > 0 {
		for _, e := range m.LogEntry {
			l = e.Size()
			n += 1 + l + sovAccesslog(uint64(l))
		}
	}
	return n
}

func (m *StreamAccessLogsResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func sovAccesslog(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozAccesslog(x uint64) (n int) {
	return sovAccesslog(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AccessLogCommon) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccesslog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccessLogCommon: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccessLogCommon: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field SampleRate", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.SampleRate = float64(math.Float64frombits(v))
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationHost", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DestinationHost == nil {
				m.DestinationHost = &envoy_api_v2.SocketAddress{}
			}
			if err := m.DestinationHost.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsProperties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TlsProperties == nil {
				m.TlsProperties = &TLSProperties{}
			}
			if err := m.TlsProperties.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartTime == nil {
				m.StartTime = &google_protobuf3.Timestamp{}
			}
			if err := m.StartTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeToLastRxByte", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TimeToLastRxByte == nil {
				m.TimeToLastRxByte = &google_protobuf2.Duration{}
			}
			if err := m.TimeToLastRxByte.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeToFirstUpstreamRxByte", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TimeToFirstUpstreamRxByte == nil {
				m.TimeToFirstUpstreamRxByte = &google_protobuf2.Duration{}
			}
			if err := m.TimeToFirstUpstreamRxByte.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeToLastUpstreamRxByte", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TimeToLastUpstreamRxByte == nil {
				m.TimeToLastUpstreamRxByte = &google_protobuf2.Duration{}
			}
			if err := m.TimeToLastUpstreamRxByte.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpstreamHost", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpstreamHost == nil {
				m.UpstreamHost = &envoy_api_v2.SocketAddress{}
			}
			if err := m.UpstreamHost.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpstreamCluster", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpstreamCluster = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseFlags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResponseFlags == nil {
				m.ResponseFlags = &ResponseFlags{}
			}
			if err := m.ResponseFlags.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &envoy_api_v21.Metadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccesslog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccesslog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponseFlags) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccesslog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseFlags: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseFlags: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailedLocalHealthcheck", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FailedLocalHealthcheck = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoHealthyUpstream", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoHealthyUpstream = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpstreamRequestTimeout", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpstreamRequestTimeout = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalReset", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LocalReset = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpstreamRemoteReset", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpstreamRemoteReset = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpstreamConnectionFailure", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpstreamConnectionFailure = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpstreamConnectionTermination", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpstreamConnectionTermination = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpstreamOverflow", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpstreamOverflow = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoRouteFound", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoRouteFound = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelayInjected", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DelayInjected = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FaultInjected", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FaultInjected = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RateLimited", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RateLimited = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAccesslog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccesslog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLSProperties) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccesslog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TLSProperties: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TLSProperties: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsVersion", wireType)
			}
			m.TlsVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TlsVersion |= (TLSProperties_TLSVersion(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsCipherSuite", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TlsCipherSuite == nil {
				m.TlsCipherSuite = &google_protobuf.UInt32Value{}
			}
			if err := m.TlsCipherSuite.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsSniHostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TlsSniHostname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccesslog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccesslog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TCPAccessLogEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccesslog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TCPAccessLogEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TCPAccessLogEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommonProperties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CommonProperties == nil {
				m.CommonProperties = &AccessLogCommon{}
			}
			if err := m.CommonProperties.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccesslog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccesslog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HTTPRequestProperties) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccesslog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HTTPRequestProperties: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HTTPRequestProperties: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestMethod", wireType)
			}
			m.RequestMethod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestMethod |= (envoy_api_v21.RequestMethod(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scheme", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Scheme = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Port == nil {
				m.Port = &google_protobuf.UInt32Value{}
			}
			if err := m.Port.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserAgent", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserAgent = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Referer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Referer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForwardedFor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ForwardedFor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginalPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OriginalPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeadersBytes", wireType)
			}
			m.RequestHeadersBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestHeadersBytes |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestBodyBytes", wireType)
			}
			m.RequestBodyBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestBodyBytes |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeaders", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RequestHeaders == nil {
				m.RequestHeaders = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAccesslog
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAccesslog
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAccesslog
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAccesslog
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAccesslog
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAccesslog(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthAccesslog
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.RequestHeaders[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccesslog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccesslog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HTTPResponseProperties) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccesslog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HTTPResponseProperties: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HTTPResponseProperties: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseCode", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResponseCode == nil {
				m.ResponseCode = &google_protobuf.UInt32Value{}
			}
			if err := m.ResponseCode.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeadersBytes", wireType)
			}
			m.ResponseHeadersBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResponseHeadersBytes |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseBodyBytes", wireType)
			}
			m.ResponseBodyBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResponseBodyBytes |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeaders", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResponseHeaders == nil {
				m.ResponseHeaders = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAccesslog
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAccesslog
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAccesslog
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAccesslog
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAccesslog
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAccesslog(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthAccesslog
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ResponseHeaders[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccesslog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccesslog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HTTPAccessLogEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccesslog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HTTPAccessLogEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HTTPAccessLogEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommonProperties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CommonProperties == nil {
				m.CommonProperties = &AccessLogCommon{}
			}
			if err := m.CommonProperties.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtocolVersion", wireType)
			}
			m.ProtocolVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProtocolVersion |= (HTTPAccessLogEntry_HTTPVersion(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Request == nil {
				m.Request = &HTTPRequestProperties{}
			}
			if err := m.Request.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Response == nil {
				m.Response = &HTTPResponseProperties{}
			}
			if err := m.Response.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccesslog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccesslog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccessLog) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccesslog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccessLog: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccessLog: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Filter == nil {
				m.Filter = &AccessLogFilter{}
			}
			if err := m.Filter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Config == nil {
				m.Config = &google_protobuf4.Struct{}
			}
			if err := m.Config.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccesslog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccesslog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccessLogFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccesslog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccessLogFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccessLogFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusCodeFilter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StatusCodeFilter{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.FilterSpecifier = &AccessLogFilter_StatusCodeFilter{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DurationFilter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DurationFilter{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.FilterSpecifier = &AccessLogFilter_DurationFilter{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotHealthCheckFilter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NotHealthCheckFilter{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.FilterSpecifier = &AccessLogFilter_NotHealthCheckFilter{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TraceableFilter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TraceableFilter{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.FilterSpecifier = &AccessLogFilter_TraceableFilter{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuntimeFilter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RuntimeFilter{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.FilterSpecifier = &AccessLogFilter_RuntimeFilter{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AndFilter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AndFilter{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.FilterSpecifier = &AccessLogFilter_AndFilter{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrFilter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &OrFilter{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.FilterSpecifier = &AccessLogFilter_OrFilter{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccesslog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccesslog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ComparisonFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccesslog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ComparisonFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ComparisonFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= (ComparisonFilter_Op(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &envoy_api_v21.RuntimeUInt32{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccesslog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccesslog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatusCodeFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccesslog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatusCodeFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatusCodeFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comparison", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Comparison == nil {
				m.Comparison = &ComparisonFilter{}
			}
			if err := m.Comparison.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccesslog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccesslog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DurationFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccesslog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DurationFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DurationFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comparison", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Comparison == nil {
				m.Comparison = &ComparisonFilter{}
			}
			if err := m.Comparison.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccesslog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccesslog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NotHealthCheckFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccesslog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NotHealthCheckFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NotHealthCheckFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAccesslog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccesslog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TraceableFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccesslog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TraceableFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TraceableFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAccesslog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccesslog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RuntimeFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccesslog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RuntimeFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RuntimeFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuntimeKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuntimeKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccesslog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccesslog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AndFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccesslog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AndFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AndFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filters = append(m.Filters, &AccessLogFilter{})
			if err := m.Filters[len(m.Filters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccesslog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccesslog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccesslog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filters = append(m.Filters, &AccessLogFilter{})
			if err := m.Filters[len(m.Filters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccesslog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccesslog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileAccessLog) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccesslog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileAccessLog: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileAccessLog: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Format", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Format = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccesslog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccesslog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccessLogServiceConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccesslog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccessLogServiceConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccessLogServiceConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LogName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccesslog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccesslog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamAccessLogsMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccesslog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamAccessLogsMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamAccessLogsMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Identifier", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Identifier == nil {
				m.Identifier = &StreamAccessLogsMessage_Identifier{}
			}
			if err := m.Identifier.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpLogs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StreamAccessLogsMessage_HTTPAccessLogEntries{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LogEntries = &StreamAccessLogsMessage_HttpLogs{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpLogs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StreamAccessLogsMessage_TCPAccessLogEntries{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LogEntries = &StreamAccessLogsMessage_TcpLogs{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccesslog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccesslog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamAccessLogsMessage_Identifier) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccesslog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Identifier: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Identifier: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Node == nil {
				m.Node = &envoy_api_v21.Node{}
			}
			if err := m.Node.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LogName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccesslog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccesslog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamAccessLogsMessage_HTTPAccessLogEntries) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccesslog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HTTPAccessLogEntries: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HTTPAccessLogEntries: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogEntry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LogEntry = append(m.LogEntry, &HTTPAccessLogEntry{})
			if err := m.LogEntry[len(m.LogEntry)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccesslog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccesslog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamAccessLogsMessage_TCPAccessLogEntries) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccesslog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TCPAccessLogEntries: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TCPAccessLogEntries: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogEntry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LogEntry = append(m.LogEntry, &TCPAccessLogEntry{})
			if err := m.LogEntry[len(m.LogEntry)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccesslog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccesslog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamAccessLogsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccesslog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamAccessLogsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamAccessLogsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAccesslog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccesslog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAccesslog(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAccesslog
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthAccesslog
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowAccesslog
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipAccesslog(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthAccesslog = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAccesslog   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("api/filter/accesslog/accesslog.proto", fileDescriptorAccesslog) }

var fileDescriptorAccesslog = []byte{
	// 2162 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x58, 0xcb, 0x73, 0x1b, 0x49,
	0xfd, 0xcf, 0xc8, 0x2f, 0xcd, 0x57, 0x96, 0x3d, 0x6e, 0x3b, 0xb6, 0xec, 0xcd, 0xc3, 0xd1, 0x6f,
	0x7f, 0x60, 0x60, 0x91, 0x13, 0x65, 0x61, 0x17, 0x28, 0x1e, 0xb6, 0xd7, 0xc2, 0xce, 0x3a, 0xb6,
	0xb7, 0xa5, 0x84, 0xad, 0x0d, 0x55, 0x43, 0x5b, 0xd3, 0x92, 0x66, 0x33, 0x9a, 0x9e, 0xed, 0x6e,
	0x39, 0xab, 0x2b, 0x17, 0xaa, 0xb8, 0xc1, 0x89, 0xc3, 0xde, 0x39, 0x70, 0xe5, 0x40, 0xed, 0x29,
	0x47, 0x8a, 0x13, 0x07, 0xfe, 0x00, 0x2a, 0xb7, 0xdc, 0xf8, 0x03, 0xa8, 0x82, 0xea, 0xc7, 0x8c,
	0x1e, 0xf6, 0x46, 0x4e, 0x0a, 0xf0, 0xc5, 0xd3, 0xdf, 0xc7, 0xa7, 0xbf, 0xfd, 0x7d, 0x76, 0x0b,
	0xde, 0x26, 0x49, 0xb8, 0xdd, 0x0a, 0x23, 0x49, 0xf9, 0x36, 0x69, 0x36, 0xa9, 0x10, 0x11, 0x6b,
	0x0f, 0xbe, 0x2a, 0x09, 0x67, 0x92, 0xa1, 0x9b, 0x34, 0x3e, 0x67, 0xfd, 0x0a, 0x49, 0xc2, 0xca,
	0x79, 0xb5, 0x62, 0xc4, 0x2b, 0x99, 0xd0, 0xc6, 0x92, 0x02, 0x21, 0x41, 0xc0, 0xa9, 0x10, 0x46,
	0x63, 0x63, 0x41, 0x91, 0xce, 0x88, 0xa0, 0x76, 0x7d, 0xab, 0xcd, 0x58, 0x3b, 0xa2, 0xdb, 0x7a,
	0x75, 0xd6, 0x6b, 0x6d, 0x07, 0x3d, 0x4e, 0x64, 0xc8, 0x62, 0xcb, 0xbf, 0x31, 0xce, 0x17, 0x92,
	0xf7, 0x9a, 0xd2, 0x72, 0x6f, 0x8f, 0x73, 0x65, 0xd8, 0xa5, 0x42, 0x92, 0x6e, 0xf2, 0x55, 0xf0,
	0xcf, 0x38, 0x49, 0x12, 0xca, 0x53, 0x73, 0xd6, 0xce, 0x49, 0x14, 0x06, 0x44, 0xd2, 0xed, 0xf4,
	0xc3, 0x30, 0xca, 0xbf, 0x9f, 0x85, 0xc5, 0x1d, 0x7d, 0x90, 0x23, 0xd6, 0xde, 0x63, 0xdd, 0x2e,
	0x8b, 0xd1, 0x0e, 0x14, 0x04, 0xe9, 0x26, 0x11, 0xf5, 0x39, 0x91, 0xb4, 0xe4, 0x6c, 0x3a, 0x5b,
	0xce, 0xee, 0xe6, 0x97, 0x2f, 0x9f, 0x4f, 0x15, 0x90, 0x7b, 0xe7, 0x9a, 0xfd, 0xb3, 0xeb, 0x75,
	0xb3, 0xfa, 0xc7, 0x8f, 0x31, 0x18, 0x25, 0x4c, 0x24, 0x45, 0x35, 0xf0, 0x02, 0x2a, 0x64, 0x18,
	0xeb, 0x33, 0xfa, 0x1d, 0x26, 0x64, 0x29, 0xb7, 0xe9, 0x6c, 0x15, 0xaa, 0x6f, 0x55, 0x46, 0x7c,
	0x59, 0x67, 0xcd, 0xa7, 0x54, 0xee, 0x18, 0xdf, 0xe1, 0xc5, 0x21, 0xa5, 0x03, 0x26, 0x24, 0xaa,
	0xc3, 0x82, 0x8c, 0x84, 0x9f, 0x70, 0x96, 0x50, 0x2e, 0x43, 0x2a, 0x4a, 0x53, 0x1a, 0xe5, 0x9d,
	0xca, 0x2b, 0x23, 0x52, 0x69, 0x1c, 0xd5, 0x4f, 0x33, 0x1d, 0x5c, 0x94, 0x91, 0x18, 0x2c, 0xd1,
	0xf7, 0x00, 0x84, 0x24, 0x5c, 0xfa, 0xca, 0x8b, 0xa5, 0x69, 0x0d, 0xb8, 0x51, 0x31, 0x1e, 0xac,
	0xa4, 0x1e, 0xac, 0x34, 0x52, 0x17, 0x63, 0x57, 0x4b, 0xab, 0x35, 0x3a, 0x84, 0x15, 0xa5, 0xe4,
	0x4b, 0xe6, 0x47, 0x44, 0x48, 0x9f, 0x7f, 0xee, 0x9f, 0xf5, 0x25, 0x2d, 0xcd, 0x68, 0x90, 0xf5,
	0x0b, 0x20, 0x1f, 0xd8, 0x28, 0x63, 0x4f, 0xa9, 0x35, 0xd8, 0x11, 0x11, 0x12, 0x7f, 0xbe, 0xdb,
	0x97, 0x14, 0xfd, 0x1c, 0x6e, 0xa5, 0x50, 0xad, 0x90, 0x0b, 0xe9, 0xf7, 0x12, 0x21, 0x39, 0x25,
	0xdd, 0x0c, 0x74, 0x76, 0x12, 0xe8, 0xba, 0x01, 0xad, 0x29, 0xf5, 0x47, 0x56, 0xdb, 0xa2, 0x7f,
	0x02, 0x37, 0x47, 0x0c, 0xbd, 0x00, 0x3e, 0x37, 0x09, 0xbc, 0x34, 0xb0, 0x78, 0x0c, 0xfb, 0x27,
	0x50, 0xcc, 0xe0, 0x74, 0x64, 0xf3, 0x93, 0x23, 0x3b, 0x9f, 0x6a, 0xe8, 0xb0, 0x7e, 0x03, 0xbc,
	0x0c, 0xa1, 0x19, 0xf5, 0x84, 0xa4, 0xbc, 0xe4, 0x6e, 0x3a, 0x5b, 0x2e, 0x5e, 0x4c, 0xe9, 0x7b,
	0x86, 0xac, 0x32, 0x80, 0x53, 0x91, 0xb0, 0x58, 0x50, 0xbf, 0x15, 0x91, 0xb6, 0x28, 0xc1, 0x95,
	0x32, 0x00, 0x5b, 0xa5, 0x9a, 0xd2, 0xc1, 0x45, 0x3e, 0xbc, 0x44, 0x55, 0xc8, 0x77, 0xa9, 0x24,
	0x01, 0x91, 0xa4, 0x54, 0xd0, 0x70, 0xab, 0xa3, 0x70, 0x0f, 0x2d, 0x17, 0x67, 0x72, 0xe5, 0xbf,
	0x4d, 0x43, 0x71, 0x04, 0x14, 0xbd, 0x0f, 0xa5, 0x16, 0x09, 0x23, 0x1a, 0xf8, 0x11, 0x6b, 0x92,
	0xc8, 0xef, 0x50, 0x12, 0xc9, 0x4e, 0xb3, 0x43, 0x9b, 0x4f, 0x75, 0xd1, 0xe4, 0xf1, 0xaa, 0xe1,
	0x1f, 0x29, 0xf6, 0xc1, 0x80, 0x8b, 0x2a, 0xb0, 0x1c, 0x33, 0x2b, 0xdf, 0xcf, 0x62, 0xa3, 0x2b,
	0x24, 0x8f, 0x97, 0x62, 0x66, 0x64, 0xfb, 0xa9, 0xdf, 0xd5, 0x4e, 0x83, 0x00, 0xd2, 0xcf, 0x7a,
	0x54, 0x98, 0xe4, 0x65, 0x3d, 0xa9, 0x0b, 0x22, 0x8f, 0x57, 0x53, 0x3e, 0x36, 0xec, 0x86, 0xe1,
	0xa2, 0xdb, 0x50, 0x30, 0xc6, 0x71, 0x2a, 0xa8, 0xd4, 0xc9, 0x9e, 0xc7, 0xa0, 0x49, 0x58, 0x51,
	0x50, 0x15, 0xae, 0x0f, 0x41, 0x77, 0x99, 0xa4, 0x56, 0x74, 0x46, 0x8b, 0x2e, 0x0f, 0x70, 0x15,
	0xcf, 0xe8, 0xfc, 0x08, 0xde, 0x1a, 0x84, 0x8f, 0xc5, 0x31, 0x6d, 0xea, 0x2a, 0x57, 0x87, 0xed,
	0x71, 0x93, 0xb7, 0x79, 0xbc, 0x9e, 0x45, 0x32, 0x93, 0xa8, 0x19, 0x01, 0x54, 0x83, 0xdb, 0x97,
	0xe9, 0x4b, 0xca, 0xbb, 0xb6, 0xf8, 0x75, 0x7a, 0xe6, 0xf1, 0xcd, 0x8b, 0x18, 0x8d, 0x81, 0x10,
	0xfa, 0x16, 0x2c, 0x65, 0x38, 0xec, 0x9c, 0xf2, 0x56, 0xc4, 0x9e, 0xe9, 0x64, 0xcc, 0xe3, 0x2c,
	0xbf, 0x4e, 0x2c, 0x1d, 0xbd, 0x0d, 0x0b, 0x31, 0xf3, 0x39, 0xeb, 0x49, 0xea, 0xb7, 0x58, 0x2f,
	0x0e, 0x74, 0xc6, 0xe5, 0xf1, 0x7c, 0xcc, 0xb0, 0x22, 0xd6, 0x14, 0x0d, 0xfd, 0x3f, 0x2c, 0x04,
	0x34, 0x22, 0x7d, 0x3f, 0x8c, 0x3f, 0xa5, 0x4d, 0x49, 0x03, 0x9d, 0x6e, 0x79, 0x5c, 0xd4, 0xd4,
	0x43, 0x4b, 0x54, 0x62, 0x2d, 0xd2, 0x8b, 0xe4, 0x40, 0xac, 0x60, 0xc4, 0x34, 0x35, 0x13, 0xbb,
	0x03, 0xf3, 0xaa, 0x85, 0xfa, 0x51, 0xd8, 0x0d, 0x95, 0xd0, 0xbc, 0x16, 0x2a, 0x28, 0xda, 0x91,
	0x21, 0x95, 0xff, 0x98, 0x83, 0xe2, 0x48, 0xb7, 0x42, 0x1f, 0x43, 0x41, 0xf5, 0xbc, 0x73, 0xca,
	0x85, 0xf2, 0x84, 0xca, 0xa4, 0x85, 0xea, 0x7b, 0xaf, 0xd3, 0xf0, 0xd4, 0xea, 0xb1, 0x51, 0xc7,
	0x20, 0x23, 0x61, 0xbf, 0x55, 0x57, 0x56, 0xc8, 0xcd, 0x30, 0xe9, 0x50, 0xee, 0x8b, 0x5e, 0x28,
	0xa9, 0xed, 0xca, 0x37, 0x2e, 0xf4, 0x81, 0x47, 0x87, 0xb1, 0xbc, 0x5f, 0x7d, 0x4c, 0xa2, 0x1e,
	0xc5, 0xaa, 0x07, 0xef, 0x69, 0xa5, 0xba, 0xd2, 0x41, 0x5b, 0x06, 0x47, 0xc4, 0xa1, 0xae, 0xff,
	0x98, 0x74, 0xa9, 0x4e, 0x43, 0x57, 0x4b, 0xd6, 0xe3, 0xf0, 0xc0, 0x52, 0xcb, 0x3f, 0x03, 0x18,
	0xd8, 0x82, 0xd6, 0x60, 0xf9, 0xf1, 0x3e, 0xae, 0x1f, 0x9e, 0x1c, 0xfb, 0x8f, 0x8e, 0xeb, 0xa7,
	0xfb, 0x7b, 0x87, 0xb5, 0xc3, 0xfd, 0x0f, 0xbc, 0x6b, 0xc8, 0x85, 0x99, 0xc6, 0x51, 0xfd, 0xfc,
	0x9e, 0xe7, 0xa0, 0x02, 0xcc, 0xe9, 0x4f, 0xff, 0x9e, 0x97, 0x1b, 0x2c, 0xaa, 0xde, 0xd4, 0x60,
	0x71, 0xdf, 0x9b, 0x2e, 0x27, 0xb0, 0xd4, 0xd8, 0x3b, 0xcd, 0x26, 0xd7, 0x7e, 0x2c, 0x79, 0x1f,
	0x3d, 0x81, 0xa5, 0xa6, 0x1e, 0x61, 0xc3, 0x03, 0xc3, 0xd1, 0x07, 0xac, 0x4c, 0xf0, 0xdf, 0xd8,
	0x0c, 0xc4, 0x9e, 0x01, 0x1a, 0xf8, 0xb4, 0xfc, 0x9b, 0x19, 0xb8, 0x7e, 0xd0, 0x68, 0x9c, 0xda,
	0x02, 0x1b, 0x0a, 0xd8, 0xae, 0x6a, 0x51, 0xa6, 0x28, 0xbb, 0x54, 0x76, 0x58, 0x60, 0x63, 0x36,
	0xd6, 0x10, 0xad, 0xe2, 0x43, 0x2d, 0xa2, 0x3a, 0xd2, 0xd0, 0x12, 0xad, 0xc2, 0xac, 0x68, 0x76,
	0x68, 0xd7, 0x04, 0xc4, 0xc5, 0x76, 0x85, 0x6e, 0x80, 0x4b, 0x7a, 0xb2, 0xc3, 0x78, 0x28, 0xfb,
	0xd6, 0xc7, 0x03, 0x02, 0xba, 0x0b, 0xd3, 0x09, 0xe3, 0xd2, 0xce, 0xb0, 0x57, 0x07, 0x51, 0x4b,
	0x22, 0x04, 0xd3, 0x09, 0x91, 0x1d, 0x5d, 0xdd, 0x2e, 0xd6, 0xdf, 0xe8, 0x26, 0x40, 0x4f, 0x50,
	0xee, 0x93, 0x36, 0x8d, 0xa5, 0xae, 0x5e, 0x17, 0xbb, 0x8a, 0xb2, 0xa3, 0x08, 0xa8, 0x04, 0x73,
	0x9c, 0xb6, 0x28, 0xa7, 0x5c, 0x57, 0xa5, 0x8b, 0xd3, 0x25, 0xfa, 0x3f, 0x28, 0xb6, 0x18, 0x7f,
	0x46, 0x78, 0x40, 0x03, 0xbf, 0xc5, 0xb8, 0xae, 0x3d, 0x17, 0xcf, 0x67, 0xc4, 0x1a, 0xe3, 0x0a,
	0x3d, 0xf5, 0x4e, 0x18, 0xd8, 0x2e, 0xef, 0x5a, 0xca, 0x61, 0xa0, 0x30, 0x18, 0x0f, 0xdb, 0x61,
	0x4c, 0x22, 0x5f, 0x5b, 0x06, 0x06, 0x23, 0x25, 0x9e, 0x2a, 0x0b, 0xab, 0x70, 0x3d, 0xc5, 0xe8,
	0x50, 0x12, 0x50, 0x2e, 0xf4, 0x10, 0x13, 0xba, 0xea, 0xa6, 0xf1, 0xb2, 0x65, 0x1e, 0x18, 0x9e,
	0x1a, 0x52, 0x02, 0xbd, 0x03, 0x28, 0xd5, 0x39, 0x63, 0x41, 0xdf, 0x2a, 0xcc, 0x6b, 0x05, 0xcf,
	0x72, 0x76, 0x59, 0xd0, 0x37, 0xd2, 0x9f, 0xc1, 0xe2, 0xd8, 0x0e, 0xa5, 0xe2, 0xe6, 0xd4, 0x56,
	0xa1, 0x7a, 0x30, 0x21, 0x71, 0x2e, 0x4d, 0x89, 0x34, 0xd6, 0xd6, 0x20, 0x9d, 0x9d, 0x78, 0x61,
	0xd4, 0xca, 0x8d, 0x1d, 0x58, 0xbe, 0x44, 0x0c, 0x79, 0x30, 0xf5, 0x94, 0xf6, 0x75, 0x0a, 0xb9,
	0x58, 0x7d, 0xa2, 0x15, 0x98, 0x39, 0x57, 0x21, 0xb4, 0xa9, 0x61, 0x16, 0xdf, 0xcf, 0xbd, 0xef,
	0x94, 0xff, 0x99, 0x83, 0x55, 0x63, 0x80, 0x99, 0x4b, 0x43, 0x49, 0xb9, 0x03, 0xd9, 0xcc, 0xf3,
	0x9b, 0x2c, 0xa0, 0xb6, 0x0e, 0x5e, 0x9d, 0x23, 0xf3, 0xa9, 0xca, 0x1e, 0x0b, 0x28, 0x7a, 0x17,
	0x56, 0x33, 0x88, 0x51, 0xb7, 0xe7, 0xb4, 0x17, 0x57, 0x52, 0xee, 0x88, 0xdf, 0x2b, 0xb0, 0x9c,
	0x69, 0x0d, 0x39, 0x7e, 0x4a, 0xab, 0x2c, 0xa5, 0xac, 0x81, 0xe7, 0x7b, 0xe0, 0x8d, 0xef, 0x52,
	0x9a, 0xd6, 0xae, 0x7f, 0x70, 0x25, 0xd7, 0x8f, 0x9f, 0x3c, 0x9b, 0xfc, 0x23, 0xce, 0x5f, 0x1c,
	0xb3, 0x75, 0x63, 0x17, 0x56, 0x2e, 0x13, 0x7c, 0x2d, 0xf7, 0xff, 0x65, 0x0a, 0x90, 0x32, 0xe2,
	0x7f, 0xd8, 0x86, 0x50, 0x07, 0x3c, 0x1d, 0xba, 0x26, 0x8b, 0xb2, 0x11, 0x91, 0xd3, 0xed, 0xe6,
	0x87, 0x57, 0x70, 0xd7, 0xa8, 0xa5, 0x9a, 0x94, 0x0e, 0x8a, 0xc5, 0x14, 0x36, 0xed, 0xd6, 0xc7,
	0xaa, 0xee, 0x75, 0x7e, 0xda, 0x4b, 0xf7, 0xbb, 0x6f, 0x52, 0x0a, 0x38, 0x05, 0x41, 0x1f, 0x41,
	0x3e, 0x0d, 0x82, 0x6d, 0x58, 0xdf, 0x79, 0xa3, 0x00, 0xe3, 0x0c, 0xa6, 0xfc, 0x00, 0x0a, 0x43,
	0x47, 0x40, 0x25, 0x58, 0x39, 0xc5, 0x27, 0x8d, 0x93, 0xbd, 0x93, 0xa3, 0xb1, 0x01, 0x03, 0x30,
	0xab, 0x04, 0xef, 0xdd, 0xf5, 0x9c, 0xec, 0x5b, 0x0d, 0x18, 0x17, 0x66, 0xd4, 0x77, 0xd5, 0x9b,
	0x2a, 0xff, 0xce, 0x01, 0x37, 0x73, 0x8f, 0xea, 0x93, 0x7a, 0xac, 0x99, 0x3c, 0xd0, 0xdf, 0xa8,
	0x06, 0xb3, 0xc6, 0x44, 0x3b, 0x34, 0xaf, 0x1c, 0xcc, 0x9a, 0xe6, 0x60, 0xab, 0x8d, 0xb6, 0x61,
	0xb6, 0xc9, 0xe2, 0x56, 0xd8, 0xb6, 0x7e, 0x5d, 0xbb, 0x50, 0x93, 0x75, 0xfd, 0xf8, 0xc3, 0x56,
	0xac, 0xfc, 0xc5, 0xcc, 0xd0, 0x23, 0xcd, 0x80, 0x21, 0x1f, 0x90, 0x90, 0x44, 0xf6, 0x84, 0xae,
	0x6e, 0xdf, 0x1a, 0x66, 0xb2, 0x6c, 0x7b, 0x82, 0x61, 0x75, 0xad, 0xa8, 0x6a, 0xdc, 0x80, 0x1d,
	0x5c, 0xc3, 0x9e, 0x18, 0xa3, 0xa1, 0x8f, 0x61, 0x31, 0x7d, 0xa3, 0xfa, 0x23, 0xc7, 0xfe, 0xf6,
	0x04, 0xf4, 0xf4, 0x05, 0x91, 0x61, 0x2f, 0x04, 0x23, 0x14, 0x14, 0xc1, 0x5a, 0xcc, 0xa4, 0xbd,
	0xfe, 0xfa, 0xfa, 0x46, 0x9c, 0xee, 0x60, 0x1c, 0x72, 0x7f, 0xc2, 0x0e, 0xc7, 0x4c, 0x9a, 0x1b,
	0xf2, 0x9e, 0xd2, 0xcd, 0xf6, 0x59, 0x89, 0x2f, 0xa1, 0xa3, 0x27, 0xe0, 0x49, 0x4e, 0x9a, 0x94,
	0x9c, 0x45, 0x99, 0x9b, 0xa6, 0xaf, 0x14, 0xbf, 0x46, 0xaa, 0x96, 0xed, 0xb0, 0x28, 0x47, 0x49,
	0xe8, 0x11, 0x2c, 0xf0, 0x5e, 0xac, 0x5f, 0x5a, 0x16, 0x7a, 0xe6, 0x6a, 0xaf, 0x13, 0xa3, 0x94,
	0x01, 0x17, 0xf9, 0x30, 0x01, 0x1d, 0x02, 0x90, 0x38, 0x48, 0x21, 0xcd, 0x3b, 0x70, 0x6b, 0x52,
	0xb6, 0xc5, 0x41, 0x06, 0xe7, 0x92, 0x74, 0x81, 0x6a, 0xe0, 0x32, 0x9e, 0x22, 0x99, 0x47, 0xdf,
	0xd7, 0x27, 0x20, 0x9d, 0xf0, 0x0c, 0x28, 0xcf, 0xec, 0xf7, 0xee, 0x3a, 0x78, 0x46, 0xd0, 0x17,
	0x09, 0x6d, 0x86, 0xad, 0x90, 0x72, 0x34, 0xf3, 0xa7, 0x97, 0xcf, 0xa7, 0x9c, 0xf2, 0x1f, 0x1c,
	0xf0, 0xf6, 0x58, 0x37, 0x21, 0x3c, 0x14, 0x59, 0x90, 0x8f, 0x21, 0xc7, 0x12, 0x7b, 0x11, 0xaa,
	0x4e, 0xd8, 0x70, 0x5c, 0xb9, 0x72, 0x92, 0xec, 0xc2, 0x97, 0x2f, 0x9f, 0x4f, 0xcd, 0xfc, 0xd2,
	0xc9, 0x79, 0x0e, 0xce, 0xb1, 0x04, 0xdd, 0x1b, 0xee, 0xc2, 0x17, 0x1e, 0x9b, 0xd6, 0x9f, 0x66,
	0x96, 0xd9, 0x16, 0x5d, 0x5e, 0x81, 0xdc, 0x49, 0x82, 0x66, 0x21, 0xb7, 0xff, 0x91, 0x77, 0x4d,
	0xfd, 0xff, 0xe9, 0xbe, 0xe7, 0x94, 0x19, 0x78, 0xe3, 0xf9, 0x8f, 0x9e, 0x00, 0x34, 0x33, 0x1b,
	0xae, 0x58, 0x44, 0xe3, 0x46, 0x5b, 0x8b, 0x7f, 0xad, 0x2d, 0x1e, 0x82, 0x2b, 0x77, 0x61, 0x61,
	0xb4, 0x24, 0xfe, 0xbb, 0xdb, 0xad, 0xc2, 0xca, 0x65, 0xf5, 0x51, 0x5e, 0x82, 0xc5, 0xb1, 0x84,
	0x2e, 0xff, 0x00, 0x8a, 0x23, 0x89, 0x88, 0xbe, 0x09, 0x85, 0x34, 0x9d, 0xb3, 0x21, 0xb8, 0xeb,
	0xaa, 0x8d, 0xa6, 0x79, 0x6e, 0xd3, 0xc1, 0x60, 0xb9, 0x1f, 0xd2, 0x7e, 0x99, 0x80, 0x9b, 0xa5,
	0x1c, 0x6a, 0xc0, 0x9c, 0xb1, 0x58, 0x0d, 0xba, 0xa9, 0xd7, 0xef, 0x8d, 0xf6, 0x34, 0xbf, 0x75,
	0x72, 0xf9, 0x1c, 0x4e, 0xa1, 0xca, 0xbf, 0x80, 0x7c, 0x9a, 0x8b, 0xc3, 0x3b, 0xe4, 0xfe, 0x73,
	0x3b, 0xd4, 0xa0, 0x58, 0x0b, 0x23, 0x3a, 0xe8, 0xfb, 0x37, 0xed, 0xfd, 0xf8, 0xc2, 0xd1, 0xcd,
	0x55, 0x79, 0x15, 0x66, 0x5b, 0x8c, 0x77, 0x89, 0x4c, 0xaf, 0xe9, 0x66, 0x55, 0x7e, 0x0c, 0xab,
	0x19, 0x46, 0x9d, 0xf2, 0xf3, 0xb0, 0x49, 0xf7, 0x74, 0xef, 0x46, 0xeb, 0x90, 0x8f, 0x58, 0xdb,
	0x1f, 0x1a, 0x26, 0x73, 0x11, 0x6b, 0x1f, 0xab, 0x79, 0x72, 0x07, 0xe6, 0xed, 0x8f, 0x1f, 0x86,
	0x6d, 0x20, 0x0b, 0x96, 0xa6, 0x44, 0xca, 0xff, 0x9a, 0x86, 0xb5, 0xba, 0x7e, 0xc7, 0x66, 0xf0,
	0xe2, 0x21, 0x15, 0x82, 0xb4, 0x29, 0x22, 0x00, 0x61, 0x40, 0x63, 0xa9, 0x6b, 0xd1, 0x66, 0xd1,
	0xce, 0xc4, 0xce, 0x7f, 0x29, 0x56, 0xe5, 0x30, 0x03, 0xc2, 0x43, 0xa0, 0xe8, 0x53, 0x70, 0x3b,
	0x52, 0x26, 0x7e, 0xc4, 0xda, 0xc2, 0x16, 0xde, 0x87, 0x6f, 0xb8, 0xc3, 0x85, 0xdb, 0x47, 0x48,
	0x85, 0x6a, 0x30, 0x0a, 0x5f, 0xc9, 0xa1, 0x36, 0xe4, 0x65, 0xd3, 0x6e, 0x65, 0xc6, 0xc0, 0x83,
	0x37, 0xdc, 0x6a, 0xfc, 0x61, 0x68, 0x76, 0x9a, 0x93, 0x4d, 0xbd, 0xd1, 0xc6, 0x09, 0xc0, 0xe0,
	0xb8, 0xe8, 0x6b, 0x30, 0x1d, 0x0f, 0xae, 0xc7, 0x68, 0x74, 0xcb, 0x63, 0x16, 0x50, 0xac, 0xf9,
	0x23, 0x71, 0xcc, 0x8d, 0xc4, 0x71, 0xa3, 0x05, 0x2b, 0x97, 0x9d, 0x0e, 0x1d, 0x83, 0xab, 0x54,
	0xa8, 0xba, 0x6a, 0xd9, 0xb2, 0xb8, 0xf7, 0xda, 0x77, 0x34, 0xac, 0xb6, 0xd5, 0x5f, 0x1b, 0x01,
	0x2c, 0x5f, 0x72, 0x34, 0xf4, 0xf0, 0xe2, 0x36, 0x77, 0x27, 0x4d, 0xb6, 0xbd, 0xaf, 0xdc, 0x65,
	0xb7, 0x08, 0x85, 0x14, 0x4e, 0x3d, 0x7b, 0x37, 0xa0, 0x34, 0xee, 0xe7, 0xf4, 0x4a, 0x56, 0xfd,
	0xc2, 0x01, 0x6f, 0x3c, 0xed, 0xd1, 0xaf, 0x1c, 0xd5, 0x60, 0x47, 0x35, 0xd0, 0x77, 0xdf, 0x2c,
	0x94, 0x1b, 0xef, 0xbd, 0xa6, 0x5e, 0x6a, 0x5a, 0xf9, 0xda, 0x96, 0xb3, 0xbb, 0xf6, 0xe7, 0x17,
	0xb7, 0x9c, 0xbf, 0xbe, 0xb8, 0xe5, 0xfc, 0xfd, 0xc5, 0x2d, 0xe7, 0x13, 0x37, 0xd3, 0x3a, 0x9b,
	0xd5, 0x17, 0xad, 0xfb, 0xff, 0x0e, 0x00, 0x00, 0xff, 0xff, 0xce, 0x4c, 0xfc, 0x33, 0xfd, 0x17,
	0x00, 0x00,
}
