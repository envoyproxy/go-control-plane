// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: api/rds.proto

package api

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "istio.io/gogo-genproto/googleapis/google/api"
import _ "github.com/gogo/protobuf/types"
import google_protobuf "github.com/gogo/protobuf/types"
import _ "github.com/lyft/protoc-gen-validate/validate"
import _ "github.com/gogo/protobuf/gogoproto"

import time "time"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

type VirtualHost_TlsRequirementType int32

const (
	// No TLS requirement for the virtual host.
	VirtualHost_NONE VirtualHost_TlsRequirementType = 0
	// External requests must use TLS. If a request is external and it is not
	// using TLS, a 301 redirect will be sent telling the client to use HTTPS.
	VirtualHost_EXTERNAL_ONLY VirtualHost_TlsRequirementType = 1
	// All requests must use TLS. If a request is not using TLS, a 301 redirect
	// will be sent telling the client to use HTTPS.
	VirtualHost_ALL VirtualHost_TlsRequirementType = 2
)

var VirtualHost_TlsRequirementType_name = map[int32]string{
	0: "NONE",
	1: "EXTERNAL_ONLY",
	2: "ALL",
}
var VirtualHost_TlsRequirementType_value = map[string]int32{
	"NONE":          0,
	"EXTERNAL_ONLY": 1,
	"ALL":           2,
}

func (x VirtualHost_TlsRequirementType) String() string {
	return proto.EnumName(VirtualHost_TlsRequirementType_name, int32(x))
}
func (VirtualHost_TlsRequirementType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorRds, []int{1, 0}
}

type RouteAction_ClusterNotFoundResponseCode int32

const (
	// HTTP status code - 503 Service Unavailable.
	RouteAction_SERVICE_UNAVAILABLE RouteAction_ClusterNotFoundResponseCode = 0
	// HTTP status code - 404 Not Found.
	RouteAction_NOT_FOUND RouteAction_ClusterNotFoundResponseCode = 1
)

var RouteAction_ClusterNotFoundResponseCode_name = map[int32]string{
	0: "SERVICE_UNAVAILABLE",
	1: "NOT_FOUND",
}
var RouteAction_ClusterNotFoundResponseCode_value = map[string]int32{
	"SERVICE_UNAVAILABLE": 0,
	"NOT_FOUND":           1,
}

func (x RouteAction_ClusterNotFoundResponseCode) String() string {
	return proto.EnumName(RouteAction_ClusterNotFoundResponseCode_name, int32(x))
}
func (RouteAction_ClusterNotFoundResponseCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorRds, []int{6, 0}
}

type RedirectAction_RedirectResponseCode int32

const (
	// Moved Permanently HTTP Status Code - 301.
	RedirectAction_MOVED_PERMANENTLY RedirectAction_RedirectResponseCode = 0
	// Found HTTP Status Code - 302.
	RedirectAction_FOUND RedirectAction_RedirectResponseCode = 1
	// See Other HTTP Status Code - 303.
	RedirectAction_SEE_OTHER RedirectAction_RedirectResponseCode = 2
	// Temporary Redirect HTTP Status Code - 307.
	RedirectAction_TEMPORARY_REDIRECT RedirectAction_RedirectResponseCode = 3
	// Permanent Redirect HTTP Status Code - 308.
	RedirectAction_PERMANENT_REDIRECT RedirectAction_RedirectResponseCode = 4
)

var RedirectAction_RedirectResponseCode_name = map[int32]string{
	0: "MOVED_PERMANENTLY",
	1: "FOUND",
	2: "SEE_OTHER",
	3: "TEMPORARY_REDIRECT",
	4: "PERMANENT_REDIRECT",
}
var RedirectAction_RedirectResponseCode_value = map[string]int32{
	"MOVED_PERMANENTLY":  0,
	"FOUND":              1,
	"SEE_OTHER":          2,
	"TEMPORARY_REDIRECT": 3,
	"PERMANENT_REDIRECT": 4,
}

func (x RedirectAction_RedirectResponseCode) String() string {
	return proto.EnumName(RedirectAction_RedirectResponseCode_name, int32(x))
}
func (RedirectAction_RedirectResponseCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorRds, []int{7, 0}
}

// * Routing :ref:`architecture overview <arch_overview_http_routing>`
// * HTTP :ref:`router filter <config_http_filters_router>`
type RouteConfiguration struct {
	// The name of the route configuration. For example, it might match
	// :ref:`route_config_name <envoy_api_field_filter.network.Rds.route_config_name>` in
	// :ref:`envoy_api_msg_filter.network.Rds`.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// An array of virtual hosts that make up the route table.
	VirtualHosts []*VirtualHost `protobuf:"bytes,2,rep,name=virtual_hosts,json=virtualHosts" json:"virtual_hosts,omitempty"`
	// Optionally specifies a list of HTTP headers that the connection manager
	// will consider to be internal only. If they are found on external requests they will be cleaned
	// prior to filter invocation. See :ref:`config_http_conn_man_headers_x-envoy-internal` for more
	// information.
	InternalOnlyHeaders []string `protobuf:"bytes,3,rep,name=internal_only_headers,json=internalOnlyHeaders" json:"internal_only_headers,omitempty"`
	// Specifies a list of HTTP headers that should be added to each response that
	// the connection manager encodes. Headers specified at this level are applied
	// after headers from any enclosed :ref:`envoy_api_msg_VirtualHost` or
	// :ref:`envoy_api_msg_RouteAction`.
	ResponseHeadersToAdd []*HeaderValueOption `protobuf:"bytes,4,rep,name=response_headers_to_add,json=responseHeadersToAdd" json:"response_headers_to_add,omitempty"`
	// Specifies a list of HTTP headers that should be removed from each response
	// that the connection manager encodes.
	ResponseHeadersToRemove []string `protobuf:"bytes,5,rep,name=response_headers_to_remove,json=responseHeadersToRemove" json:"response_headers_to_remove,omitempty"`
	// Specifies a list of HTTP headers that should be added to each request
	// routed by the HTTP connection manager. Headers specified at this level are
	// applied after headers from any enclosed :ref:`envoy_api_msg_VirtualHost` or
	// :ref:`envoy_api_msg_RouteAction`. For more information see the documentation on
	// :ref:`custom request headers <config_http_conn_man_headers_custom_request_headers>`.
	RequestHeadersToAdd []*HeaderValueOption `protobuf:"bytes,6,rep,name=request_headers_to_add,json=requestHeadersToAdd" json:"request_headers_to_add,omitempty"`
	// An optional boolean that specifies whether the clusters that the route
	// table refers to will be validated by the cluster manager. If set to true
	// and a route refers to a non-existent cluster, the route table will not
	// load. If set to false and a route refers to a non-existent cluster, the
	// route table will load and the router filter will return a 404 if the route
	// is selected at runtime. This setting defaults to true if the route table
	// is statically defined via the :ref:`route_config
	// <envoy_api_field_filter.network.HttpConnectionManager.route_config>` option. This setting
	// default to false if the route table is loaded dynamically via the :ref:`rds
	// <envoy_api_field_filter.network.HttpConnectionManager.rds>` option. Users
	// may which to override the default behavior in certain cases (for example
	// when using CDS with a static route table).
	ValidateClusters *google_protobuf.BoolValue `protobuf:"bytes,7,opt,name=validate_clusters,json=validateClusters" json:"validate_clusters,omitempty"`
}

func (m *RouteConfiguration) Reset()                    { *m = RouteConfiguration{} }
func (m *RouteConfiguration) String() string            { return proto.CompactTextString(m) }
func (*RouteConfiguration) ProtoMessage()               {}
func (*RouteConfiguration) Descriptor() ([]byte, []int) { return fileDescriptorRds, []int{0} }

func (m *RouteConfiguration) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *RouteConfiguration) GetVirtualHosts() []*VirtualHost {
	if m != nil {
		return m.VirtualHosts
	}
	return nil
}

func (m *RouteConfiguration) GetInternalOnlyHeaders() []string {
	if m != nil {
		return m.InternalOnlyHeaders
	}
	return nil
}

func (m *RouteConfiguration) GetResponseHeadersToAdd() []*HeaderValueOption {
	if m != nil {
		return m.ResponseHeadersToAdd
	}
	return nil
}

func (m *RouteConfiguration) GetResponseHeadersToRemove() []string {
	if m != nil {
		return m.ResponseHeadersToRemove
	}
	return nil
}

func (m *RouteConfiguration) GetRequestHeadersToAdd() []*HeaderValueOption {
	if m != nil {
		return m.RequestHeadersToAdd
	}
	return nil
}

func (m *RouteConfiguration) GetValidateClusters() *google_protobuf.BoolValue {
	if m != nil {
		return m.ValidateClusters
	}
	return nil
}

// The top level element in the routing configuration is a virtual host. Each virtual host has
// a logical name as well as a set of domains that get routed to it based on the incoming request's
// host header. This allows a single listener to service multiple top level domain path trees. Once
// a virtual host is selected based on the domain, the routes are processed in order to see which
// upstream cluster to route to or whether to perform a redirect.
type VirtualHost struct {
	// The logical name of the virtual host. This is used when emitting certain
	// statistics but is not relevant for routing.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// A list of domains (host/authority header) that will be matched to this
	// virtual host. Wildcard hosts are supported in the form of “*.foo.com” or
	// “*-bar.foo.com”.
	//
	// .. note::
	//
	//   The wildcard will not match the empty string.
	//   e.g. “*-bar.foo.com” will match “baz-bar.foo.com” but not “-bar.foo.com”.
	//   Additionally, a special entry “*” is allowed which will match any
	//   host/authority header. Only a single virtual host in the entire route
	//   configuration can match on “*”. A domain must be unique across all virtual
	//   hosts or the config will fail to load.
	Domains []string `protobuf:"bytes,2,rep,name=domains" json:"domains,omitempty"`
	// The list of routes that will be matched, in order, for incoming requests.
	// The first route that matches will be used.
	Routes []*Route `protobuf:"bytes,3,rep,name=routes" json:"routes,omitempty"`
	// Specifies the type of TLS enforcement the virtual host expects. If this option is not
	// specified, there is no TLS requirement for the virtual host.
	RequireTls VirtualHost_TlsRequirementType `protobuf:"varint,4,opt,name=require_tls,json=requireTls,proto3,enum=envoy.api.v2.VirtualHost_TlsRequirementType" json:"require_tls,omitempty"`
	// A list of virtual clusters defined for this virtual host. Virtual clusters
	// are used for additional statistics gathering.
	VirtualClusters []*VirtualCluster `protobuf:"bytes,5,rep,name=virtual_clusters,json=virtualClusters" json:"virtual_clusters,omitempty"`
	// Specifies a set of rate limit configurations that will be applied to the
	// virtual host.
	RateLimits []*RateLimit `protobuf:"bytes,6,rep,name=rate_limits,json=rateLimits" json:"rate_limits,omitempty"`
	// Specifies a list of HTTP headers that should be added to each request
	// handled by this virtual host. Headers specified at this level are applied
	// after headers from enclosed :ref:`envoy_api_msg_RouteAction` and before headers from the
	// enclosing :ref:`envoy_api_msg_RouteConfiguration`. For more information see the documentation
	// on :ref:`custom request headers <config_http_conn_man_headers_custom_request_headers>`.
	RequestHeadersToAdd []*HeaderValueOption `protobuf:"bytes,7,rep,name=request_headers_to_add,json=requestHeadersToAdd" json:"request_headers_to_add,omitempty"`
	// Specifies a list of HTTP headers that should be added to each response
	// handled by this virtual host. Headers specified at this level are applied
	// after headers from enclosed :ref:`envoy_api_msg_RouteAction` and before headers from the
	// enclosing :ref:`envoy_api_msg_RouteConfiguration`.
	ResponseHeadersToAdd []*HeaderValueOption `protobuf:"bytes,10,rep,name=response_headers_to_add,json=responseHeadersToAdd" json:"response_headers_to_add,omitempty"`
	// Specifies a list of HTTP headers that should be removed from each response
	// handle by this virtual host.
	ResponseHeadersToRemove []string `protobuf:"bytes,11,rep,name=response_headers_to_remove,json=responseHeadersToRemove" json:"response_headers_to_remove,omitempty"`
	// Indicates that the virtual host has a CORS policy.
	Cors *CorsPolicy `protobuf:"bytes,8,opt,name=cors" json:"cors,omitempty"`
	// [#not-implemented-hide:]
	// Return a 401/403 when auth checks fail.
	Auth *AuthAction `protobuf:"bytes,9,opt,name=auth" json:"auth,omitempty"`
}

func (m *VirtualHost) Reset()                    { *m = VirtualHost{} }
func (m *VirtualHost) String() string            { return proto.CompactTextString(m) }
func (*VirtualHost) ProtoMessage()               {}
func (*VirtualHost) Descriptor() ([]byte, []int) { return fileDescriptorRds, []int{1} }

func (m *VirtualHost) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *VirtualHost) GetDomains() []string {
	if m != nil {
		return m.Domains
	}
	return nil
}

func (m *VirtualHost) GetRoutes() []*Route {
	if m != nil {
		return m.Routes
	}
	return nil
}

func (m *VirtualHost) GetRequireTls() VirtualHost_TlsRequirementType {
	if m != nil {
		return m.RequireTls
	}
	return VirtualHost_NONE
}

func (m *VirtualHost) GetVirtualClusters() []*VirtualCluster {
	if m != nil {
		return m.VirtualClusters
	}
	return nil
}

func (m *VirtualHost) GetRateLimits() []*RateLimit {
	if m != nil {
		return m.RateLimits
	}
	return nil
}

func (m *VirtualHost) GetRequestHeadersToAdd() []*HeaderValueOption {
	if m != nil {
		return m.RequestHeadersToAdd
	}
	return nil
}

func (m *VirtualHost) GetResponseHeadersToAdd() []*HeaderValueOption {
	if m != nil {
		return m.ResponseHeadersToAdd
	}
	return nil
}

func (m *VirtualHost) GetResponseHeadersToRemove() []string {
	if m != nil {
		return m.ResponseHeadersToRemove
	}
	return nil
}

func (m *VirtualHost) GetCors() *CorsPolicy {
	if m != nil {
		return m.Cors
	}
	return nil
}

func (m *VirtualHost) GetAuth() *AuthAction {
	if m != nil {
		return m.Auth
	}
	return nil
}

// A route is both a specification of how to match a request as well as an indication of what to do
// next (e.g., redirect, forward, rewrite, etc.).
//
// .. attention::
//
//   Envoy supports routing on HTTP method via :ref:`header matching
//   <envoy_api_msg_HeaderMatcher>`.
type Route struct {
	// Route matching parameters.
	Match *RouteMatch `protobuf:"bytes,1,opt,name=match" json:"match,omitempty"`
	// Types that are valid to be assigned to Action:
	//	*Route_Route
	//	*Route_Redirect
	//	*Route_DirectResponse
	Action isRoute_Action `protobuf_oneof:"action"`
	// The Metadata field can be used to provide additional information
	// about the route. It can be used for configuration, stats, and logging.
	// The metadata should go under the filter namespace that will need it.
	// For instance, if the metadata is intended for the Router filter,
	// the filter name should be specified as *envoy.router*.
	Metadata *Metadata `protobuf:"bytes,4,opt,name=metadata" json:"metadata,omitempty"`
	// Decorator for the matched route.
	Decorator *Decorator `protobuf:"bytes,5,opt,name=decorator" json:"decorator,omitempty"`
	// [#not-implemented-hide:]
	// Return a 401/403 when auth checks fail.
	Auth *AuthAction `protobuf:"bytes,6,opt,name=auth" json:"auth,omitempty"`
}

func (m *Route) Reset()                    { *m = Route{} }
func (m *Route) String() string            { return proto.CompactTextString(m) }
func (*Route) ProtoMessage()               {}
func (*Route) Descriptor() ([]byte, []int) { return fileDescriptorRds, []int{2} }

type isRoute_Action interface {
	isRoute_Action()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Route_Route struct {
	Route *RouteAction `protobuf:"bytes,2,opt,name=route,oneof"`
}
type Route_Redirect struct {
	Redirect *RedirectAction `protobuf:"bytes,3,opt,name=redirect,oneof"`
}
type Route_DirectResponse struct {
	DirectResponse *DirectResponseAction `protobuf:"bytes,7,opt,name=direct_response,json=directResponse,oneof"`
}

func (*Route_Route) isRoute_Action()          {}
func (*Route_Redirect) isRoute_Action()       {}
func (*Route_DirectResponse) isRoute_Action() {}

func (m *Route) GetAction() isRoute_Action {
	if m != nil {
		return m.Action
	}
	return nil
}

func (m *Route) GetMatch() *RouteMatch {
	if m != nil {
		return m.Match
	}
	return nil
}

func (m *Route) GetRoute() *RouteAction {
	if x, ok := m.GetAction().(*Route_Route); ok {
		return x.Route
	}
	return nil
}

func (m *Route) GetRedirect() *RedirectAction {
	if x, ok := m.GetAction().(*Route_Redirect); ok {
		return x.Redirect
	}
	return nil
}

func (m *Route) GetDirectResponse() *DirectResponseAction {
	if x, ok := m.GetAction().(*Route_DirectResponse); ok {
		return x.DirectResponse
	}
	return nil
}

func (m *Route) GetMetadata() *Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *Route) GetDecorator() *Decorator {
	if m != nil {
		return m.Decorator
	}
	return nil
}

func (m *Route) GetAuth() *AuthAction {
	if m != nil {
		return m.Auth
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Route) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Route_OneofMarshaler, _Route_OneofUnmarshaler, _Route_OneofSizer, []interface{}{
		(*Route_Route)(nil),
		(*Route_Redirect)(nil),
		(*Route_DirectResponse)(nil),
	}
}

func _Route_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Route)
	// action
	switch x := m.Action.(type) {
	case *Route_Route:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Route); err != nil {
			return err
		}
	case *Route_Redirect:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Redirect); err != nil {
			return err
		}
	case *Route_DirectResponse:
		_ = b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DirectResponse); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Route.Action has unexpected type %T", x)
	}
	return nil
}

func _Route_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Route)
	switch tag {
	case 2: // action.route
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RouteAction)
		err := b.DecodeMessage(msg)
		m.Action = &Route_Route{msg}
		return true, err
	case 3: // action.redirect
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RedirectAction)
		err := b.DecodeMessage(msg)
		m.Action = &Route_Redirect{msg}
		return true, err
	case 7: // action.direct_response
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DirectResponseAction)
		err := b.DecodeMessage(msg)
		m.Action = &Route_DirectResponse{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Route_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Route)
	// action
	switch x := m.Action.(type) {
	case *Route_Route:
		s := proto.Size(x.Route)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Route_Redirect:
		s := proto.Size(x.Redirect)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Route_DirectResponse:
		s := proto.Size(x.DirectResponse)
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Compared to the :ref:`cluster <envoy_api_field_RouteAction.cluster>` field that specifies a
// single upstream cluster as the target of a request, the :ref:`weighted_clusters
// <envoy_api_field_RouteAction.weighted_clusters>` option allows for specification of
// multiple upstream clusters along with weights that indicate the percentage of
// traffic to be forwarded to each cluster. The router selects an upstream cluster based on the
// weights.
type WeightedCluster struct {
	// Specifies one or more upstream clusters associated with the route.
	Clusters []*WeightedCluster_ClusterWeight `protobuf:"bytes,1,rep,name=clusters" json:"clusters,omitempty"`
	// Specifies the runtime key prefix that should be used to construct the
	// runtime keys associated with each cluster. When the *runtime_key_prefix* is
	// specified, the router will look for weights associated with each upstream
	// cluster under the key *runtime_key_prefix* + "." + *cluster[i].name* where
	// *cluster[i]* denotes an entry in the clusters array field. If the runtime
	// key for the cluster does not exist, the value specified in the
	// configuration file will be used as the default weight. See the :ref:`runtime documentation
	// <operations_runtime>` for how key names map to the underlying implementation.
	RuntimeKeyPrefix string `protobuf:"bytes,2,opt,name=runtime_key_prefix,json=runtimeKeyPrefix,proto3" json:"runtime_key_prefix,omitempty"`
}

func (m *WeightedCluster) Reset()                    { *m = WeightedCluster{} }
func (m *WeightedCluster) String() string            { return proto.CompactTextString(m) }
func (*WeightedCluster) ProtoMessage()               {}
func (*WeightedCluster) Descriptor() ([]byte, []int) { return fileDescriptorRds, []int{3} }

func (m *WeightedCluster) GetClusters() []*WeightedCluster_ClusterWeight {
	if m != nil {
		return m.Clusters
	}
	return nil
}

func (m *WeightedCluster) GetRuntimeKeyPrefix() string {
	if m != nil {
		return m.RuntimeKeyPrefix
	}
	return ""
}

type WeightedCluster_ClusterWeight struct {
	// Name of the upstream cluster. The cluster must exist in the
	// :ref:`cluster manager configuration <config_cluster_manager>`.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// An integer between 0-100. When a request matches the route, the choice of
	// an upstream cluster is determined by its weight. The sum of weights
	// across all entries in the clusters array must add up to 100.
	Weight *google_protobuf.UInt32Value `protobuf:"bytes,2,opt,name=weight" json:"weight,omitempty"`
	// Optional endpoint metadata match criteria. Only endpoints in the upstream
	// cluster with metadata matching that set in metadata_match will be
	// considered. The filter name should be specified as *envoy.lb*.
	MetadataMatch *Metadata `protobuf:"bytes,3,opt,name=metadata_match,json=metadataMatch" json:"metadata_match,omitempty"`
}

func (m *WeightedCluster_ClusterWeight) Reset()         { *m = WeightedCluster_ClusterWeight{} }
func (m *WeightedCluster_ClusterWeight) String() string { return proto.CompactTextString(m) }
func (*WeightedCluster_ClusterWeight) ProtoMessage()    {}
func (*WeightedCluster_ClusterWeight) Descriptor() ([]byte, []int) {
	return fileDescriptorRds, []int{3, 0}
}

func (m *WeightedCluster_ClusterWeight) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *WeightedCluster_ClusterWeight) GetWeight() *google_protobuf.UInt32Value {
	if m != nil {
		return m.Weight
	}
	return nil
}

func (m *WeightedCluster_ClusterWeight) GetMetadataMatch() *Metadata {
	if m != nil {
		return m.MetadataMatch
	}
	return nil
}

type RouteMatch struct {
	// Types that are valid to be assigned to PathSpecifier:
	//	*RouteMatch_Prefix
	//	*RouteMatch_Path
	//	*RouteMatch_Regex
	PathSpecifier isRouteMatch_PathSpecifier `protobuf_oneof:"path_specifier"`
	// Indicates that prefix/path matching should be case insensitive. The default
	// is true.
	CaseSensitive *google_protobuf.BoolValue `protobuf:"bytes,4,opt,name=case_sensitive,json=caseSensitive" json:"case_sensitive,omitempty"`
	// Indicates that the route should additionally match on a runtime key. An
	// integer between 0-100. Every time the route is considered for a match, a
	// random number between 0-99 is selected. If the number is <= the value found
	// in the key (checked first) or, if the key is not present, the default
	// value, the route is a match (assuming everything also about the route
	// matches). A runtime route configuration can be used to roll out route changes in a
	// gradual manner without full code/config deploys. Refer to the
	// :ref:`traffic shifting <config_http_conn_man_route_table_traffic_splitting_shift>` docs
	// for additional documentation.
	Runtime *RuntimeUInt32 `protobuf:"bytes,5,opt,name=runtime" json:"runtime,omitempty"`
	// Specifies a set of headers that the route should match on. The router will
	// check the request’s headers against all the specified headers in the route
	// config. A match will happen if all the headers in the route are present in
	// the request with the same values (or based on presence if the value field
	// is not in the config).
	Headers []*HeaderMatcher `protobuf:"bytes,6,rep,name=headers" json:"headers,omitempty"`
	// Specifies a set of URL query parameters on which the route should
	// match. The router will check the query string from the *path* header
	// against all the specified query parameters. If the number of specified
	// query parameters is nonzero, they all must match the *path* header's
	// query string for a match to occur.
	QueryParameters []*QueryParameterMatcher `protobuf:"bytes,7,rep,name=query_parameters,json=queryParameters" json:"query_parameters,omitempty"`
}

func (m *RouteMatch) Reset()                    { *m = RouteMatch{} }
func (m *RouteMatch) String() string            { return proto.CompactTextString(m) }
func (*RouteMatch) ProtoMessage()               {}
func (*RouteMatch) Descriptor() ([]byte, []int) { return fileDescriptorRds, []int{4} }

type isRouteMatch_PathSpecifier interface {
	isRouteMatch_PathSpecifier()
	MarshalTo([]byte) (int, error)
	Size() int
}

type RouteMatch_Prefix struct {
	Prefix string `protobuf:"bytes,1,opt,name=prefix,proto3,oneof"`
}
type RouteMatch_Path struct {
	Path string `protobuf:"bytes,2,opt,name=path,proto3,oneof"`
}
type RouteMatch_Regex struct {
	Regex string `protobuf:"bytes,3,opt,name=regex,proto3,oneof"`
}

func (*RouteMatch_Prefix) isRouteMatch_PathSpecifier() {}
func (*RouteMatch_Path) isRouteMatch_PathSpecifier()   {}
func (*RouteMatch_Regex) isRouteMatch_PathSpecifier()  {}

func (m *RouteMatch) GetPathSpecifier() isRouteMatch_PathSpecifier {
	if m != nil {
		return m.PathSpecifier
	}
	return nil
}

func (m *RouteMatch) GetPrefix() string {
	if x, ok := m.GetPathSpecifier().(*RouteMatch_Prefix); ok {
		return x.Prefix
	}
	return ""
}

func (m *RouteMatch) GetPath() string {
	if x, ok := m.GetPathSpecifier().(*RouteMatch_Path); ok {
		return x.Path
	}
	return ""
}

func (m *RouteMatch) GetRegex() string {
	if x, ok := m.GetPathSpecifier().(*RouteMatch_Regex); ok {
		return x.Regex
	}
	return ""
}

func (m *RouteMatch) GetCaseSensitive() *google_protobuf.BoolValue {
	if m != nil {
		return m.CaseSensitive
	}
	return nil
}

func (m *RouteMatch) GetRuntime() *RuntimeUInt32 {
	if m != nil {
		return m.Runtime
	}
	return nil
}

func (m *RouteMatch) GetHeaders() []*HeaderMatcher {
	if m != nil {
		return m.Headers
	}
	return nil
}

func (m *RouteMatch) GetQueryParameters() []*QueryParameterMatcher {
	if m != nil {
		return m.QueryParameters
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*RouteMatch) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _RouteMatch_OneofMarshaler, _RouteMatch_OneofUnmarshaler, _RouteMatch_OneofSizer, []interface{}{
		(*RouteMatch_Prefix)(nil),
		(*RouteMatch_Path)(nil),
		(*RouteMatch_Regex)(nil),
	}
}

func _RouteMatch_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*RouteMatch)
	// path_specifier
	switch x := m.PathSpecifier.(type) {
	case *RouteMatch_Prefix:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.Prefix)
	case *RouteMatch_Path:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.Path)
	case *RouteMatch_Regex:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.Regex)
	case nil:
	default:
		return fmt.Errorf("RouteMatch.PathSpecifier has unexpected type %T", x)
	}
	return nil
}

func _RouteMatch_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*RouteMatch)
	switch tag {
	case 1: // path_specifier.prefix
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.PathSpecifier = &RouteMatch_Prefix{x}
		return true, err
	case 2: // path_specifier.path
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.PathSpecifier = &RouteMatch_Path{x}
		return true, err
	case 3: // path_specifier.regex
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.PathSpecifier = &RouteMatch_Regex{x}
		return true, err
	default:
		return false, nil
	}
}

func _RouteMatch_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*RouteMatch)
	// path_specifier
	switch x := m.PathSpecifier.(type) {
	case *RouteMatch_Prefix:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Prefix)))
		n += len(x.Prefix)
	case *RouteMatch_Path:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Path)))
		n += len(x.Path)
	case *RouteMatch_Regex:
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Regex)))
		n += len(x.Regex)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type CorsPolicy struct {
	// Specifies the origins that will be allowed to do CORS requests.
	AllowOrigin []string `protobuf:"bytes,1,rep,name=allow_origin,json=allowOrigin" json:"allow_origin,omitempty"`
	// Specifies the content for the *access-control-allow-methods* header.
	AllowMethods string `protobuf:"bytes,2,opt,name=allow_methods,json=allowMethods,proto3" json:"allow_methods,omitempty"`
	// Specifies the content for the *access-control-allow-headers* header.
	AllowHeaders string `protobuf:"bytes,3,opt,name=allow_headers,json=allowHeaders,proto3" json:"allow_headers,omitempty"`
	// Specifies the content for the *access-control-expose-headers* header.
	ExposeHeaders string `protobuf:"bytes,4,opt,name=expose_headers,json=exposeHeaders,proto3" json:"expose_headers,omitempty"`
	// Specifies the content for the *access-control-max-age* header.
	MaxAge string `protobuf:"bytes,5,opt,name=max_age,json=maxAge,proto3" json:"max_age,omitempty"`
	// Specifies whether the resource allows credentials.
	AllowCredentials *google_protobuf.BoolValue `protobuf:"bytes,6,opt,name=allow_credentials,json=allowCredentials" json:"allow_credentials,omitempty"`
	// Specifies if CORS is enabled. Defaults to true. Only effective on route.
	Enabled *google_protobuf.BoolValue `protobuf:"bytes,7,opt,name=enabled" json:"enabled,omitempty"`
}

func (m *CorsPolicy) Reset()                    { *m = CorsPolicy{} }
func (m *CorsPolicy) String() string            { return proto.CompactTextString(m) }
func (*CorsPolicy) ProtoMessage()               {}
func (*CorsPolicy) Descriptor() ([]byte, []int) { return fileDescriptorRds, []int{5} }

func (m *CorsPolicy) GetAllowOrigin() []string {
	if m != nil {
		return m.AllowOrigin
	}
	return nil
}

func (m *CorsPolicy) GetAllowMethods() string {
	if m != nil {
		return m.AllowMethods
	}
	return ""
}

func (m *CorsPolicy) GetAllowHeaders() string {
	if m != nil {
		return m.AllowHeaders
	}
	return ""
}

func (m *CorsPolicy) GetExposeHeaders() string {
	if m != nil {
		return m.ExposeHeaders
	}
	return ""
}

func (m *CorsPolicy) GetMaxAge() string {
	if m != nil {
		return m.MaxAge
	}
	return ""
}

func (m *CorsPolicy) GetAllowCredentials() *google_protobuf.BoolValue {
	if m != nil {
		return m.AllowCredentials
	}
	return nil
}

func (m *CorsPolicy) GetEnabled() *google_protobuf.BoolValue {
	if m != nil {
		return m.Enabled
	}
	return nil
}

type RouteAction struct {
	// Types that are valid to be assigned to ClusterSpecifier:
	//	*RouteAction_Cluster
	//	*RouteAction_ClusterHeader
	//	*RouteAction_WeightedClusters
	ClusterSpecifier isRouteAction_ClusterSpecifier `protobuf_oneof:"cluster_specifier"`
	// The HTTP status code to use when configured cluster is not found.
	// The default response code is 503 Service Unavailable.
	ClusterNotFoundResponseCode RouteAction_ClusterNotFoundResponseCode `protobuf:"varint,20,opt,name=cluster_not_found_response_code,json=clusterNotFoundResponseCode,proto3,enum=envoy.api.v2.RouteAction_ClusterNotFoundResponseCode" json:"cluster_not_found_response_code,omitempty"`
	// Optional endpoint metadata match criteria. Only endpoints in the upstream
	// cluster with metadata matching that set in metadata_match will be
	// considered. The filter name should be specified as *envoy.lb*.
	MetadataMatch *Metadata `protobuf:"bytes,4,opt,name=metadata_match,json=metadataMatch" json:"metadata_match,omitempty"`
	// Indicates that during forwarding, the matched prefix (or path) should be
	// swapped with this value. This option allows application URLs to be rooted
	// at a different path from those exposed at the reverse proxy layer.
	PrefixRewrite string `protobuf:"bytes,5,opt,name=prefix_rewrite,json=prefixRewrite,proto3" json:"prefix_rewrite,omitempty"`
	// Types that are valid to be assigned to HostRewriteSpecifier:
	//	*RouteAction_HostRewrite
	//	*RouteAction_AutoHostRewrite
	HostRewriteSpecifier isRouteAction_HostRewriteSpecifier `protobuf_oneof:"host_rewrite_specifier"`
	// Specifies the timeout for the route. If not specified, the default is 15s.
	//
	// .. note::
	//
	//   This timeout includes all retries. See also
	//   :ref:`config_http_filters_router_x-envoy-upstream-rq-timeout-ms`,
	//   :ref:`config_http_filters_router_x-envoy-upstream-rq-per-try-timeout-ms`, and the
	//   :ref:`retry overview <arch_overview_http_routing_retry>`.
	Timeout *time.Duration `protobuf:"bytes,8,opt,name=timeout,stdduration" json:"timeout,omitempty"`
	// Indicates that the route has a retry policy.
	RetryPolicy *RouteAction_RetryPolicy `protobuf:"bytes,9,opt,name=retry_policy,json=retryPolicy" json:"retry_policy,omitempty"`
	// Indicates that the route has a request mirroring policy.
	RequestMirrorPolicy *RouteAction_RequestMirrorPolicy `protobuf:"bytes,10,opt,name=request_mirror_policy,json=requestMirrorPolicy" json:"request_mirror_policy,omitempty"`
	// Optionally specifies the :ref:`routing priority <arch_overview_http_routing_priority>`.
	// [#comment:TODO(htuch): add (validate.rules).enum.defined_only = true once
	// https://github.com/lyft/protoc-gen-validate/issues/42 is resolved.]
	Priority RoutingPriority `protobuf:"varint,11,opt,name=priority,proto3,enum=envoy.api.v2.RoutingPriority" json:"priority,omitempty"`
	// Specifies a set of headers that will be added to requests matching this
	// route. Headers specified at this level are applied before headers from the
	// enclosing :ref:`envoy_api_msg_VirtualHost` and :ref:`envoy_api_msg_RouteConfiguration`.
	// For more information see the documentation on :ref:`custom request headers
	// <config_http_conn_man_headers_custom_request_headers>`.
	RequestHeadersToAdd []*HeaderValueOption `protobuf:"bytes,12,rep,name=request_headers_to_add,json=requestHeadersToAdd" json:"request_headers_to_add,omitempty"`
	// Specifies a set of headers that will be added to responses to requests
	// matching this route. Headers specified at this level are applied before
	// headers from the enclosing :ref:`envoy_api_msg_VirtualHost` and
	// :ref:`envoy_api_msg_RouteConfiguration`.
	ResponseHeadersToAdd []*HeaderValueOption `protobuf:"bytes,18,rep,name=response_headers_to_add,json=responseHeadersToAdd" json:"response_headers_to_add,omitempty"`
	// Specifies a list of HTTP headers that should be removed from each response
	// to requests matching this route.
	ResponseHeadersToRemove []string `protobuf:"bytes,19,rep,name=response_headers_to_remove,json=responseHeadersToRemove" json:"response_headers_to_remove,omitempty"`
	// Specifies a set of rate limit configurations that could be applied to the
	// route.
	RateLimits []*RateLimit `protobuf:"bytes,13,rep,name=rate_limits,json=rateLimits" json:"rate_limits,omitempty"`
	// Specifies if the rate limit filter should include the virtual host rate
	// limits. By default, if the route configured rate limits, the virtual host
	// :ref:`rate_limits <envoy_api_field_VirtualHost.rate_limits>` are not applied to the request.
	IncludeVhRateLimits *google_protobuf.BoolValue `protobuf:"bytes,14,opt,name=include_vh_rate_limits,json=includeVhRateLimits" json:"include_vh_rate_limits,omitempty"`
	// Specifies a list of hash policies to use for ring hash load balancing. Each
	// hash policy is evaluated individually and the combined result is used to
	// route the request. The method of combination is deterministic such that
	// identical lists of hash policies will produce the same hash. Since a hash
	// policy examines specific parts of a request, it can fail to produce a hash
	// (i.e. if the hashed header is not present). If (and only if) all configured
	// hash policies fail to generate a hash, no hash will be produced for
	// the route. In this case, the behavior is the same as if no hash policies
	// were specified (i.e. the ring hash load balancer will choose a random
	// backend).
	HashPolicy []*RouteAction_HashPolicy `protobuf:"bytes,15,rep,name=hash_policy,json=hashPolicy" json:"hash_policy,omitempty"`
	// Indicates that a HTTP/1.1 client connection to this particular route
	// should be allowed (and expected) to upgrade to a WebSocket connection. The
	// default is false.
	//
	// .. attention::
	//
	//   If set to true, Envoy will expect the first request matching this route to
	//   contain WebSocket upgrade headers. If the headers are not present, the
	//   connection will be rejected. If set to true, Envoy will setup plain TCP
	//   proxying between the client and the upstream server. Hence, an upstream
	//   server that rejects the WebSocket upgrade request is also responsible for
	//   closing the associated connection. Until then, Envoy will continue to
	//   proxy data from the client to the upstream server.
	//
	//   Redirects, timeouts and retries are not supported on routes where websocket upgrades are
	//   allowed.
	UseWebsocket *google_protobuf.BoolValue `protobuf:"bytes,16,opt,name=use_websocket,json=useWebsocket" json:"use_websocket,omitempty"`
	// Indicates that the route has a CORS policy.
	Cors *CorsPolicy `protobuf:"bytes,17,opt,name=cors" json:"cors,omitempty"`
}

func (m *RouteAction) Reset()                    { *m = RouteAction{} }
func (m *RouteAction) String() string            { return proto.CompactTextString(m) }
func (*RouteAction) ProtoMessage()               {}
func (*RouteAction) Descriptor() ([]byte, []int) { return fileDescriptorRds, []int{6} }

type isRouteAction_ClusterSpecifier interface {
	isRouteAction_ClusterSpecifier()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isRouteAction_HostRewriteSpecifier interface {
	isRouteAction_HostRewriteSpecifier()
	MarshalTo([]byte) (int, error)
	Size() int
}

type RouteAction_Cluster struct {
	Cluster string `protobuf:"bytes,1,opt,name=cluster,proto3,oneof"`
}
type RouteAction_ClusterHeader struct {
	ClusterHeader string `protobuf:"bytes,2,opt,name=cluster_header,json=clusterHeader,proto3,oneof"`
}
type RouteAction_WeightedClusters struct {
	WeightedClusters *WeightedCluster `protobuf:"bytes,3,opt,name=weighted_clusters,json=weightedClusters,oneof"`
}
type RouteAction_HostRewrite struct {
	HostRewrite string `protobuf:"bytes,6,opt,name=host_rewrite,json=hostRewrite,proto3,oneof"`
}
type RouteAction_AutoHostRewrite struct {
	AutoHostRewrite *google_protobuf.BoolValue `protobuf:"bytes,7,opt,name=auto_host_rewrite,json=autoHostRewrite,oneof"`
}

func (*RouteAction_Cluster) isRouteAction_ClusterSpecifier()             {}
func (*RouteAction_ClusterHeader) isRouteAction_ClusterSpecifier()       {}
func (*RouteAction_WeightedClusters) isRouteAction_ClusterSpecifier()    {}
func (*RouteAction_HostRewrite) isRouteAction_HostRewriteSpecifier()     {}
func (*RouteAction_AutoHostRewrite) isRouteAction_HostRewriteSpecifier() {}

func (m *RouteAction) GetClusterSpecifier() isRouteAction_ClusterSpecifier {
	if m != nil {
		return m.ClusterSpecifier
	}
	return nil
}
func (m *RouteAction) GetHostRewriteSpecifier() isRouteAction_HostRewriteSpecifier {
	if m != nil {
		return m.HostRewriteSpecifier
	}
	return nil
}

func (m *RouteAction) GetCluster() string {
	if x, ok := m.GetClusterSpecifier().(*RouteAction_Cluster); ok {
		return x.Cluster
	}
	return ""
}

func (m *RouteAction) GetClusterHeader() string {
	if x, ok := m.GetClusterSpecifier().(*RouteAction_ClusterHeader); ok {
		return x.ClusterHeader
	}
	return ""
}

func (m *RouteAction) GetWeightedClusters() *WeightedCluster {
	if x, ok := m.GetClusterSpecifier().(*RouteAction_WeightedClusters); ok {
		return x.WeightedClusters
	}
	return nil
}

func (m *RouteAction) GetClusterNotFoundResponseCode() RouteAction_ClusterNotFoundResponseCode {
	if m != nil {
		return m.ClusterNotFoundResponseCode
	}
	return RouteAction_SERVICE_UNAVAILABLE
}

func (m *RouteAction) GetMetadataMatch() *Metadata {
	if m != nil {
		return m.MetadataMatch
	}
	return nil
}

func (m *RouteAction) GetPrefixRewrite() string {
	if m != nil {
		return m.PrefixRewrite
	}
	return ""
}

func (m *RouteAction) GetHostRewrite() string {
	if x, ok := m.GetHostRewriteSpecifier().(*RouteAction_HostRewrite); ok {
		return x.HostRewrite
	}
	return ""
}

func (m *RouteAction) GetAutoHostRewrite() *google_protobuf.BoolValue {
	if x, ok := m.GetHostRewriteSpecifier().(*RouteAction_AutoHostRewrite); ok {
		return x.AutoHostRewrite
	}
	return nil
}

func (m *RouteAction) GetTimeout() *time.Duration {
	if m != nil {
		return m.Timeout
	}
	return nil
}

func (m *RouteAction) GetRetryPolicy() *RouteAction_RetryPolicy {
	if m != nil {
		return m.RetryPolicy
	}
	return nil
}

func (m *RouteAction) GetRequestMirrorPolicy() *RouteAction_RequestMirrorPolicy {
	if m != nil {
		return m.RequestMirrorPolicy
	}
	return nil
}

func (m *RouteAction) GetPriority() RoutingPriority {
	if m != nil {
		return m.Priority
	}
	return RoutingPriority_DEFAULT
}

func (m *RouteAction) GetRequestHeadersToAdd() []*HeaderValueOption {
	if m != nil {
		return m.RequestHeadersToAdd
	}
	return nil
}

func (m *RouteAction) GetResponseHeadersToAdd() []*HeaderValueOption {
	if m != nil {
		return m.ResponseHeadersToAdd
	}
	return nil
}

func (m *RouteAction) GetResponseHeadersToRemove() []string {
	if m != nil {
		return m.ResponseHeadersToRemove
	}
	return nil
}

func (m *RouteAction) GetRateLimits() []*RateLimit {
	if m != nil {
		return m.RateLimits
	}
	return nil
}

func (m *RouteAction) GetIncludeVhRateLimits() *google_protobuf.BoolValue {
	if m != nil {
		return m.IncludeVhRateLimits
	}
	return nil
}

func (m *RouteAction) GetHashPolicy() []*RouteAction_HashPolicy {
	if m != nil {
		return m.HashPolicy
	}
	return nil
}

func (m *RouteAction) GetUseWebsocket() *google_protobuf.BoolValue {
	if m != nil {
		return m.UseWebsocket
	}
	return nil
}

func (m *RouteAction) GetCors() *CorsPolicy {
	if m != nil {
		return m.Cors
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*RouteAction) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _RouteAction_OneofMarshaler, _RouteAction_OneofUnmarshaler, _RouteAction_OneofSizer, []interface{}{
		(*RouteAction_Cluster)(nil),
		(*RouteAction_ClusterHeader)(nil),
		(*RouteAction_WeightedClusters)(nil),
		(*RouteAction_HostRewrite)(nil),
		(*RouteAction_AutoHostRewrite)(nil),
	}
}

func _RouteAction_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*RouteAction)
	// cluster_specifier
	switch x := m.ClusterSpecifier.(type) {
	case *RouteAction_Cluster:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.Cluster)
	case *RouteAction_ClusterHeader:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.ClusterHeader)
	case *RouteAction_WeightedClusters:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.WeightedClusters); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("RouteAction.ClusterSpecifier has unexpected type %T", x)
	}
	// host_rewrite_specifier
	switch x := m.HostRewriteSpecifier.(type) {
	case *RouteAction_HostRewrite:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.HostRewrite)
	case *RouteAction_AutoHostRewrite:
		_ = b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AutoHostRewrite); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("RouteAction.HostRewriteSpecifier has unexpected type %T", x)
	}
	return nil
}

func _RouteAction_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*RouteAction)
	switch tag {
	case 1: // cluster_specifier.cluster
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.ClusterSpecifier = &RouteAction_Cluster{x}
		return true, err
	case 2: // cluster_specifier.cluster_header
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.ClusterSpecifier = &RouteAction_ClusterHeader{x}
		return true, err
	case 3: // cluster_specifier.weighted_clusters
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(WeightedCluster)
		err := b.DecodeMessage(msg)
		m.ClusterSpecifier = &RouteAction_WeightedClusters{msg}
		return true, err
	case 6: // host_rewrite_specifier.host_rewrite
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.HostRewriteSpecifier = &RouteAction_HostRewrite{x}
		return true, err
	case 7: // host_rewrite_specifier.auto_host_rewrite
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(google_protobuf.BoolValue)
		err := b.DecodeMessage(msg)
		m.HostRewriteSpecifier = &RouteAction_AutoHostRewrite{msg}
		return true, err
	default:
		return false, nil
	}
}

func _RouteAction_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*RouteAction)
	// cluster_specifier
	switch x := m.ClusterSpecifier.(type) {
	case *RouteAction_Cluster:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Cluster)))
		n += len(x.Cluster)
	case *RouteAction_ClusterHeader:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.ClusterHeader)))
		n += len(x.ClusterHeader)
	case *RouteAction_WeightedClusters:
		s := proto.Size(x.WeightedClusters)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// host_rewrite_specifier
	switch x := m.HostRewriteSpecifier.(type) {
	case *RouteAction_HostRewrite:
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.HostRewrite)))
		n += len(x.HostRewrite)
	case *RouteAction_AutoHostRewrite:
		s := proto.Size(x.AutoHostRewrite)
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// HTTP retry :ref:`architecture overview <arch_overview_http_routing_retry>`.
type RouteAction_RetryPolicy struct {
	// Specifies the conditions under which retry takes place. These are the same
	// conditions documented for :ref:`config_http_filters_router_x-envoy-retry-on` and
	// :ref:`config_http_filters_router_x-envoy-retry-grpc-on`.
	RetryOn string `protobuf:"bytes,1,opt,name=retry_on,json=retryOn,proto3" json:"retry_on,omitempty"`
	// Specifies the allowed number of retries. This parameter is optional and
	// defaults to 1. These are the same conditions documented for
	// :ref:`config_http_filters_router_x-envoy-max-retries`.
	NumRetries *google_protobuf.UInt32Value `protobuf:"bytes,2,opt,name=num_retries,json=numRetries" json:"num_retries,omitempty"`
	// Specifies a non-zero timeout per retry attempt. This parameter is optional.
	// The same conditions documented for
	// :ref:`config_http_filters_router_x-envoy-upstream-rq-per-try-timeout-ms` apply.
	//
	// .. note::
	//
	//   If left unspecified, Envoy will use the global
	//   :ref:`route timeout <envoy_api_field_RouteAction.timeout>` for the request.
	//   Consequently, when using a :ref:`5xx <config_http_filters_router_x-envoy-retry-on>` based
	//   retry policy, a request that times out will not be retried as the total timeout budget
	//   would have been exhausted.
	PerTryTimeout *time.Duration `protobuf:"bytes,3,opt,name=per_try_timeout,json=perTryTimeout,stdduration" json:"per_try_timeout,omitempty"`
}

func (m *RouteAction_RetryPolicy) Reset()                    { *m = RouteAction_RetryPolicy{} }
func (m *RouteAction_RetryPolicy) String() string            { return proto.CompactTextString(m) }
func (*RouteAction_RetryPolicy) ProtoMessage()               {}
func (*RouteAction_RetryPolicy) Descriptor() ([]byte, []int) { return fileDescriptorRds, []int{6, 0} }

func (m *RouteAction_RetryPolicy) GetRetryOn() string {
	if m != nil {
		return m.RetryOn
	}
	return ""
}

func (m *RouteAction_RetryPolicy) GetNumRetries() *google_protobuf.UInt32Value {
	if m != nil {
		return m.NumRetries
	}
	return nil
}

func (m *RouteAction_RetryPolicy) GetPerTryTimeout() *time.Duration {
	if m != nil {
		return m.PerTryTimeout
	}
	return nil
}

// The router is capable of shadowing traffic from one cluster to another. The current
// implementation is "fire and forget," meaning Envoy will not wait for the shadow cluster to
// respond before returning the response from the primary cluster. All normal statistics are
// collected for the shadow cluster making this feature useful for testing.
//
// During shadowing, the host/authority header is altered such that *-shadow* is appended. This is
// useful for logging. For example, *cluster1* becomes *cluster1-shadow*.
type RouteAction_RequestMirrorPolicy struct {
	// Specifies the cluster that requests will be mirrored to. The cluster must
	// exist in the cluster manager configuration.
	Cluster string `protobuf:"bytes,1,opt,name=cluster,proto3" json:"cluster,omitempty"`
	// If not specified, all requests to the target cluster will be mirrored. If
	// specified, Envoy will lookup the runtime key to get the % of requests to
	// mirror. Valid values are from 0 to 10000, allowing for increments of
	// 0.01% of requests to be mirrored. If the runtime key is specified in the
	// configuration but not present in runtime, 0 is the default and thus 0% of
	// requests will be mirrored.
	RuntimeKey string `protobuf:"bytes,2,opt,name=runtime_key,json=runtimeKey,proto3" json:"runtime_key,omitempty"`
}

func (m *RouteAction_RequestMirrorPolicy) Reset()         { *m = RouteAction_RequestMirrorPolicy{} }
func (m *RouteAction_RequestMirrorPolicy) String() string { return proto.CompactTextString(m) }
func (*RouteAction_RequestMirrorPolicy) ProtoMessage()    {}
func (*RouteAction_RequestMirrorPolicy) Descriptor() ([]byte, []int) {
	return fileDescriptorRds, []int{6, 1}
}

func (m *RouteAction_RequestMirrorPolicy) GetCluster() string {
	if m != nil {
		return m.Cluster
	}
	return ""
}

func (m *RouteAction_RequestMirrorPolicy) GetRuntimeKey() string {
	if m != nil {
		return m.RuntimeKey
	}
	return ""
}

// Specifies the route's hashing policy if the upstream cluster uses a hashing :ref:`load balancer
// <arch_overview_load_balancing_types>`.
type RouteAction_HashPolicy struct {
	// Types that are valid to be assigned to PolicySpecifier:
	//	*RouteAction_HashPolicy_Header_
	//	*RouteAction_HashPolicy_Cookie_
	//	*RouteAction_HashPolicy_ConnectionProperties_
	PolicySpecifier isRouteAction_HashPolicy_PolicySpecifier `protobuf_oneof:"policy_specifier"`
}

func (m *RouteAction_HashPolicy) Reset()                    { *m = RouteAction_HashPolicy{} }
func (m *RouteAction_HashPolicy) String() string            { return proto.CompactTextString(m) }
func (*RouteAction_HashPolicy) ProtoMessage()               {}
func (*RouteAction_HashPolicy) Descriptor() ([]byte, []int) { return fileDescriptorRds, []int{6, 2} }

type isRouteAction_HashPolicy_PolicySpecifier interface {
	isRouteAction_HashPolicy_PolicySpecifier()
	MarshalTo([]byte) (int, error)
	Size() int
}

type RouteAction_HashPolicy_Header_ struct {
	Header *RouteAction_HashPolicy_Header `protobuf:"bytes,1,opt,name=header,oneof"`
}
type RouteAction_HashPolicy_Cookie_ struct {
	Cookie *RouteAction_HashPolicy_Cookie `protobuf:"bytes,2,opt,name=cookie,oneof"`
}
type RouteAction_HashPolicy_ConnectionProperties_ struct {
	ConnectionProperties *RouteAction_HashPolicy_ConnectionProperties `protobuf:"bytes,3,opt,name=connection_properties,json=connectionProperties,oneof"`
}

func (*RouteAction_HashPolicy_Header_) isRouteAction_HashPolicy_PolicySpecifier()               {}
func (*RouteAction_HashPolicy_Cookie_) isRouteAction_HashPolicy_PolicySpecifier()               {}
func (*RouteAction_HashPolicy_ConnectionProperties_) isRouteAction_HashPolicy_PolicySpecifier() {}

func (m *RouteAction_HashPolicy) GetPolicySpecifier() isRouteAction_HashPolicy_PolicySpecifier {
	if m != nil {
		return m.PolicySpecifier
	}
	return nil
}

func (m *RouteAction_HashPolicy) GetHeader() *RouteAction_HashPolicy_Header {
	if x, ok := m.GetPolicySpecifier().(*RouteAction_HashPolicy_Header_); ok {
		return x.Header
	}
	return nil
}

func (m *RouteAction_HashPolicy) GetCookie() *RouteAction_HashPolicy_Cookie {
	if x, ok := m.GetPolicySpecifier().(*RouteAction_HashPolicy_Cookie_); ok {
		return x.Cookie
	}
	return nil
}

func (m *RouteAction_HashPolicy) GetConnectionProperties() *RouteAction_HashPolicy_ConnectionProperties {
	if x, ok := m.GetPolicySpecifier().(*RouteAction_HashPolicy_ConnectionProperties_); ok {
		return x.ConnectionProperties
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*RouteAction_HashPolicy) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _RouteAction_HashPolicy_OneofMarshaler, _RouteAction_HashPolicy_OneofUnmarshaler, _RouteAction_HashPolicy_OneofSizer, []interface{}{
		(*RouteAction_HashPolicy_Header_)(nil),
		(*RouteAction_HashPolicy_Cookie_)(nil),
		(*RouteAction_HashPolicy_ConnectionProperties_)(nil),
	}
}

func _RouteAction_HashPolicy_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*RouteAction_HashPolicy)
	// policy_specifier
	switch x := m.PolicySpecifier.(type) {
	case *RouteAction_HashPolicy_Header_:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Header); err != nil {
			return err
		}
	case *RouteAction_HashPolicy_Cookie_:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Cookie); err != nil {
			return err
		}
	case *RouteAction_HashPolicy_ConnectionProperties_:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ConnectionProperties); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("RouteAction_HashPolicy.PolicySpecifier has unexpected type %T", x)
	}
	return nil
}

func _RouteAction_HashPolicy_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*RouteAction_HashPolicy)
	switch tag {
	case 1: // policy_specifier.header
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RouteAction_HashPolicy_Header)
		err := b.DecodeMessage(msg)
		m.PolicySpecifier = &RouteAction_HashPolicy_Header_{msg}
		return true, err
	case 2: // policy_specifier.cookie
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RouteAction_HashPolicy_Cookie)
		err := b.DecodeMessage(msg)
		m.PolicySpecifier = &RouteAction_HashPolicy_Cookie_{msg}
		return true, err
	case 3: // policy_specifier.connection_properties
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RouteAction_HashPolicy_ConnectionProperties)
		err := b.DecodeMessage(msg)
		m.PolicySpecifier = &RouteAction_HashPolicy_ConnectionProperties_{msg}
		return true, err
	default:
		return false, nil
	}
}

func _RouteAction_HashPolicy_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*RouteAction_HashPolicy)
	// policy_specifier
	switch x := m.PolicySpecifier.(type) {
	case *RouteAction_HashPolicy_Header_:
		s := proto.Size(x.Header)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RouteAction_HashPolicy_Cookie_:
		s := proto.Size(x.Cookie)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RouteAction_HashPolicy_ConnectionProperties_:
		s := proto.Size(x.ConnectionProperties)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type RouteAction_HashPolicy_Header struct {
	// The name of the request header that will be used to obtain the hash
	// key. If the request header is not present, no hash will be produced.
	HeaderName string `protobuf:"bytes,1,opt,name=header_name,json=headerName,proto3" json:"header_name,omitempty"`
}

func (m *RouteAction_HashPolicy_Header) Reset()         { *m = RouteAction_HashPolicy_Header{} }
func (m *RouteAction_HashPolicy_Header) String() string { return proto.CompactTextString(m) }
func (*RouteAction_HashPolicy_Header) ProtoMessage()    {}
func (*RouteAction_HashPolicy_Header) Descriptor() ([]byte, []int) {
	return fileDescriptorRds, []int{6, 2, 0}
}

func (m *RouteAction_HashPolicy_Header) GetHeaderName() string {
	if m != nil {
		return m.HeaderName
	}
	return ""
}

// Envoy supports two types of cookie affinity:
//
// 1. Passive. Envoy takes a cookie that's present in the cookies header and
//    hashes on its value.
//
// 2. Generated. Envoy generates and sets a cookie with an expiration (TTL)
//    on the first request from the client in its response to the client,
//    based on the endpoint the request gets sent to. The client then
//    presents this on the next and all subsequent requests. The hash of
//    this is sufficient to ensure these requests get sent to the same
//    endpoint. The cookie is generated by hashing the source and
//    destination ports and addresses so that multiple independent HTTP2
//    streams on the same connection will independently receive the same
//    cookie, even if they arrive at the Envoy simultaneously.
type RouteAction_HashPolicy_Cookie struct {
	// The name of the cookie that will be used to obtain the hash key. If the
	// cookie is not present and ttl below is not set, no hash will be
	// produced.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// If specified, a cookie with the TTL will be generated if the cookie is
	// not present.
	Ttl *time.Duration `protobuf:"bytes,2,opt,name=ttl,stdduration" json:"ttl,omitempty"`
}

func (m *RouteAction_HashPolicy_Cookie) Reset()         { *m = RouteAction_HashPolicy_Cookie{} }
func (m *RouteAction_HashPolicy_Cookie) String() string { return proto.CompactTextString(m) }
func (*RouteAction_HashPolicy_Cookie) ProtoMessage()    {}
func (*RouteAction_HashPolicy_Cookie) Descriptor() ([]byte, []int) {
	return fileDescriptorRds, []int{6, 2, 1}
}

func (m *RouteAction_HashPolicy_Cookie) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *RouteAction_HashPolicy_Cookie) GetTtl() *time.Duration {
	if m != nil {
		return m.Ttl
	}
	return nil
}

type RouteAction_HashPolicy_ConnectionProperties struct {
	// Hash on source IP address.
	SourceIp bool `protobuf:"varint,1,opt,name=source_ip,json=sourceIp,proto3" json:"source_ip,omitempty"`
}

func (m *RouteAction_HashPolicy_ConnectionProperties) Reset() {
	*m = RouteAction_HashPolicy_ConnectionProperties{}
}
func (m *RouteAction_HashPolicy_ConnectionProperties) String() string {
	return proto.CompactTextString(m)
}
func (*RouteAction_HashPolicy_ConnectionProperties) ProtoMessage() {}
func (*RouteAction_HashPolicy_ConnectionProperties) Descriptor() ([]byte, []int) {
	return fileDescriptorRds, []int{6, 2, 2}
}

func (m *RouteAction_HashPolicy_ConnectionProperties) GetSourceIp() bool {
	if m != nil {
		return m.SourceIp
	}
	return false
}

type RedirectAction struct {
	// The host portion of the URL will be swapped with this value.
	HostRedirect string `protobuf:"bytes,1,opt,name=host_redirect,json=hostRedirect,proto3" json:"host_redirect,omitempty"`
	// The path portion of the URL will be swapped with this value.
	PathRedirect string `protobuf:"bytes,2,opt,name=path_redirect,json=pathRedirect,proto3" json:"path_redirect,omitempty"`
	// The HTTP status code to use in the redirect response. The default response
	// code is MOVED_PERMANENTLY (301).
	ResponseCode RedirectAction_RedirectResponseCode `protobuf:"varint,3,opt,name=response_code,json=responseCode,proto3,enum=envoy.api.v2.RedirectAction_RedirectResponseCode" json:"response_code,omitempty"`
}

func (m *RedirectAction) Reset()                    { *m = RedirectAction{} }
func (m *RedirectAction) String() string            { return proto.CompactTextString(m) }
func (*RedirectAction) ProtoMessage()               {}
func (*RedirectAction) Descriptor() ([]byte, []int) { return fileDescriptorRds, []int{7} }

func (m *RedirectAction) GetHostRedirect() string {
	if m != nil {
		return m.HostRedirect
	}
	return ""
}

func (m *RedirectAction) GetPathRedirect() string {
	if m != nil {
		return m.PathRedirect
	}
	return ""
}

func (m *RedirectAction) GetResponseCode() RedirectAction_RedirectResponseCode {
	if m != nil {
		return m.ResponseCode
	}
	return RedirectAction_MOVED_PERMANENTLY
}

type DirectResponseAction struct {
	// Specifies the HTTP response status to be returned.
	Status uint32 `protobuf:"varint,1,opt,name=status,proto3" json:"status,omitempty"`
	// Specifies the content of the response body. If this setting is omitted,
	// no body is included in the generated response.
	//
	// .. note::
	//
	//   Headers can be specified using *response_headers_to_add* in
	//   :ref:`envoy_api_msg_RouteConfiguration`.
	Body *DataSource `protobuf:"bytes,2,opt,name=body" json:"body,omitempty"`
}

func (m *DirectResponseAction) Reset()                    { *m = DirectResponseAction{} }
func (m *DirectResponseAction) String() string            { return proto.CompactTextString(m) }
func (*DirectResponseAction) ProtoMessage()               {}
func (*DirectResponseAction) Descriptor() ([]byte, []int) { return fileDescriptorRds, []int{8} }

func (m *DirectResponseAction) GetStatus() uint32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *DirectResponseAction) GetBody() *DataSource {
	if m != nil {
		return m.Body
	}
	return nil
}

type Decorator struct {
	// The operation name associated with the request matched to this route. If tracing is
	// enabled, this information will be used as the span name reported for this request.
	//
	// .. note::
	//
	//   For ingress (inbound) requests, or egress (outbound) responses, this value may be overridden
	//   by the :ref:`x-envoy-decorator-operation
	//   <config_http_filters_router_x-envoy-decorator-operation>` header.
	Operation string `protobuf:"bytes,1,opt,name=operation,proto3" json:"operation,omitempty"`
}

func (m *Decorator) Reset()                    { *m = Decorator{} }
func (m *Decorator) String() string            { return proto.CompactTextString(m) }
func (*Decorator) ProtoMessage()               {}
func (*Decorator) Descriptor() ([]byte, []int) { return fileDescriptorRds, []int{9} }

func (m *Decorator) GetOperation() string {
	if m != nil {
		return m.Operation
	}
	return ""
}

// A virtual cluster is a way of specifying a regex matching rule against
// certain important endpoints such that statistics are generated explicitly for
// the matched requests. The reason this is useful is that when doing
// prefix/path matching Envoy does not always know what the application
// considers to be an endpoint. Thus, it’s impossible for Envoy to generically
// emit per endpoint statistics. However, often systems have highly critical
// endpoints that they wish to get “perfect” statistics on. Virtual cluster
// statistics are perfect in the sense that they are emitted on the downstream
// side such that they include network level failures.
//
// Documentation for :ref:`virtual cluster statistics <config_http_filters_router_stats>`.
//
// .. note::
//
//    Virtual clusters are a useful tool, but we do not recommend setting up a virtual cluster for
//    every application endpoint. This is both not easily maintainable and as well the matching and
//    statistics output are not free.
type VirtualCluster struct {
	// Specifies a regex pattern to use for matching requests. The entire path of the request
	// must match the regex. The regex grammar used is defined `here
	// <http://en.cppreference.com/w/cpp/regex/ecmascript>`_.
	//
	// Examples:
	//
	// * The regex */rides/\d+* matches the path */rides/0*
	// * The regex */rides/\d+* matches the path */rides/123*
	// * The regex */rides/\d+* does not match the path */rides/123/456*
	Pattern string `protobuf:"bytes,1,opt,name=pattern,proto3" json:"pattern,omitempty"`
	//  Specifies the name of the virtual cluster. The virtual cluster name as well
	// as the virtual host name are used when emitting statistics. The statistics are emitted by the
	// router filter and are documented :ref:`here <config_http_filters_router_stats>`.
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// Optionally specifies the HTTP method to match on. For example GET, PUT,
	// etc.
	// [#comment:TODO(htuch): add (validate.rules).enum.defined_only = true once
	// https://github.com/lyft/protoc-gen-validate/issues/42 is resolved.]
	Method RequestMethod `protobuf:"varint,3,opt,name=method,proto3,enum=envoy.api.v2.RequestMethod" json:"method,omitempty"`
}

func (m *VirtualCluster) Reset()                    { *m = VirtualCluster{} }
func (m *VirtualCluster) String() string            { return proto.CompactTextString(m) }
func (*VirtualCluster) ProtoMessage()               {}
func (*VirtualCluster) Descriptor() ([]byte, []int) { return fileDescriptorRds, []int{10} }

func (m *VirtualCluster) GetPattern() string {
	if m != nil {
		return m.Pattern
	}
	return ""
}

func (m *VirtualCluster) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *VirtualCluster) GetMethod() RequestMethod {
	if m != nil {
		return m.Method
	}
	return RequestMethod_METHOD_UNSPECIFIED
}

// Global rate limiting :ref:`architecture overview <arch_overview_rate_limit>`.
type RateLimit struct {
	// Refers to the stage set in the filter. The rate limit configuration only
	// applies to filters with the same stage number. The default stage number is
	// 0.
	//
	// .. note::
	//
	//   The filter supports a range of 0 - 10 inclusively for stage numbers.
	Stage *google_protobuf.UInt32Value `protobuf:"bytes,1,opt,name=stage" json:"stage,omitempty"`
	// The key to be set in runtime to disable this rate limit configuration.
	DisableKey string `protobuf:"bytes,2,opt,name=disable_key,json=disableKey,proto3" json:"disable_key,omitempty"`
	// A list of actions that are to be applied for this rate limit configuration.
	// Order matters as the actions are processed sequentially and the descriptor
	// is composed by appending descriptor entries in that sequence. If an action
	// cannot append a descriptor entry, no descriptor is generated for the
	// configuration. See :ref:`composing actions
	// <config_http_filters_rate_limit_composing_actions>` for additional documentation.
	Actions []*RateLimit_Action `protobuf:"bytes,3,rep,name=actions" json:"actions,omitempty"`
}

func (m *RateLimit) Reset()                    { *m = RateLimit{} }
func (m *RateLimit) String() string            { return proto.CompactTextString(m) }
func (*RateLimit) ProtoMessage()               {}
func (*RateLimit) Descriptor() ([]byte, []int) { return fileDescriptorRds, []int{11} }

func (m *RateLimit) GetStage() *google_protobuf.UInt32Value {
	if m != nil {
		return m.Stage
	}
	return nil
}

func (m *RateLimit) GetDisableKey() string {
	if m != nil {
		return m.DisableKey
	}
	return ""
}

func (m *RateLimit) GetActions() []*RateLimit_Action {
	if m != nil {
		return m.Actions
	}
	return nil
}

type RateLimit_Action struct {
	// Types that are valid to be assigned to ActionSpecifier:
	//	*RateLimit_Action_SourceCluster_
	//	*RateLimit_Action_DestinationCluster_
	//	*RateLimit_Action_RequestHeaders_
	//	*RateLimit_Action_RemoteAddress_
	//	*RateLimit_Action_GenericKey_
	//	*RateLimit_Action_HeaderValueMatch_
	ActionSpecifier isRateLimit_Action_ActionSpecifier `protobuf_oneof:"action_specifier"`
}

func (m *RateLimit_Action) Reset()                    { *m = RateLimit_Action{} }
func (m *RateLimit_Action) String() string            { return proto.CompactTextString(m) }
func (*RateLimit_Action) ProtoMessage()               {}
func (*RateLimit_Action) Descriptor() ([]byte, []int) { return fileDescriptorRds, []int{11, 0} }

type isRateLimit_Action_ActionSpecifier interface {
	isRateLimit_Action_ActionSpecifier()
	MarshalTo([]byte) (int, error)
	Size() int
}

type RateLimit_Action_SourceCluster_ struct {
	SourceCluster *RateLimit_Action_SourceCluster `protobuf:"bytes,1,opt,name=source_cluster,json=sourceCluster,oneof"`
}
type RateLimit_Action_DestinationCluster_ struct {
	DestinationCluster *RateLimit_Action_DestinationCluster `protobuf:"bytes,2,opt,name=destination_cluster,json=destinationCluster,oneof"`
}
type RateLimit_Action_RequestHeaders_ struct {
	RequestHeaders *RateLimit_Action_RequestHeaders `protobuf:"bytes,3,opt,name=request_headers,json=requestHeaders,oneof"`
}
type RateLimit_Action_RemoteAddress_ struct {
	RemoteAddress *RateLimit_Action_RemoteAddress `protobuf:"bytes,4,opt,name=remote_address,json=remoteAddress,oneof"`
}
type RateLimit_Action_GenericKey_ struct {
	GenericKey *RateLimit_Action_GenericKey `protobuf:"bytes,5,opt,name=generic_key,json=genericKey,oneof"`
}
type RateLimit_Action_HeaderValueMatch_ struct {
	HeaderValueMatch *RateLimit_Action_HeaderValueMatch `protobuf:"bytes,6,opt,name=header_value_match,json=headerValueMatch,oneof"`
}

func (*RateLimit_Action_SourceCluster_) isRateLimit_Action_ActionSpecifier()      {}
func (*RateLimit_Action_DestinationCluster_) isRateLimit_Action_ActionSpecifier() {}
func (*RateLimit_Action_RequestHeaders_) isRateLimit_Action_ActionSpecifier()     {}
func (*RateLimit_Action_RemoteAddress_) isRateLimit_Action_ActionSpecifier()      {}
func (*RateLimit_Action_GenericKey_) isRateLimit_Action_ActionSpecifier()         {}
func (*RateLimit_Action_HeaderValueMatch_) isRateLimit_Action_ActionSpecifier()   {}

func (m *RateLimit_Action) GetActionSpecifier() isRateLimit_Action_ActionSpecifier {
	if m != nil {
		return m.ActionSpecifier
	}
	return nil
}

func (m *RateLimit_Action) GetSourceCluster() *RateLimit_Action_SourceCluster {
	if x, ok := m.GetActionSpecifier().(*RateLimit_Action_SourceCluster_); ok {
		return x.SourceCluster
	}
	return nil
}

func (m *RateLimit_Action) GetDestinationCluster() *RateLimit_Action_DestinationCluster {
	if x, ok := m.GetActionSpecifier().(*RateLimit_Action_DestinationCluster_); ok {
		return x.DestinationCluster
	}
	return nil
}

func (m *RateLimit_Action) GetRequestHeaders() *RateLimit_Action_RequestHeaders {
	if x, ok := m.GetActionSpecifier().(*RateLimit_Action_RequestHeaders_); ok {
		return x.RequestHeaders
	}
	return nil
}

func (m *RateLimit_Action) GetRemoteAddress() *RateLimit_Action_RemoteAddress {
	if x, ok := m.GetActionSpecifier().(*RateLimit_Action_RemoteAddress_); ok {
		return x.RemoteAddress
	}
	return nil
}

func (m *RateLimit_Action) GetGenericKey() *RateLimit_Action_GenericKey {
	if x, ok := m.GetActionSpecifier().(*RateLimit_Action_GenericKey_); ok {
		return x.GenericKey
	}
	return nil
}

func (m *RateLimit_Action) GetHeaderValueMatch() *RateLimit_Action_HeaderValueMatch {
	if x, ok := m.GetActionSpecifier().(*RateLimit_Action_HeaderValueMatch_); ok {
		return x.HeaderValueMatch
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*RateLimit_Action) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _RateLimit_Action_OneofMarshaler, _RateLimit_Action_OneofUnmarshaler, _RateLimit_Action_OneofSizer, []interface{}{
		(*RateLimit_Action_SourceCluster_)(nil),
		(*RateLimit_Action_DestinationCluster_)(nil),
		(*RateLimit_Action_RequestHeaders_)(nil),
		(*RateLimit_Action_RemoteAddress_)(nil),
		(*RateLimit_Action_GenericKey_)(nil),
		(*RateLimit_Action_HeaderValueMatch_)(nil),
	}
}

func _RateLimit_Action_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*RateLimit_Action)
	// action_specifier
	switch x := m.ActionSpecifier.(type) {
	case *RateLimit_Action_SourceCluster_:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SourceCluster); err != nil {
			return err
		}
	case *RateLimit_Action_DestinationCluster_:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DestinationCluster); err != nil {
			return err
		}
	case *RateLimit_Action_RequestHeaders_:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.RequestHeaders); err != nil {
			return err
		}
	case *RateLimit_Action_RemoteAddress_:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.RemoteAddress); err != nil {
			return err
		}
	case *RateLimit_Action_GenericKey_:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.GenericKey); err != nil {
			return err
		}
	case *RateLimit_Action_HeaderValueMatch_:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.HeaderValueMatch); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("RateLimit_Action.ActionSpecifier has unexpected type %T", x)
	}
	return nil
}

func _RateLimit_Action_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*RateLimit_Action)
	switch tag {
	case 1: // action_specifier.source_cluster
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RateLimit_Action_SourceCluster)
		err := b.DecodeMessage(msg)
		m.ActionSpecifier = &RateLimit_Action_SourceCluster_{msg}
		return true, err
	case 2: // action_specifier.destination_cluster
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RateLimit_Action_DestinationCluster)
		err := b.DecodeMessage(msg)
		m.ActionSpecifier = &RateLimit_Action_DestinationCluster_{msg}
		return true, err
	case 3: // action_specifier.request_headers
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RateLimit_Action_RequestHeaders)
		err := b.DecodeMessage(msg)
		m.ActionSpecifier = &RateLimit_Action_RequestHeaders_{msg}
		return true, err
	case 4: // action_specifier.remote_address
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RateLimit_Action_RemoteAddress)
		err := b.DecodeMessage(msg)
		m.ActionSpecifier = &RateLimit_Action_RemoteAddress_{msg}
		return true, err
	case 5: // action_specifier.generic_key
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RateLimit_Action_GenericKey)
		err := b.DecodeMessage(msg)
		m.ActionSpecifier = &RateLimit_Action_GenericKey_{msg}
		return true, err
	case 6: // action_specifier.header_value_match
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RateLimit_Action_HeaderValueMatch)
		err := b.DecodeMessage(msg)
		m.ActionSpecifier = &RateLimit_Action_HeaderValueMatch_{msg}
		return true, err
	default:
		return false, nil
	}
}

func _RateLimit_Action_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*RateLimit_Action)
	// action_specifier
	switch x := m.ActionSpecifier.(type) {
	case *RateLimit_Action_SourceCluster_:
		s := proto.Size(x.SourceCluster)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RateLimit_Action_DestinationCluster_:
		s := proto.Size(x.DestinationCluster)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RateLimit_Action_RequestHeaders_:
		s := proto.Size(x.RequestHeaders)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RateLimit_Action_RemoteAddress_:
		s := proto.Size(x.RemoteAddress)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RateLimit_Action_GenericKey_:
		s := proto.Size(x.GenericKey)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RateLimit_Action_HeaderValueMatch_:
		s := proto.Size(x.HeaderValueMatch)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// The following descriptor entry is appended to the descriptor:
//
// .. code-block:: cpp
//
//   ("source_cluster", "<local service cluster>")
//
// <local service cluster> is derived from the :option:`--service-cluster` option.
type RateLimit_Action_SourceCluster struct {
}

func (m *RateLimit_Action_SourceCluster) Reset()         { *m = RateLimit_Action_SourceCluster{} }
func (m *RateLimit_Action_SourceCluster) String() string { return proto.CompactTextString(m) }
func (*RateLimit_Action_SourceCluster) ProtoMessage()    {}
func (*RateLimit_Action_SourceCluster) Descriptor() ([]byte, []int) {
	return fileDescriptorRds, []int{11, 0, 0}
}

// The following descriptor entry is appended to the descriptor:
//
// .. code-block:: cpp
//
//   ("destination_cluster", "<routed target cluster>")
//
// Once a request matches against a route table rule, a routed cluster is determined by one of
// the following :ref:`route table configuration <envoy_api_msg_RouteConfiguration>`
// settings:
//
// * :ref:`cluster <envoy_api_field_RouteAction.cluster>` indicates the upstream cluster
//   to route to.
// * :ref:`weighted_clusters <envoy_api_field_RouteAction.weighted_clusters>`
//   chooses a cluster randomly from a set of clusters with attributed weight.
// * :ref:`cluster_header <envoy_api_field_RouteAction.cluster_header>` indicates which
//   header in the request contains the target cluster.
type RateLimit_Action_DestinationCluster struct {
}

func (m *RateLimit_Action_DestinationCluster) Reset()         { *m = RateLimit_Action_DestinationCluster{} }
func (m *RateLimit_Action_DestinationCluster) String() string { return proto.CompactTextString(m) }
func (*RateLimit_Action_DestinationCluster) ProtoMessage()    {}
func (*RateLimit_Action_DestinationCluster) Descriptor() ([]byte, []int) {
	return fileDescriptorRds, []int{11, 0, 1}
}

// The following descriptor entry is appended when a header contains a key that matches the
// *header_name*:
//
// .. code-block:: cpp
//
//   ("<descriptor_key>", "<header_value_queried_from_header>")
type RateLimit_Action_RequestHeaders struct {
	// The header name to be queried from the request headers. The header’s
	// value is used to populate the value of the descriptor entry for the
	// descriptor_key.
	HeaderName string `protobuf:"bytes,1,opt,name=header_name,json=headerName,proto3" json:"header_name,omitempty"`
	// The key to use in the descriptor entry.
	DescriptorKey string `protobuf:"bytes,2,opt,name=descriptor_key,json=descriptorKey,proto3" json:"descriptor_key,omitempty"`
}

func (m *RateLimit_Action_RequestHeaders) Reset()         { *m = RateLimit_Action_RequestHeaders{} }
func (m *RateLimit_Action_RequestHeaders) String() string { return proto.CompactTextString(m) }
func (*RateLimit_Action_RequestHeaders) ProtoMessage()    {}
func (*RateLimit_Action_RequestHeaders) Descriptor() ([]byte, []int) {
	return fileDescriptorRds, []int{11, 0, 2}
}

func (m *RateLimit_Action_RequestHeaders) GetHeaderName() string {
	if m != nil {
		return m.HeaderName
	}
	return ""
}

func (m *RateLimit_Action_RequestHeaders) GetDescriptorKey() string {
	if m != nil {
		return m.DescriptorKey
	}
	return ""
}

// The following descriptor entry is appended to the descriptor and is populated using the
// trusted address from :ref:`x-forwarded-for <config_http_conn_man_headers_x-forwarded-for>`:
//
// .. code-block:: cpp
//
//   ("remote_address", "<trusted address from x-forwarded-for>")
type RateLimit_Action_RemoteAddress struct {
}

func (m *RateLimit_Action_RemoteAddress) Reset()         { *m = RateLimit_Action_RemoteAddress{} }
func (m *RateLimit_Action_RemoteAddress) String() string { return proto.CompactTextString(m) }
func (*RateLimit_Action_RemoteAddress) ProtoMessage()    {}
func (*RateLimit_Action_RemoteAddress) Descriptor() ([]byte, []int) {
	return fileDescriptorRds, []int{11, 0, 3}
}

// The following descriptor entry is appended to the descriptor:
//
// .. code-block:: cpp
//
//   ("generic_key", "<descriptor_value>")
type RateLimit_Action_GenericKey struct {
	// The value to use in the descriptor entry.
	DescriptorValue string `protobuf:"bytes,1,opt,name=descriptor_value,json=descriptorValue,proto3" json:"descriptor_value,omitempty"`
}

func (m *RateLimit_Action_GenericKey) Reset()         { *m = RateLimit_Action_GenericKey{} }
func (m *RateLimit_Action_GenericKey) String() string { return proto.CompactTextString(m) }
func (*RateLimit_Action_GenericKey) ProtoMessage()    {}
func (*RateLimit_Action_GenericKey) Descriptor() ([]byte, []int) {
	return fileDescriptorRds, []int{11, 0, 4}
}

func (m *RateLimit_Action_GenericKey) GetDescriptorValue() string {
	if m != nil {
		return m.DescriptorValue
	}
	return ""
}

// The following descriptor entry is appended to the descriptor:
//
// .. code-block:: cpp
//
//   ("header_match", "<descriptor_value>")
type RateLimit_Action_HeaderValueMatch struct {
	// The value to use in the descriptor entry.
	DescriptorValue string `protobuf:"bytes,1,opt,name=descriptor_value,json=descriptorValue,proto3" json:"descriptor_value,omitempty"`
	// If set to true, the action will append a descriptor entry when the
	// request matches the headers. If set to false, the action will append a
	// descriptor entry when the request does not match the headers. The
	// default value is true.
	ExpectMatch *google_protobuf.BoolValue `protobuf:"bytes,2,opt,name=expect_match,json=expectMatch" json:"expect_match,omitempty"`
	// Specifies a set of headers that the rate limit action should match
	// on. The action will check the request’s headers against all the
	// specified headers in the config. A match will happen if all the
	// headers in the config are present in the request with the same values
	// (or based on presence if the value field is not in the config).
	Headers []*HeaderMatcher `protobuf:"bytes,3,rep,name=headers" json:"headers,omitempty"`
}

func (m *RateLimit_Action_HeaderValueMatch) Reset()         { *m = RateLimit_Action_HeaderValueMatch{} }
func (m *RateLimit_Action_HeaderValueMatch) String() string { return proto.CompactTextString(m) }
func (*RateLimit_Action_HeaderValueMatch) ProtoMessage()    {}
func (*RateLimit_Action_HeaderValueMatch) Descriptor() ([]byte, []int) {
	return fileDescriptorRds, []int{11, 0, 5}
}

func (m *RateLimit_Action_HeaderValueMatch) GetDescriptorValue() string {
	if m != nil {
		return m.DescriptorValue
	}
	return ""
}

func (m *RateLimit_Action_HeaderValueMatch) GetExpectMatch() *google_protobuf.BoolValue {
	if m != nil {
		return m.ExpectMatch
	}
	return nil
}

func (m *RateLimit_Action_HeaderValueMatch) GetHeaders() []*HeaderMatcher {
	if m != nil {
		return m.Headers
	}
	return nil
}

// .. attention::
//
//   Internally, Envoy always uses the HTTP/2 *:authority* header to represent the HTTP/1 *Host*
//   header. Thus, if attempting to match on *Host*, match on *:authority* instead.
//
// .. attention::
//
//   To route on HTTP method, use the special HTTP/2 *:method* header. This works for both
//   HTTP/1 and HTTP/2 as Envoy normalizes headers. E.g.,
//
//   .. code-block:: json
//
//     {
//       "name": ":method",
//       "value": "POST"
//     }
type HeaderMatcher struct {
	// Specifies the name of the header in the request.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Specifies the value of the header. If the value is absent a request that
	// has the name header will match, regardless of the header’s value.
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	// Specifies whether the header value is a regular
	// expression or not. Defaults to false. The entire request header value must match the regex. The
	// rule will not match if only a subsequence of the request header value matches the regex. The
	// regex grammar used in the value field is defined
	// `here <http://en.cppreference.com/w/cpp/regex/ecmascript>`_.
	//
	// Examples:
	//
	// * The regex *\d{3}* matches the value *123*
	// * The regex *\d{3}* does not match the value *1234*
	// * The regex *\d{3}* does not match the value *123.456*
	Regex *google_protobuf.BoolValue `protobuf:"bytes,3,opt,name=regex" json:"regex,omitempty"`
}

func (m *HeaderMatcher) Reset()                    { *m = HeaderMatcher{} }
func (m *HeaderMatcher) String() string            { return proto.CompactTextString(m) }
func (*HeaderMatcher) ProtoMessage()               {}
func (*HeaderMatcher) Descriptor() ([]byte, []int) { return fileDescriptorRds, []int{12} }

func (m *HeaderMatcher) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *HeaderMatcher) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *HeaderMatcher) GetRegex() *google_protobuf.BoolValue {
	if m != nil {
		return m.Regex
	}
	return nil
}

// Query parameter matching treats the query string of a request's :path header
// as an ampersand-separated list of keys and/or key=value elements.
type QueryParameterMatcher struct {
	// Specifies the name of a key that must be present in the requested
	// *path*'s query string.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Specifies the value of the key. If the value is absent, a request
	// that contains the key in its query string will match, whether the
	// key appears with a value (e.g., "?debug=true") or not (e.g., "?debug")
	Value string `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
	// Specifies whether the query parameter value is a regular expression.
	// Defaults to false. The entire query parameter value (i.e., the part to
	// the right of the equals sign in "key=value") must match the regex.
	// E.g., the regex "\d+$" will match "123" but not "a123" or "123a".
	Regex *google_protobuf.BoolValue `protobuf:"bytes,4,opt,name=regex" json:"regex,omitempty"`
}

func (m *QueryParameterMatcher) Reset()                    { *m = QueryParameterMatcher{} }
func (m *QueryParameterMatcher) String() string            { return proto.CompactTextString(m) }
func (*QueryParameterMatcher) ProtoMessage()               {}
func (*QueryParameterMatcher) Descriptor() ([]byte, []int) { return fileDescriptorRds, []int{13} }

func (m *QueryParameterMatcher) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *QueryParameterMatcher) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *QueryParameterMatcher) GetRegex() *google_protobuf.BoolValue {
	if m != nil {
		return m.Regex
	}
	return nil
}

func init() {
	proto.RegisterType((*RouteConfiguration)(nil), "envoy.api.v2.RouteConfiguration")
	proto.RegisterType((*VirtualHost)(nil), "envoy.api.v2.VirtualHost")
	proto.RegisterType((*Route)(nil), "envoy.api.v2.Route")
	proto.RegisterType((*WeightedCluster)(nil), "envoy.api.v2.WeightedCluster")
	proto.RegisterType((*WeightedCluster_ClusterWeight)(nil), "envoy.api.v2.WeightedCluster.ClusterWeight")
	proto.RegisterType((*RouteMatch)(nil), "envoy.api.v2.RouteMatch")
	proto.RegisterType((*CorsPolicy)(nil), "envoy.api.v2.CorsPolicy")
	proto.RegisterType((*RouteAction)(nil), "envoy.api.v2.RouteAction")
	proto.RegisterType((*RouteAction_RetryPolicy)(nil), "envoy.api.v2.RouteAction.RetryPolicy")
	proto.RegisterType((*RouteAction_RequestMirrorPolicy)(nil), "envoy.api.v2.RouteAction.RequestMirrorPolicy")
	proto.RegisterType((*RouteAction_HashPolicy)(nil), "envoy.api.v2.RouteAction.HashPolicy")
	proto.RegisterType((*RouteAction_HashPolicy_Header)(nil), "envoy.api.v2.RouteAction.HashPolicy.Header")
	proto.RegisterType((*RouteAction_HashPolicy_Cookie)(nil), "envoy.api.v2.RouteAction.HashPolicy.Cookie")
	proto.RegisterType((*RouteAction_HashPolicy_ConnectionProperties)(nil), "envoy.api.v2.RouteAction.HashPolicy.ConnectionProperties")
	proto.RegisterType((*RedirectAction)(nil), "envoy.api.v2.RedirectAction")
	proto.RegisterType((*DirectResponseAction)(nil), "envoy.api.v2.DirectResponseAction")
	proto.RegisterType((*Decorator)(nil), "envoy.api.v2.Decorator")
	proto.RegisterType((*VirtualCluster)(nil), "envoy.api.v2.VirtualCluster")
	proto.RegisterType((*RateLimit)(nil), "envoy.api.v2.RateLimit")
	proto.RegisterType((*RateLimit_Action)(nil), "envoy.api.v2.RateLimit.Action")
	proto.RegisterType((*RateLimit_Action_SourceCluster)(nil), "envoy.api.v2.RateLimit.Action.SourceCluster")
	proto.RegisterType((*RateLimit_Action_DestinationCluster)(nil), "envoy.api.v2.RateLimit.Action.DestinationCluster")
	proto.RegisterType((*RateLimit_Action_RequestHeaders)(nil), "envoy.api.v2.RateLimit.Action.RequestHeaders")
	proto.RegisterType((*RateLimit_Action_RemoteAddress)(nil), "envoy.api.v2.RateLimit.Action.RemoteAddress")
	proto.RegisterType((*RateLimit_Action_GenericKey)(nil), "envoy.api.v2.RateLimit.Action.GenericKey")
	proto.RegisterType((*RateLimit_Action_HeaderValueMatch)(nil), "envoy.api.v2.RateLimit.Action.HeaderValueMatch")
	proto.RegisterType((*HeaderMatcher)(nil), "envoy.api.v2.HeaderMatcher")
	proto.RegisterType((*QueryParameterMatcher)(nil), "envoy.api.v2.QueryParameterMatcher")
	proto.RegisterEnum("envoy.api.v2.VirtualHost_TlsRequirementType", VirtualHost_TlsRequirementType_name, VirtualHost_TlsRequirementType_value)
	proto.RegisterEnum("envoy.api.v2.RouteAction_ClusterNotFoundResponseCode", RouteAction_ClusterNotFoundResponseCode_name, RouteAction_ClusterNotFoundResponseCode_value)
	proto.RegisterEnum("envoy.api.v2.RedirectAction_RedirectResponseCode", RedirectAction_RedirectResponseCode_name, RedirectAction_RedirectResponseCode_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for RouteDiscoveryService service

type RouteDiscoveryServiceClient interface {
	StreamRoutes(ctx context.Context, opts ...grpc.CallOption) (RouteDiscoveryService_StreamRoutesClient, error)
	FetchRoutes(ctx context.Context, in *DiscoveryRequest, opts ...grpc.CallOption) (*DiscoveryResponse, error)
}

type routeDiscoveryServiceClient struct {
	cc *grpc.ClientConn
}

func NewRouteDiscoveryServiceClient(cc *grpc.ClientConn) RouteDiscoveryServiceClient {
	return &routeDiscoveryServiceClient{cc}
}

func (c *routeDiscoveryServiceClient) StreamRoutes(ctx context.Context, opts ...grpc.CallOption) (RouteDiscoveryService_StreamRoutesClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_RouteDiscoveryService_serviceDesc.Streams[0], c.cc, "/envoy.api.v2.RouteDiscoveryService/StreamRoutes", opts...)
	if err != nil {
		return nil, err
	}
	x := &routeDiscoveryServiceStreamRoutesClient{stream}
	return x, nil
}

type RouteDiscoveryService_StreamRoutesClient interface {
	Send(*DiscoveryRequest) error
	Recv() (*DiscoveryResponse, error)
	grpc.ClientStream
}

type routeDiscoveryServiceStreamRoutesClient struct {
	grpc.ClientStream
}

func (x *routeDiscoveryServiceStreamRoutesClient) Send(m *DiscoveryRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *routeDiscoveryServiceStreamRoutesClient) Recv() (*DiscoveryResponse, error) {
	m := new(DiscoveryResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *routeDiscoveryServiceClient) FetchRoutes(ctx context.Context, in *DiscoveryRequest, opts ...grpc.CallOption) (*DiscoveryResponse, error) {
	out := new(DiscoveryResponse)
	err := grpc.Invoke(ctx, "/envoy.api.v2.RouteDiscoveryService/FetchRoutes", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for RouteDiscoveryService service

type RouteDiscoveryServiceServer interface {
	StreamRoutes(RouteDiscoveryService_StreamRoutesServer) error
	FetchRoutes(context.Context, *DiscoveryRequest) (*DiscoveryResponse, error)
}

func RegisterRouteDiscoveryServiceServer(s *grpc.Server, srv RouteDiscoveryServiceServer) {
	s.RegisterService(&_RouteDiscoveryService_serviceDesc, srv)
}

func _RouteDiscoveryService_StreamRoutes_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(RouteDiscoveryServiceServer).StreamRoutes(&routeDiscoveryServiceStreamRoutesServer{stream})
}

type RouteDiscoveryService_StreamRoutesServer interface {
	Send(*DiscoveryResponse) error
	Recv() (*DiscoveryRequest, error)
	grpc.ServerStream
}

type routeDiscoveryServiceStreamRoutesServer struct {
	grpc.ServerStream
}

func (x *routeDiscoveryServiceStreamRoutesServer) Send(m *DiscoveryResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *routeDiscoveryServiceStreamRoutesServer) Recv() (*DiscoveryRequest, error) {
	m := new(DiscoveryRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _RouteDiscoveryService_FetchRoutes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DiscoveryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouteDiscoveryServiceServer).FetchRoutes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/envoy.api.v2.RouteDiscoveryService/FetchRoutes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouteDiscoveryServiceServer).FetchRoutes(ctx, req.(*DiscoveryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _RouteDiscoveryService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "envoy.api.v2.RouteDiscoveryService",
	HandlerType: (*RouteDiscoveryServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "FetchRoutes",
			Handler:    _RouteDiscoveryService_FetchRoutes_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamRoutes",
			Handler:       _RouteDiscoveryService_StreamRoutes_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "api/rds.proto",
}

func (m *RouteConfiguration) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteConfiguration) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRds(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.VirtualHosts) > 0 {
		for _, msg := range m.VirtualHosts {
			dAtA[i] = 0x12
			i++
			i = encodeVarintRds(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.InternalOnlyHeaders) > 0 {
		for _, s := range m.InternalOnlyHeaders {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.ResponseHeadersToAdd) > 0 {
		for _, msg := range m.ResponseHeadersToAdd {
			dAtA[i] = 0x22
			i++
			i = encodeVarintRds(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ResponseHeadersToRemove) > 0 {
		for _, s := range m.ResponseHeadersToRemove {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.RequestHeadersToAdd) > 0 {
		for _, msg := range m.RequestHeadersToAdd {
			dAtA[i] = 0x32
			i++
			i = encodeVarintRds(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.ValidateClusters != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintRds(dAtA, i, uint64(m.ValidateClusters.Size()))
		n1, err := m.ValidateClusters.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *VirtualHost) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VirtualHost) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRds(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Domains) > 0 {
		for _, s := range m.Domains {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Routes) > 0 {
		for _, msg := range m.Routes {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintRds(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.RequireTls != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintRds(dAtA, i, uint64(m.RequireTls))
	}
	if len(m.VirtualClusters) > 0 {
		for _, msg := range m.VirtualClusters {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintRds(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.RateLimits) > 0 {
		for _, msg := range m.RateLimits {
			dAtA[i] = 0x32
			i++
			i = encodeVarintRds(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.RequestHeadersToAdd) > 0 {
		for _, msg := range m.RequestHeadersToAdd {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintRds(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Cors != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintRds(dAtA, i, uint64(m.Cors.Size()))
		n2, err := m.Cors.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.Auth != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintRds(dAtA, i, uint64(m.Auth.Size()))
		n3, err := m.Auth.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if len(m.ResponseHeadersToAdd) > 0 {
		for _, msg := range m.ResponseHeadersToAdd {
			dAtA[i] = 0x52
			i++
			i = encodeVarintRds(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ResponseHeadersToRemove) > 0 {
		for _, s := range m.ResponseHeadersToRemove {
			dAtA[i] = 0x5a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *Route) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Route) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Match != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRds(dAtA, i, uint64(m.Match.Size()))
		n4, err := m.Match.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.Action != nil {
		nn5, err := m.Action.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn5
	}
	if m.Metadata != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRds(dAtA, i, uint64(m.Metadata.Size()))
		n6, err := m.Metadata.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.Decorator != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintRds(dAtA, i, uint64(m.Decorator.Size()))
		n7, err := m.Decorator.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.Auth != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintRds(dAtA, i, uint64(m.Auth.Size()))
		n8, err := m.Auth.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}

func (m *Route_Route) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Route != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRds(dAtA, i, uint64(m.Route.Size()))
		n9, err := m.Route.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}
func (m *Route_Redirect) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Redirect != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRds(dAtA, i, uint64(m.Redirect.Size()))
		n10, err := m.Redirect.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}
func (m *Route_DirectResponse) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DirectResponse != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintRds(dAtA, i, uint64(m.DirectResponse.Size()))
		n11, err := m.DirectResponse.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}
func (m *WeightedCluster) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WeightedCluster) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Clusters) > 0 {
		for _, msg := range m.Clusters {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRds(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.RuntimeKeyPrefix) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRds(dAtA, i, uint64(len(m.RuntimeKeyPrefix)))
		i += copy(dAtA[i:], m.RuntimeKeyPrefix)
	}
	return i, nil
}

func (m *WeightedCluster_ClusterWeight) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WeightedCluster_ClusterWeight) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRds(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Weight != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRds(dAtA, i, uint64(m.Weight.Size()))
		n12, err := m.Weight.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.MetadataMatch != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRds(dAtA, i, uint64(m.MetadataMatch.Size()))
		n13, err := m.MetadataMatch.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}

func (m *RouteMatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteMatch) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PathSpecifier != nil {
		nn14, err := m.PathSpecifier.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn14
	}
	if m.CaseSensitive != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRds(dAtA, i, uint64(m.CaseSensitive.Size()))
		n15, err := m.CaseSensitive.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.Runtime != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintRds(dAtA, i, uint64(m.Runtime.Size()))
		n16, err := m.Runtime.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if len(m.Headers) > 0 {
		for _, msg := range m.Headers {
			dAtA[i] = 0x32
			i++
			i = encodeVarintRds(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.QueryParameters) > 0 {
		for _, msg := range m.QueryParameters {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintRds(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RouteMatch_Prefix) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0xa
	i++
	i = encodeVarintRds(dAtA, i, uint64(len(m.Prefix)))
	i += copy(dAtA[i:], m.Prefix)
	return i, nil
}
func (m *RouteMatch_Path) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x12
	i++
	i = encodeVarintRds(dAtA, i, uint64(len(m.Path)))
	i += copy(dAtA[i:], m.Path)
	return i, nil
}
func (m *RouteMatch_Regex) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x1a
	i++
	i = encodeVarintRds(dAtA, i, uint64(len(m.Regex)))
	i += copy(dAtA[i:], m.Regex)
	return i, nil
}
func (m *CorsPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CorsPolicy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AllowOrigin) > 0 {
		for _, s := range m.AllowOrigin {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.AllowMethods) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRds(dAtA, i, uint64(len(m.AllowMethods)))
		i += copy(dAtA[i:], m.AllowMethods)
	}
	if len(m.AllowHeaders) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRds(dAtA, i, uint64(len(m.AllowHeaders)))
		i += copy(dAtA[i:], m.AllowHeaders)
	}
	if len(m.ExposeHeaders) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRds(dAtA, i, uint64(len(m.ExposeHeaders)))
		i += copy(dAtA[i:], m.ExposeHeaders)
	}
	if len(m.MaxAge) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintRds(dAtA, i, uint64(len(m.MaxAge)))
		i += copy(dAtA[i:], m.MaxAge)
	}
	if m.AllowCredentials != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintRds(dAtA, i, uint64(m.AllowCredentials.Size()))
		n17, err := m.AllowCredentials.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if m.Enabled != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintRds(dAtA, i, uint64(m.Enabled.Size()))
		n18, err := m.Enabled.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	return i, nil
}

func (m *RouteAction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteAction) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ClusterSpecifier != nil {
		nn19, err := m.ClusterSpecifier.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn19
	}
	if m.MetadataMatch != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRds(dAtA, i, uint64(m.MetadataMatch.Size()))
		n20, err := m.MetadataMatch.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if len(m.PrefixRewrite) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintRds(dAtA, i, uint64(len(m.PrefixRewrite)))
		i += copy(dAtA[i:], m.PrefixRewrite)
	}
	if m.HostRewriteSpecifier != nil {
		nn21, err := m.HostRewriteSpecifier.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn21
	}
	if m.Timeout != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintRds(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdDuration(*m.Timeout)))
		n22, err := github_com_gogo_protobuf_types.StdDurationMarshalTo(*m.Timeout, dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	if m.RetryPolicy != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintRds(dAtA, i, uint64(m.RetryPolicy.Size()))
		n23, err := m.RetryPolicy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	if m.RequestMirrorPolicy != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintRds(dAtA, i, uint64(m.RequestMirrorPolicy.Size()))
		n24, err := m.RequestMirrorPolicy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	if m.Priority != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintRds(dAtA, i, uint64(m.Priority))
	}
	if len(m.RequestHeadersToAdd) > 0 {
		for _, msg := range m.RequestHeadersToAdd {
			dAtA[i] = 0x62
			i++
			i = encodeVarintRds(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.RateLimits) > 0 {
		for _, msg := range m.RateLimits {
			dAtA[i] = 0x6a
			i++
			i = encodeVarintRds(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.IncludeVhRateLimits != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintRds(dAtA, i, uint64(m.IncludeVhRateLimits.Size()))
		n25, err := m.IncludeVhRateLimits.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	if len(m.HashPolicy) > 0 {
		for _, msg := range m.HashPolicy {
			dAtA[i] = 0x7a
			i++
			i = encodeVarintRds(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.UseWebsocket != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintRds(dAtA, i, uint64(m.UseWebsocket.Size()))
		n26, err := m.UseWebsocket.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	if m.Cors != nil {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintRds(dAtA, i, uint64(m.Cors.Size()))
		n27, err := m.Cors.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	if len(m.ResponseHeadersToAdd) > 0 {
		for _, msg := range m.ResponseHeadersToAdd {
			dAtA[i] = 0x92
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintRds(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ResponseHeadersToRemove) > 0 {
		for _, s := range m.ResponseHeadersToRemove {
			dAtA[i] = 0x9a
			i++
			dAtA[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.ClusterNotFoundResponseCode != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintRds(dAtA, i, uint64(m.ClusterNotFoundResponseCode))
	}
	return i, nil
}

func (m *RouteAction_Cluster) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0xa
	i++
	i = encodeVarintRds(dAtA, i, uint64(len(m.Cluster)))
	i += copy(dAtA[i:], m.Cluster)
	return i, nil
}
func (m *RouteAction_ClusterHeader) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x12
	i++
	i = encodeVarintRds(dAtA, i, uint64(len(m.ClusterHeader)))
	i += copy(dAtA[i:], m.ClusterHeader)
	return i, nil
}
func (m *RouteAction_WeightedClusters) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.WeightedClusters != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRds(dAtA, i, uint64(m.WeightedClusters.Size()))
		n28, err := m.WeightedClusters.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	return i, nil
}
func (m *RouteAction_HostRewrite) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x32
	i++
	i = encodeVarintRds(dAtA, i, uint64(len(m.HostRewrite)))
	i += copy(dAtA[i:], m.HostRewrite)
	return i, nil
}
func (m *RouteAction_AutoHostRewrite) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.AutoHostRewrite != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintRds(dAtA, i, uint64(m.AutoHostRewrite.Size()))
		n29, err := m.AutoHostRewrite.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	return i, nil
}
func (m *RouteAction_RetryPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteAction_RetryPolicy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RetryOn) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRds(dAtA, i, uint64(len(m.RetryOn)))
		i += copy(dAtA[i:], m.RetryOn)
	}
	if m.NumRetries != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRds(dAtA, i, uint64(m.NumRetries.Size()))
		n30, err := m.NumRetries.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	if m.PerTryTimeout != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRds(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdDuration(*m.PerTryTimeout)))
		n31, err := github_com_gogo_protobuf_types.StdDurationMarshalTo(*m.PerTryTimeout, dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	return i, nil
}

func (m *RouteAction_RequestMirrorPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteAction_RequestMirrorPolicy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Cluster) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRds(dAtA, i, uint64(len(m.Cluster)))
		i += copy(dAtA[i:], m.Cluster)
	}
	if len(m.RuntimeKey) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRds(dAtA, i, uint64(len(m.RuntimeKey)))
		i += copy(dAtA[i:], m.RuntimeKey)
	}
	return i, nil
}

func (m *RouteAction_HashPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteAction_HashPolicy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PolicySpecifier != nil {
		nn32, err := m.PolicySpecifier.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn32
	}
	return i, nil
}

func (m *RouteAction_HashPolicy_Header_) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Header != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRds(dAtA, i, uint64(m.Header.Size()))
		n33, err := m.Header.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	return i, nil
}
func (m *RouteAction_HashPolicy_Cookie_) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Cookie != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRds(dAtA, i, uint64(m.Cookie.Size()))
		n34, err := m.Cookie.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n34
	}
	return i, nil
}
func (m *RouteAction_HashPolicy_ConnectionProperties_) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ConnectionProperties != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRds(dAtA, i, uint64(m.ConnectionProperties.Size()))
		n35, err := m.ConnectionProperties.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n35
	}
	return i, nil
}
func (m *RouteAction_HashPolicy_Header) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteAction_HashPolicy_Header) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.HeaderName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRds(dAtA, i, uint64(len(m.HeaderName)))
		i += copy(dAtA[i:], m.HeaderName)
	}
	return i, nil
}

func (m *RouteAction_HashPolicy_Cookie) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteAction_HashPolicy_Cookie) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRds(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Ttl != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRds(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdDuration(*m.Ttl)))
		n36, err := github_com_gogo_protobuf_types.StdDurationMarshalTo(*m.Ttl, dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n36
	}
	return i, nil
}

func (m *RouteAction_HashPolicy_ConnectionProperties) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteAction_HashPolicy_ConnectionProperties) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SourceIp {
		dAtA[i] = 0x8
		i++
		if m.SourceIp {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *RedirectAction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RedirectAction) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.HostRedirect) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRds(dAtA, i, uint64(len(m.HostRedirect)))
		i += copy(dAtA[i:], m.HostRedirect)
	}
	if len(m.PathRedirect) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRds(dAtA, i, uint64(len(m.PathRedirect)))
		i += copy(dAtA[i:], m.PathRedirect)
	}
	if m.ResponseCode != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRds(dAtA, i, uint64(m.ResponseCode))
	}
	return i, nil
}

func (m *DirectResponseAction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DirectResponseAction) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRds(dAtA, i, uint64(m.Status))
	}
	if m.Body != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRds(dAtA, i, uint64(m.Body.Size()))
		n37, err := m.Body.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n37
	}
	return i, nil
}

func (m *Decorator) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Decorator) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Operation) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRds(dAtA, i, uint64(len(m.Operation)))
		i += copy(dAtA[i:], m.Operation)
	}
	return i, nil
}

func (m *VirtualCluster) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VirtualCluster) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Pattern) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRds(dAtA, i, uint64(len(m.Pattern)))
		i += copy(dAtA[i:], m.Pattern)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRds(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Method != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRds(dAtA, i, uint64(m.Method))
	}
	return i, nil
}

func (m *RateLimit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RateLimit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Stage != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRds(dAtA, i, uint64(m.Stage.Size()))
		n38, err := m.Stage.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n38
	}
	if len(m.DisableKey) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRds(dAtA, i, uint64(len(m.DisableKey)))
		i += copy(dAtA[i:], m.DisableKey)
	}
	if len(m.Actions) > 0 {
		for _, msg := range m.Actions {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintRds(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RateLimit_Action) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RateLimit_Action) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ActionSpecifier != nil {
		nn39, err := m.ActionSpecifier.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn39
	}
	return i, nil
}

func (m *RateLimit_Action_SourceCluster_) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.SourceCluster != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRds(dAtA, i, uint64(m.SourceCluster.Size()))
		n40, err := m.SourceCluster.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n40
	}
	return i, nil
}
func (m *RateLimit_Action_DestinationCluster_) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DestinationCluster != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRds(dAtA, i, uint64(m.DestinationCluster.Size()))
		n41, err := m.DestinationCluster.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n41
	}
	return i, nil
}
func (m *RateLimit_Action_RequestHeaders_) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.RequestHeaders != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRds(dAtA, i, uint64(m.RequestHeaders.Size()))
		n42, err := m.RequestHeaders.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n42
	}
	return i, nil
}
func (m *RateLimit_Action_RemoteAddress_) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.RemoteAddress != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRds(dAtA, i, uint64(m.RemoteAddress.Size()))
		n43, err := m.RemoteAddress.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n43
	}
	return i, nil
}
func (m *RateLimit_Action_GenericKey_) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.GenericKey != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintRds(dAtA, i, uint64(m.GenericKey.Size()))
		n44, err := m.GenericKey.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n44
	}
	return i, nil
}
func (m *RateLimit_Action_HeaderValueMatch_) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.HeaderValueMatch != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintRds(dAtA, i, uint64(m.HeaderValueMatch.Size()))
		n45, err := m.HeaderValueMatch.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n45
	}
	return i, nil
}
func (m *RateLimit_Action_SourceCluster) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RateLimit_Action_SourceCluster) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *RateLimit_Action_DestinationCluster) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RateLimit_Action_DestinationCluster) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *RateLimit_Action_RequestHeaders) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RateLimit_Action_RequestHeaders) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.HeaderName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRds(dAtA, i, uint64(len(m.HeaderName)))
		i += copy(dAtA[i:], m.HeaderName)
	}
	if len(m.DescriptorKey) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRds(dAtA, i, uint64(len(m.DescriptorKey)))
		i += copy(dAtA[i:], m.DescriptorKey)
	}
	return i, nil
}

func (m *RateLimit_Action_RemoteAddress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RateLimit_Action_RemoteAddress) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *RateLimit_Action_GenericKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RateLimit_Action_GenericKey) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DescriptorValue) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRds(dAtA, i, uint64(len(m.DescriptorValue)))
		i += copy(dAtA[i:], m.DescriptorValue)
	}
	return i, nil
}

func (m *RateLimit_Action_HeaderValueMatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RateLimit_Action_HeaderValueMatch) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DescriptorValue) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRds(dAtA, i, uint64(len(m.DescriptorValue)))
		i += copy(dAtA[i:], m.DescriptorValue)
	}
	if m.ExpectMatch != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRds(dAtA, i, uint64(m.ExpectMatch.Size()))
		n46, err := m.ExpectMatch.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n46
	}
	if len(m.Headers) > 0 {
		for _, msg := range m.Headers {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintRds(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *HeaderMatcher) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeaderMatcher) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRds(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRds(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	if m.Regex != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRds(dAtA, i, uint64(m.Regex.Size()))
		n47, err := m.Regex.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n47
	}
	return i, nil
}

func (m *QueryParameterMatcher) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryParameterMatcher) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRds(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRds(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	if m.Regex != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRds(dAtA, i, uint64(m.Regex.Size()))
		n48, err := m.Regex.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n48
	}
	return i, nil
}

func encodeVarintRds(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *RouteConfiguration) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovRds(uint64(l))
	}
	if len(m.VirtualHosts) > 0 {
		for _, e := range m.VirtualHosts {
			l = e.Size()
			n += 1 + l + sovRds(uint64(l))
		}
	}
	if len(m.InternalOnlyHeaders) > 0 {
		for _, s := range m.InternalOnlyHeaders {
			l = len(s)
			n += 1 + l + sovRds(uint64(l))
		}
	}
	if len(m.ResponseHeadersToAdd) > 0 {
		for _, e := range m.ResponseHeadersToAdd {
			l = e.Size()
			n += 1 + l + sovRds(uint64(l))
		}
	}
	if len(m.ResponseHeadersToRemove) > 0 {
		for _, s := range m.ResponseHeadersToRemove {
			l = len(s)
			n += 1 + l + sovRds(uint64(l))
		}
	}
	if len(m.RequestHeadersToAdd) > 0 {
		for _, e := range m.RequestHeadersToAdd {
			l = e.Size()
			n += 1 + l + sovRds(uint64(l))
		}
	}
	if m.ValidateClusters != nil {
		l = m.ValidateClusters.Size()
		n += 1 + l + sovRds(uint64(l))
	}
	return n
}

func (m *VirtualHost) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovRds(uint64(l))
	}
	if len(m.Domains) > 0 {
		for _, s := range m.Domains {
			l = len(s)
			n += 1 + l + sovRds(uint64(l))
		}
	}
	if len(m.Routes) > 0 {
		for _, e := range m.Routes {
			l = e.Size()
			n += 1 + l + sovRds(uint64(l))
		}
	}
	if m.RequireTls != 0 {
		n += 1 + sovRds(uint64(m.RequireTls))
	}
	if len(m.VirtualClusters) > 0 {
		for _, e := range m.VirtualClusters {
			l = e.Size()
			n += 1 + l + sovRds(uint64(l))
		}
	}
	if len(m.RateLimits) > 0 {
		for _, e := range m.RateLimits {
			l = e.Size()
			n += 1 + l + sovRds(uint64(l))
		}
	}
	if len(m.RequestHeadersToAdd) > 0 {
		for _, e := range m.RequestHeadersToAdd {
			l = e.Size()
			n += 1 + l + sovRds(uint64(l))
		}
	}
	if m.Cors != nil {
		l = m.Cors.Size()
		n += 1 + l + sovRds(uint64(l))
	}
	if m.Auth != nil {
		l = m.Auth.Size()
		n += 1 + l + sovRds(uint64(l))
	}
	if len(m.ResponseHeadersToAdd) > 0 {
		for _, e := range m.ResponseHeadersToAdd {
			l = e.Size()
			n += 1 + l + sovRds(uint64(l))
		}
	}
	if len(m.ResponseHeadersToRemove) > 0 {
		for _, s := range m.ResponseHeadersToRemove {
			l = len(s)
			n += 1 + l + sovRds(uint64(l))
		}
	}
	return n
}

func (m *Route) Size() (n int) {
	var l int
	_ = l
	if m.Match != nil {
		l = m.Match.Size()
		n += 1 + l + sovRds(uint64(l))
	}
	if m.Action != nil {
		n += m.Action.Size()
	}
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovRds(uint64(l))
	}
	if m.Decorator != nil {
		l = m.Decorator.Size()
		n += 1 + l + sovRds(uint64(l))
	}
	if m.Auth != nil {
		l = m.Auth.Size()
		n += 1 + l + sovRds(uint64(l))
	}
	return n
}

func (m *Route_Route) Size() (n int) {
	var l int
	_ = l
	if m.Route != nil {
		l = m.Route.Size()
		n += 1 + l + sovRds(uint64(l))
	}
	return n
}
func (m *Route_Redirect) Size() (n int) {
	var l int
	_ = l
	if m.Redirect != nil {
		l = m.Redirect.Size()
		n += 1 + l + sovRds(uint64(l))
	}
	return n
}
func (m *Route_DirectResponse) Size() (n int) {
	var l int
	_ = l
	if m.DirectResponse != nil {
		l = m.DirectResponse.Size()
		n += 1 + l + sovRds(uint64(l))
	}
	return n
}
func (m *WeightedCluster) Size() (n int) {
	var l int
	_ = l
	if len(m.Clusters) > 0 {
		for _, e := range m.Clusters {
			l = e.Size()
			n += 1 + l + sovRds(uint64(l))
		}
	}
	l = len(m.RuntimeKeyPrefix)
	if l > 0 {
		n += 1 + l + sovRds(uint64(l))
	}
	return n
}

func (m *WeightedCluster_ClusterWeight) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovRds(uint64(l))
	}
	if m.Weight != nil {
		l = m.Weight.Size()
		n += 1 + l + sovRds(uint64(l))
	}
	if m.MetadataMatch != nil {
		l = m.MetadataMatch.Size()
		n += 1 + l + sovRds(uint64(l))
	}
	return n
}

func (m *RouteMatch) Size() (n int) {
	var l int
	_ = l
	if m.PathSpecifier != nil {
		n += m.PathSpecifier.Size()
	}
	if m.CaseSensitive != nil {
		l = m.CaseSensitive.Size()
		n += 1 + l + sovRds(uint64(l))
	}
	if m.Runtime != nil {
		l = m.Runtime.Size()
		n += 1 + l + sovRds(uint64(l))
	}
	if len(m.Headers) > 0 {
		for _, e := range m.Headers {
			l = e.Size()
			n += 1 + l + sovRds(uint64(l))
		}
	}
	if len(m.QueryParameters) > 0 {
		for _, e := range m.QueryParameters {
			l = e.Size()
			n += 1 + l + sovRds(uint64(l))
		}
	}
	return n
}

func (m *RouteMatch_Prefix) Size() (n int) {
	var l int
	_ = l
	l = len(m.Prefix)
	n += 1 + l + sovRds(uint64(l))
	return n
}
func (m *RouteMatch_Path) Size() (n int) {
	var l int
	_ = l
	l = len(m.Path)
	n += 1 + l + sovRds(uint64(l))
	return n
}
func (m *RouteMatch_Regex) Size() (n int) {
	var l int
	_ = l
	l = len(m.Regex)
	n += 1 + l + sovRds(uint64(l))
	return n
}
func (m *CorsPolicy) Size() (n int) {
	var l int
	_ = l
	if len(m.AllowOrigin) > 0 {
		for _, s := range m.AllowOrigin {
			l = len(s)
			n += 1 + l + sovRds(uint64(l))
		}
	}
	l = len(m.AllowMethods)
	if l > 0 {
		n += 1 + l + sovRds(uint64(l))
	}
	l = len(m.AllowHeaders)
	if l > 0 {
		n += 1 + l + sovRds(uint64(l))
	}
	l = len(m.ExposeHeaders)
	if l > 0 {
		n += 1 + l + sovRds(uint64(l))
	}
	l = len(m.MaxAge)
	if l > 0 {
		n += 1 + l + sovRds(uint64(l))
	}
	if m.AllowCredentials != nil {
		l = m.AllowCredentials.Size()
		n += 1 + l + sovRds(uint64(l))
	}
	if m.Enabled != nil {
		l = m.Enabled.Size()
		n += 1 + l + sovRds(uint64(l))
	}
	return n
}

func (m *RouteAction) Size() (n int) {
	var l int
	_ = l
	if m.ClusterSpecifier != nil {
		n += m.ClusterSpecifier.Size()
	}
	if m.MetadataMatch != nil {
		l = m.MetadataMatch.Size()
		n += 1 + l + sovRds(uint64(l))
	}
	l = len(m.PrefixRewrite)
	if l > 0 {
		n += 1 + l + sovRds(uint64(l))
	}
	if m.HostRewriteSpecifier != nil {
		n += m.HostRewriteSpecifier.Size()
	}
	if m.Timeout != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdDuration(*m.Timeout)
		n += 1 + l + sovRds(uint64(l))
	}
	if m.RetryPolicy != nil {
		l = m.RetryPolicy.Size()
		n += 1 + l + sovRds(uint64(l))
	}
	if m.RequestMirrorPolicy != nil {
		l = m.RequestMirrorPolicy.Size()
		n += 1 + l + sovRds(uint64(l))
	}
	if m.Priority != 0 {
		n += 1 + sovRds(uint64(m.Priority))
	}
	if len(m.RequestHeadersToAdd) > 0 {
		for _, e := range m.RequestHeadersToAdd {
			l = e.Size()
			n += 1 + l + sovRds(uint64(l))
		}
	}
	if len(m.RateLimits) > 0 {
		for _, e := range m.RateLimits {
			l = e.Size()
			n += 1 + l + sovRds(uint64(l))
		}
	}
	if m.IncludeVhRateLimits != nil {
		l = m.IncludeVhRateLimits.Size()
		n += 1 + l + sovRds(uint64(l))
	}
	if len(m.HashPolicy) > 0 {
		for _, e := range m.HashPolicy {
			l = e.Size()
			n += 1 + l + sovRds(uint64(l))
		}
	}
	if m.UseWebsocket != nil {
		l = m.UseWebsocket.Size()
		n += 2 + l + sovRds(uint64(l))
	}
	if m.Cors != nil {
		l = m.Cors.Size()
		n += 2 + l + sovRds(uint64(l))
	}
	if len(m.ResponseHeadersToAdd) > 0 {
		for _, e := range m.ResponseHeadersToAdd {
			l = e.Size()
			n += 2 + l + sovRds(uint64(l))
		}
	}
	if len(m.ResponseHeadersToRemove) > 0 {
		for _, s := range m.ResponseHeadersToRemove {
			l = len(s)
			n += 2 + l + sovRds(uint64(l))
		}
	}
	if m.ClusterNotFoundResponseCode != 0 {
		n += 2 + sovRds(uint64(m.ClusterNotFoundResponseCode))
	}
	return n
}

func (m *RouteAction_Cluster) Size() (n int) {
	var l int
	_ = l
	l = len(m.Cluster)
	n += 1 + l + sovRds(uint64(l))
	return n
}
func (m *RouteAction_ClusterHeader) Size() (n int) {
	var l int
	_ = l
	l = len(m.ClusterHeader)
	n += 1 + l + sovRds(uint64(l))
	return n
}
func (m *RouteAction_WeightedClusters) Size() (n int) {
	var l int
	_ = l
	if m.WeightedClusters != nil {
		l = m.WeightedClusters.Size()
		n += 1 + l + sovRds(uint64(l))
	}
	return n
}
func (m *RouteAction_HostRewrite) Size() (n int) {
	var l int
	_ = l
	l = len(m.HostRewrite)
	n += 1 + l + sovRds(uint64(l))
	return n
}
func (m *RouteAction_AutoHostRewrite) Size() (n int) {
	var l int
	_ = l
	if m.AutoHostRewrite != nil {
		l = m.AutoHostRewrite.Size()
		n += 1 + l + sovRds(uint64(l))
	}
	return n
}
func (m *RouteAction_RetryPolicy) Size() (n int) {
	var l int
	_ = l
	l = len(m.RetryOn)
	if l > 0 {
		n += 1 + l + sovRds(uint64(l))
	}
	if m.NumRetries != nil {
		l = m.NumRetries.Size()
		n += 1 + l + sovRds(uint64(l))
	}
	if m.PerTryTimeout != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdDuration(*m.PerTryTimeout)
		n += 1 + l + sovRds(uint64(l))
	}
	return n
}

func (m *RouteAction_RequestMirrorPolicy) Size() (n int) {
	var l int
	_ = l
	l = len(m.Cluster)
	if l > 0 {
		n += 1 + l + sovRds(uint64(l))
	}
	l = len(m.RuntimeKey)
	if l > 0 {
		n += 1 + l + sovRds(uint64(l))
	}
	return n
}

func (m *RouteAction_HashPolicy) Size() (n int) {
	var l int
	_ = l
	if m.PolicySpecifier != nil {
		n += m.PolicySpecifier.Size()
	}
	return n
}

func (m *RouteAction_HashPolicy_Header_) Size() (n int) {
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovRds(uint64(l))
	}
	return n
}
func (m *RouteAction_HashPolicy_Cookie_) Size() (n int) {
	var l int
	_ = l
	if m.Cookie != nil {
		l = m.Cookie.Size()
		n += 1 + l + sovRds(uint64(l))
	}
	return n
}
func (m *RouteAction_HashPolicy_ConnectionProperties_) Size() (n int) {
	var l int
	_ = l
	if m.ConnectionProperties != nil {
		l = m.ConnectionProperties.Size()
		n += 1 + l + sovRds(uint64(l))
	}
	return n
}
func (m *RouteAction_HashPolicy_Header) Size() (n int) {
	var l int
	_ = l
	l = len(m.HeaderName)
	if l > 0 {
		n += 1 + l + sovRds(uint64(l))
	}
	return n
}

func (m *RouteAction_HashPolicy_Cookie) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovRds(uint64(l))
	}
	if m.Ttl != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdDuration(*m.Ttl)
		n += 1 + l + sovRds(uint64(l))
	}
	return n
}

func (m *RouteAction_HashPolicy_ConnectionProperties) Size() (n int) {
	var l int
	_ = l
	if m.SourceIp {
		n += 2
	}
	return n
}

func (m *RedirectAction) Size() (n int) {
	var l int
	_ = l
	l = len(m.HostRedirect)
	if l > 0 {
		n += 1 + l + sovRds(uint64(l))
	}
	l = len(m.PathRedirect)
	if l > 0 {
		n += 1 + l + sovRds(uint64(l))
	}
	if m.ResponseCode != 0 {
		n += 1 + sovRds(uint64(m.ResponseCode))
	}
	return n
}

func (m *DirectResponseAction) Size() (n int) {
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovRds(uint64(m.Status))
	}
	if m.Body != nil {
		l = m.Body.Size()
		n += 1 + l + sovRds(uint64(l))
	}
	return n
}

func (m *Decorator) Size() (n int) {
	var l int
	_ = l
	l = len(m.Operation)
	if l > 0 {
		n += 1 + l + sovRds(uint64(l))
	}
	return n
}

func (m *VirtualCluster) Size() (n int) {
	var l int
	_ = l
	l = len(m.Pattern)
	if l > 0 {
		n += 1 + l + sovRds(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovRds(uint64(l))
	}
	if m.Method != 0 {
		n += 1 + sovRds(uint64(m.Method))
	}
	return n
}

func (m *RateLimit) Size() (n int) {
	var l int
	_ = l
	if m.Stage != nil {
		l = m.Stage.Size()
		n += 1 + l + sovRds(uint64(l))
	}
	l = len(m.DisableKey)
	if l > 0 {
		n += 1 + l + sovRds(uint64(l))
	}
	if len(m.Actions) > 0 {
		for _, e := range m.Actions {
			l = e.Size()
			n += 1 + l + sovRds(uint64(l))
		}
	}
	return n
}

func (m *RateLimit_Action) Size() (n int) {
	var l int
	_ = l
	if m.ActionSpecifier != nil {
		n += m.ActionSpecifier.Size()
	}
	return n
}

func (m *RateLimit_Action_SourceCluster_) Size() (n int) {
	var l int
	_ = l
	if m.SourceCluster != nil {
		l = m.SourceCluster.Size()
		n += 1 + l + sovRds(uint64(l))
	}
	return n
}
func (m *RateLimit_Action_DestinationCluster_) Size() (n int) {
	var l int
	_ = l
	if m.DestinationCluster != nil {
		l = m.DestinationCluster.Size()
		n += 1 + l + sovRds(uint64(l))
	}
	return n
}
func (m *RateLimit_Action_RequestHeaders_) Size() (n int) {
	var l int
	_ = l
	if m.RequestHeaders != nil {
		l = m.RequestHeaders.Size()
		n += 1 + l + sovRds(uint64(l))
	}
	return n
}
func (m *RateLimit_Action_RemoteAddress_) Size() (n int) {
	var l int
	_ = l
	if m.RemoteAddress != nil {
		l = m.RemoteAddress.Size()
		n += 1 + l + sovRds(uint64(l))
	}
	return n
}
func (m *RateLimit_Action_GenericKey_) Size() (n int) {
	var l int
	_ = l
	if m.GenericKey != nil {
		l = m.GenericKey.Size()
		n += 1 + l + sovRds(uint64(l))
	}
	return n
}
func (m *RateLimit_Action_HeaderValueMatch_) Size() (n int) {
	var l int
	_ = l
	if m.HeaderValueMatch != nil {
		l = m.HeaderValueMatch.Size()
		n += 1 + l + sovRds(uint64(l))
	}
	return n
}
func (m *RateLimit_Action_SourceCluster) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *RateLimit_Action_DestinationCluster) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *RateLimit_Action_RequestHeaders) Size() (n int) {
	var l int
	_ = l
	l = len(m.HeaderName)
	if l > 0 {
		n += 1 + l + sovRds(uint64(l))
	}
	l = len(m.DescriptorKey)
	if l > 0 {
		n += 1 + l + sovRds(uint64(l))
	}
	return n
}

func (m *RateLimit_Action_RemoteAddress) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *RateLimit_Action_GenericKey) Size() (n int) {
	var l int
	_ = l
	l = len(m.DescriptorValue)
	if l > 0 {
		n += 1 + l + sovRds(uint64(l))
	}
	return n
}

func (m *RateLimit_Action_HeaderValueMatch) Size() (n int) {
	var l int
	_ = l
	l = len(m.DescriptorValue)
	if l > 0 {
		n += 1 + l + sovRds(uint64(l))
	}
	if m.ExpectMatch != nil {
		l = m.ExpectMatch.Size()
		n += 1 + l + sovRds(uint64(l))
	}
	if len(m.Headers) > 0 {
		for _, e := range m.Headers {
			l = e.Size()
			n += 1 + l + sovRds(uint64(l))
		}
	}
	return n
}

func (m *HeaderMatcher) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovRds(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovRds(uint64(l))
	}
	if m.Regex != nil {
		l = m.Regex.Size()
		n += 1 + l + sovRds(uint64(l))
	}
	return n
}

func (m *QueryParameterMatcher) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovRds(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovRds(uint64(l))
	}
	if m.Regex != nil {
		l = m.Regex.Size()
		n += 1 + l + sovRds(uint64(l))
	}
	return n
}

func sovRds(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozRds(x uint64) (n int) {
	return sovRds(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *RouteConfiguration) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRds
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteConfiguration: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteConfiguration: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualHosts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VirtualHosts = append(m.VirtualHosts, &VirtualHost{})
			if err := m.VirtualHosts[len(m.VirtualHosts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternalOnlyHeaders", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InternalOnlyHeaders = append(m.InternalOnlyHeaders, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeadersToAdd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResponseHeadersToAdd = append(m.ResponseHeadersToAdd, &HeaderValueOption{})
			if err := m.ResponseHeadersToAdd[len(m.ResponseHeadersToAdd)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeadersToRemove", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResponseHeadersToRemove = append(m.ResponseHeadersToRemove, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeadersToAdd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestHeadersToAdd = append(m.RequestHeadersToAdd, &HeaderValueOption{})
			if err := m.RequestHeadersToAdd[len(m.RequestHeadersToAdd)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidateClusters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ValidateClusters == nil {
				m.ValidateClusters = &google_protobuf.BoolValue{}
			}
			if err := m.ValidateClusters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRds(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRds
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VirtualHost) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRds
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VirtualHost: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VirtualHost: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domains", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domains = append(m.Domains, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Routes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Routes = append(m.Routes, &Route{})
			if err := m.Routes[len(m.Routes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireTls", wireType)
			}
			m.RequireTls = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequireTls |= (VirtualHost_TlsRequirementType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualClusters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VirtualClusters = append(m.VirtualClusters, &VirtualCluster{})
			if err := m.VirtualClusters[len(m.VirtualClusters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RateLimits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RateLimits = append(m.RateLimits, &RateLimit{})
			if err := m.RateLimits[len(m.RateLimits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeadersToAdd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestHeadersToAdd = append(m.RequestHeadersToAdd, &HeaderValueOption{})
			if err := m.RequestHeadersToAdd[len(m.RequestHeadersToAdd)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cors == nil {
				m.Cors = &CorsPolicy{}
			}
			if err := m.Cors.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Auth", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Auth == nil {
				m.Auth = &AuthAction{}
			}
			if err := m.Auth.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeadersToAdd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResponseHeadersToAdd = append(m.ResponseHeadersToAdd, &HeaderValueOption{})
			if err := m.ResponseHeadersToAdd[len(m.ResponseHeadersToAdd)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeadersToRemove", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResponseHeadersToRemove = append(m.ResponseHeadersToRemove, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRds(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRds
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Route) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRds
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Route: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Route: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Match", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Match == nil {
				m.Match = &RouteMatch{}
			}
			if err := m.Match.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Route", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RouteAction{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &Route_Route{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Redirect", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RedirectAction{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &Route_Redirect{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &Metadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Decorator", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Decorator == nil {
				m.Decorator = &Decorator{}
			}
			if err := m.Decorator.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Auth", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Auth == nil {
				m.Auth = &AuthAction{}
			}
			if err := m.Auth.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DirectResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DirectResponseAction{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &Route_DirectResponse{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRds(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRds
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WeightedCluster) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRds
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WeightedCluster: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WeightedCluster: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Clusters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Clusters = append(m.Clusters, &WeightedCluster_ClusterWeight{})
			if err := m.Clusters[len(m.Clusters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuntimeKeyPrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuntimeKeyPrefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRds(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRds
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WeightedCluster_ClusterWeight) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRds
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterWeight: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterWeight: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weight", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Weight == nil {
				m.Weight = &google_protobuf.UInt32Value{}
			}
			if err := m.Weight.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetadataMatch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MetadataMatch == nil {
				m.MetadataMatch = &Metadata{}
			}
			if err := m.MetadataMatch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRds(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRds
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteMatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRds
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteMatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteMatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PathSpecifier = &RouteMatch_Prefix{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PathSpecifier = &RouteMatch_Path{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Regex", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PathSpecifier = &RouteMatch_Regex{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaseSensitive", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CaseSensitive == nil {
				m.CaseSensitive = &google_protobuf.BoolValue{}
			}
			if err := m.CaseSensitive.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Runtime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Runtime == nil {
				m.Runtime = &RuntimeUInt32{}
			}
			if err := m.Runtime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Headers = append(m.Headers, &HeaderMatcher{})
			if err := m.Headers[len(m.Headers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryParameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QueryParameters = append(m.QueryParameters, &QueryParameterMatcher{})
			if err := m.QueryParameters[len(m.QueryParameters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRds(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRds
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CorsPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRds
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CorsPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CorsPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowOrigin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllowOrigin = append(m.AllowOrigin, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowMethods", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllowMethods = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowHeaders", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllowHeaders = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExposeHeaders", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExposeHeaders = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxAge", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MaxAge = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowCredentials", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AllowCredentials == nil {
				m.AllowCredentials = &google_protobuf.BoolValue{}
			}
			if err := m.AllowCredentials.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Enabled == nil {
				m.Enabled = &google_protobuf.BoolValue{}
			}
			if err := m.Enabled.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRds(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRds
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteAction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRds
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteAction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteAction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cluster", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterSpecifier = &RouteAction_Cluster{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterHeader", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterSpecifier = &RouteAction_ClusterHeader{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WeightedClusters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &WeightedCluster{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ClusterSpecifier = &RouteAction_WeightedClusters{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetadataMatch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MetadataMatch == nil {
				m.MetadataMatch = &Metadata{}
			}
			if err := m.MetadataMatch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrefixRewrite", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrefixRewrite = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostRewrite", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostRewriteSpecifier = &RouteAction_HostRewrite{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoHostRewrite", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &google_protobuf.BoolValue{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.HostRewriteSpecifier = &RouteAction_AutoHostRewrite{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timeout == nil {
				m.Timeout = new(time.Duration)
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(m.Timeout, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetryPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RetryPolicy == nil {
				m.RetryPolicy = &RouteAction_RetryPolicy{}
			}
			if err := m.RetryPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestMirrorPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RequestMirrorPolicy == nil {
				m.RequestMirrorPolicy = &RouteAction_RequestMirrorPolicy{}
			}
			if err := m.RequestMirrorPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= (RoutingPriority(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeadersToAdd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestHeadersToAdd = append(m.RequestHeadersToAdd, &HeaderValueOption{})
			if err := m.RequestHeadersToAdd[len(m.RequestHeadersToAdd)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RateLimits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RateLimits = append(m.RateLimits, &RateLimit{})
			if err := m.RateLimits[len(m.RateLimits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncludeVhRateLimits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IncludeVhRateLimits == nil {
				m.IncludeVhRateLimits = &google_protobuf.BoolValue{}
			}
			if err := m.IncludeVhRateLimits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HashPolicy = append(m.HashPolicy, &RouteAction_HashPolicy{})
			if err := m.HashPolicy[len(m.HashPolicy)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseWebsocket", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UseWebsocket == nil {
				m.UseWebsocket = &google_protobuf.BoolValue{}
			}
			if err := m.UseWebsocket.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cors == nil {
				m.Cors = &CorsPolicy{}
			}
			if err := m.Cors.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeadersToAdd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResponseHeadersToAdd = append(m.ResponseHeadersToAdd, &HeaderValueOption{})
			if err := m.ResponseHeadersToAdd[len(m.ResponseHeadersToAdd)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeadersToRemove", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResponseHeadersToRemove = append(m.ResponseHeadersToRemove, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterNotFoundResponseCode", wireType)
			}
			m.ClusterNotFoundResponseCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClusterNotFoundResponseCode |= (RouteAction_ClusterNotFoundResponseCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRds(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRds
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteAction_RetryPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRds
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RetryPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RetryPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetryOn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RetryOn = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumRetries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NumRetries == nil {
				m.NumRetries = &google_protobuf.UInt32Value{}
			}
			if err := m.NumRetries.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerTryTimeout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PerTryTimeout == nil {
				m.PerTryTimeout = new(time.Duration)
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(m.PerTryTimeout, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRds(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRds
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteAction_RequestMirrorPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRds
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestMirrorPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestMirrorPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cluster", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cluster = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuntimeKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuntimeKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRds(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRds
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteAction_HashPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRds
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HashPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HashPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RouteAction_HashPolicy_Header{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PolicySpecifier = &RouteAction_HashPolicy_Header_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cookie", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RouteAction_HashPolicy_Cookie{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PolicySpecifier = &RouteAction_HashPolicy_Cookie_{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectionProperties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RouteAction_HashPolicy_ConnectionProperties{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PolicySpecifier = &RouteAction_HashPolicy_ConnectionProperties_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRds(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRds
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteAction_HashPolicy_Header) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRds
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Header: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Header: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeaderName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeaderName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRds(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRds
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteAction_HashPolicy_Cookie) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRds
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Cookie: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Cookie: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ttl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ttl == nil {
				m.Ttl = new(time.Duration)
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(m.Ttl, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRds(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRds
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteAction_HashPolicy_ConnectionProperties) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRds
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConnectionProperties: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConnectionProperties: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceIp", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SourceIp = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipRds(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRds
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RedirectAction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRds
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RedirectAction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RedirectAction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostRedirect", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostRedirect = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PathRedirect", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PathRedirect = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseCode", wireType)
			}
			m.ResponseCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResponseCode |= (RedirectAction_RedirectResponseCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRds(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRds
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DirectResponseAction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRds
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DirectResponseAction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DirectResponseAction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Body == nil {
				m.Body = &DataSource{}
			}
			if err := m.Body.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRds(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRds
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Decorator) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRds
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Decorator: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Decorator: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRds(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRds
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VirtualCluster) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRds
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VirtualCluster: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VirtualCluster: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pattern", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pattern = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			m.Method = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Method |= (RequestMethod(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRds(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRds
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RateLimit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRds
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RateLimit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RateLimit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stage == nil {
				m.Stage = &google_protobuf.UInt32Value{}
			}
			if err := m.Stage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisableKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Actions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Actions = append(m.Actions, &RateLimit_Action{})
			if err := m.Actions[len(m.Actions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRds(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRds
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RateLimit_Action) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRds
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Action: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Action: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceCluster", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RateLimit_Action_SourceCluster{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionSpecifier = &RateLimit_Action_SourceCluster_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationCluster", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RateLimit_Action_DestinationCluster{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionSpecifier = &RateLimit_Action_DestinationCluster_{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeaders", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RateLimit_Action_RequestHeaders{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionSpecifier = &RateLimit_Action_RequestHeaders_{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RateLimit_Action_RemoteAddress{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionSpecifier = &RateLimit_Action_RemoteAddress_{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GenericKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RateLimit_Action_GenericKey{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionSpecifier = &RateLimit_Action_GenericKey_{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeaderValueMatch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RateLimit_Action_HeaderValueMatch{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionSpecifier = &RateLimit_Action_HeaderValueMatch_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRds(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRds
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RateLimit_Action_SourceCluster) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRds
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SourceCluster: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SourceCluster: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRds(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRds
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RateLimit_Action_DestinationCluster) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRds
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DestinationCluster: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DestinationCluster: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRds(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRds
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RateLimit_Action_RequestHeaders) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRds
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestHeaders: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestHeaders: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeaderName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeaderName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DescriptorKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DescriptorKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRds(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRds
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RateLimit_Action_RemoteAddress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRds
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoteAddress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoteAddress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRds(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRds
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RateLimit_Action_GenericKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRds
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GenericKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GenericKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DescriptorValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DescriptorValue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRds(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRds
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RateLimit_Action_HeaderValueMatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRds
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeaderValueMatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeaderValueMatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DescriptorValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DescriptorValue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpectMatch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExpectMatch == nil {
				m.ExpectMatch = &google_protobuf.BoolValue{}
			}
			if err := m.ExpectMatch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Headers = append(m.Headers, &HeaderMatcher{})
			if err := m.Headers[len(m.Headers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRds(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRds
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeaderMatcher) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRds
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeaderMatcher: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeaderMatcher: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Regex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Regex == nil {
				m.Regex = &google_protobuf.BoolValue{}
			}
			if err := m.Regex.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRds(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRds
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryParameterMatcher) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRds
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryParameterMatcher: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryParameterMatcher: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Regex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRds
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRds
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Regex == nil {
				m.Regex = &google_protobuf.BoolValue{}
			}
			if err := m.Regex.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRds(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRds
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRds(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRds
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRds
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRds
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthRds
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowRds
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipRds(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthRds = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRds   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("api/rds.proto", fileDescriptorRds) }

var fileDescriptorRds = []byte{
	// 2558 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x59, 0xcd, 0x6f, 0x1b, 0xc7,
	0xd9, 0xd7, 0xf2, 0x53, 0x7c, 0xf8, 0x21, 0x6a, 0x24, 0x5b, 0x34, 0x9d, 0xd8, 0x7e, 0xe9, 0x04,
	0xd1, 0xeb, 0x38, 0x54, 0x2c, 0x3b, 0x40, 0xe3, 0xc2, 0x0d, 0x48, 0x89, 0x31, 0x8d, 0xe8, 0xab,
	0x23, 0x5a, 0x49, 0xda, 0xc3, 0x62, 0xc5, 0x1d, 0x93, 0xdb, 0x90, 0x3b, 0xcc, 0xec, 0x90, 0x12,
	0x2f, 0x3d, 0xe4, 0x52, 0xb4, 0xc7, 0xf6, 0xd2, 0x7f, 0xa2, 0x45, 0x6e, 0x0d, 0x7a, 0xca, 0xa5,
	0x40, 0x51, 0xf4, 0x10, 0xa0, 0x97, 0xf6, 0x94, 0x22, 0xe8, 0x25, 0x97, 0xdc, 0x7b, 0x2b, 0xe6,
	0x63, 0x77, 0xb9, 0x14, 0x45, 0x2a, 0x4d, 0x73, 0x12, 0xe7, 0x99, 0xdf, 0xf3, 0xcc, 0xcc, 0xf3,
	0x35, 0xbf, 0x59, 0x41, 0xde, 0x1a, 0x38, 0x5b, 0xcc, 0xf6, 0xaa, 0x03, 0x46, 0x39, 0x45, 0x39,
	0xe2, 0x8e, 0xe8, 0xb8, 0x6a, 0x0d, 0x9c, 0xea, 0x68, 0xbb, 0x5c, 0x10, 0x93, 0xd6, 0x90, 0x77,
	0xd5, 0xac, 0x1a, 0x9f, 0x5a, 0x1e, 0xd1, 0xe3, 0x35, 0x31, 0xb6, 0x1d, 0xaf, 0x4d, 0x47, 0x84,
	0x8d, 0xb5, 0xf0, 0xa5, 0x0e, 0xa5, 0x9d, 0x1e, 0xd9, 0x92, 0xba, 0xae, 0x4b, 0xb9, 0xc5, 0x1d,
	0xea, 0xea, 0x05, 0xca, 0xb7, 0xf4, 0xac, 0x1c, 0x9d, 0x0e, 0x5f, 0x6c, 0xd9, 0x43, 0x26, 0x01,
	0x97, 0xcd, 0x9f, 0x31, 0x6b, 0x30, 0x20, 0xcc, 0xd7, 0xdf, 0x18, 0x59, 0x3d, 0xc7, 0xb6, 0x38,
	0xd9, 0xf2, 0x7f, 0xe8, 0x89, 0xf5, 0x0e, 0xed, 0x50, 0xf9, 0x73, 0x4b, 0xfc, 0x52, 0xd2, 0xca,
	0x17, 0x71, 0x40, 0x98, 0x0e, 0x39, 0xd9, 0xa1, 0xee, 0x0b, 0xa7, 0xa3, 0xd7, 0x42, 0x08, 0x12,
	0xae, 0xd5, 0x27, 0x25, 0xe3, 0x8e, 0xb1, 0x99, 0xc1, 0xf2, 0x37, 0xfa, 0x11, 0xe4, 0x47, 0x0e,
	0xe3, 0x43, 0xab, 0x67, 0x76, 0xa9, 0xc7, 0xbd, 0x52, 0xec, 0x4e, 0x7c, 0x33, 0xbb, 0x7d, 0xa3,
	0x3a, 0xe9, 0x92, 0xea, 0x89, 0x82, 0x34, 0xa9, 0xc7, 0x71, 0x6e, 0x14, 0x0e, 0x3c, 0xb4, 0x0d,
	0xd7, 0x1c, 0x97, 0x13, 0xe6, 0x5a, 0x3d, 0x93, 0xba, 0xbd, 0xb1, 0xd9, 0x25, 0x96, 0x4d, 0x98,
	0x57, 0x8a, 0xdf, 0x89, 0x6f, 0x66, 0xf0, 0x9a, 0x3f, 0x79, 0xe8, 0xf6, 0xc6, 0x4d, 0x35, 0x85,
	0x4e, 0x60, 0x83, 0x11, 0x6f, 0x40, 0x5d, 0x8f, 0xf8, 0x70, 0x93, 0x53, 0xd3, 0xb2, 0xed, 0x52,
	0x42, 0xae, 0x7e, 0x3b, 0xba, 0xba, 0xd2, 0x3b, 0xb1, 0x7a, 0x43, 0x72, 0x38, 0x10, 0x27, 0xc1,
	0xeb, 0xbe, 0xbe, 0x36, 0xd9, 0xa2, 0x35, 0xdb, 0x46, 0x3f, 0x84, 0xf2, 0x2c, 0xbb, 0x8c, 0xf4,
	0xe9, 0x88, 0x94, 0x92, 0x72, 0x43, 0x1b, 0x17, 0x34, 0xb1, 0x9c, 0x46, 0x2d, 0xb8, 0xce, 0xc8,
	0xc7, 0x43, 0xe2, 0xf1, 0xe9, 0x3d, 0xa5, 0xae, 0xb6, 0xa7, 0x35, 0xad, 0x1e, 0xd9, 0xd2, 0x53,
	0x58, 0xf5, 0x23, 0x66, 0xb6, 0x7b, 0x43, 0x8f, 0x0b, 0xd7, 0xa4, 0xef, 0x18, 0x9b, 0xd9, 0xed,
	0x72, 0x55, 0x05, 0xbd, 0xea, 0x07, 0xbd, 0x5a, 0xa7, 0xb4, 0x27, 0x2d, 0xe2, 0xa2, 0xaf, 0xb4,
	0xa3, 0x75, 0x2a, 0xff, 0x48, 0x42, 0x76, 0x22, 0x0a, 0xe8, 0xe5, 0xc9, 0x58, 0xd6, 0x33, 0x7f,
	0xfc, 0xfa, 0xf3, 0x78, 0x82, 0xc5, 0xee, 0x18, 0x3a, 0xac, 0xaf, 0x40, 0xda, 0xa6, 0x7d, 0xcb,
	0x71, 0x55, 0x40, 0x33, 0x75, 0x10, 0x88, 0xe4, 0xaf, 0x8d, 0xd8, 0xb2, 0x81, 0xfd, 0x29, 0xf4,
	0x3a, 0xa4, 0x98, 0x48, 0x13, 0x15, 0xad, 0xec, 0xf6, 0x5a, 0xf4, 0x8c, 0x32, 0x85, 0xb0, 0x86,
	0xa0, 0x7d, 0xc8, 0x8a, 0x13, 0x3a, 0x8c, 0x98, 0xbc, 0xe7, 0x95, 0x12, 0x77, 0x8c, 0xcd, 0xc2,
	0xf6, 0xfd, 0x4b, 0xf3, 0xa4, 0xda, 0xea, 0x79, 0x58, 0xe1, 0xfb, 0xc4, 0xe5, 0xad, 0xf1, 0x80,
	0x60, 0xd0, 0x06, 0x5a, 0x3d, 0x0f, 0x3d, 0x85, 0xa2, 0x9f, 0x78, 0x81, 0x63, 0x92, 0x72, 0x17,
	0x2f, 0xcd, 0xb4, 0xa9, 0x3d, 0x81, 0x57, 0x46, 0x91, 0xb1, 0x87, 0x7e, 0x00, 0x59, 0x26, 0xdc,
	0xdb, 0x73, 0xfa, 0x0e, 0xf7, 0x74, 0xb4, 0x36, 0xa6, 0x4e, 0x62, 0x71, 0xb2, 0x27, 0xe6, 0x31,
	0x30, 0xff, 0xa7, 0x37, 0x27, 0xe4, 0xe9, 0xef, 0x10, 0xf2, 0xfb, 0x90, 0x68, 0x53, 0xe6, 0x95,
	0x96, 0x65, 0x94, 0x4b, 0x51, 0x1b, 0x3b, 0x94, 0x79, 0x47, 0xb4, 0xe7, 0xb4, 0xc7, 0x58, 0xa2,
	0xd0, 0x03, 0x48, 0x88, 0x56, 0x53, 0xca, 0x48, 0xf4, 0xcb, 0x51, 0xb4, 0x6c, 0x42, 0xb5, 0x21,
	0xef, 0xd6, 0xda, 0x72, 0x3d, 0x09, 0x9d, 0x57, 0x3e, 0xf0, 0xfd, 0x95, 0x4f, 0x76, 0x6e, 0xf9,
	0x54, 0x1e, 0x03, 0xba, 0x18, 0x70, 0xb4, 0x0c, 0x89, 0x83, 0xc3, 0x83, 0x46, 0x71, 0x09, 0xad,
	0x42, 0xbe, 0xf1, 0x41, 0xab, 0x81, 0x0f, 0x6a, 0x7b, 0xe6, 0xe1, 0xc1, 0xde, 0x87, 0x45, 0x03,
	0xa5, 0x21, 0x5e, 0xdb, 0xdb, 0x2b, 0xc6, 0x2a, 0x9f, 0xc6, 0x21, 0x29, 0x73, 0x0d, 0x3d, 0x86,
	0x64, 0xdf, 0xe2, 0xed, 0xae, 0x4c, 0xeb, 0x0b, 0xce, 0x93, 0x98, 0x7d, 0x31, 0xaf, 0xd3, 0xf9,
	0x57, 0x46, 0xac, 0x68, 0x60, 0xa5, 0x82, 0x1e, 0x40, 0x52, 0x66, 0x6a, 0x29, 0x26, 0x75, 0x6f,
	0xcc, 0xd0, 0x55, 0x6e, 0x6c, 0x2e, 0x61, 0x85, 0x44, 0x8f, 0x61, 0x99, 0x11, 0xdb, 0x61, 0xa4,
	0xcd, 0x4b, 0x71, 0xa9, 0x35, 0x95, 0x7b, 0x58, 0xcf, 0x06, 0x8a, 0x01, 0x1e, 0x6d, 0xc3, 0x72,
	0x9f, 0x70, 0xcb, 0xb6, 0xb8, 0x25, 0x6b, 0x21, 0xbb, 0x7d, 0x3d, 0xaa, 0xbb, 0xaf, 0x67, 0x71,
	0x80, 0x43, 0x6f, 0x41, 0xc6, 0x26, 0x6d, 0xca, 0x2c, 0x4e, 0x59, 0x29, 0x29, 0x95, 0xa6, 0x12,
	0x75, 0xd7, 0x9f, 0xc6, 0x21, 0x32, 0xc8, 0x91, 0xd4, 0xd5, 0x73, 0x64, 0x1f, 0x56, 0xd4, 0x3e,
	0x4d, 0x3f, 0x60, 0xba, 0xeb, 0x54, 0xa6, 0xd6, 0x93, 0x20, 0xac, 0x31, 0xc1, 0x31, 0x0b, 0x76,
	0x44, 0x5e, 0x5f, 0x81, 0x94, 0x25, 0xe7, 0x50, 0xf2, 0xb3, 0xaf, 0x3f, 0x8f, 0x1b, 0x95, 0x3f,
	0xc5, 0x60, 0xe5, 0x7d, 0xe2, 0x74, 0xba, 0x9c, 0xd8, 0xba, 0x12, 0xd1, 0x31, 0x2c, 0x07, 0x95,
	0x6c, 0xc8, 0x44, 0x7c, 0x3d, 0xba, 0xd8, 0x94, 0x42, 0x55, 0xff, 0x55, 0xe2, 0x48, 0x87, 0x0a,
	0x0c, 0xa1, 0xfb, 0x80, 0xd8, 0xd0, 0xe5, 0x4e, 0x9f, 0x98, 0x1f, 0x91, 0xb1, 0x39, 0x60, 0xe4,
	0x85, 0x73, 0x2e, 0x43, 0x9c, 0xc1, 0x45, 0x3d, 0xf3, 0x1e, 0x19, 0x1f, 0x49, 0x79, 0xf9, 0xf7,
	0x06, 0xe4, 0x23, 0x56, 0x17, 0xf5, 0xc9, 0x77, 0x20, 0x75, 0x26, 0x81, 0x3a, 0x6b, 0x5e, 0xba,
	0xd0, 0x94, 0x9f, 0x3f, 0x73, 0xf9, 0xc3, 0x6d, 0x59, 0x3d, 0x5a, 0xfd, 0x5e, 0xac, 0x64, 0x63,
	0xad, 0x86, 0x9e, 0x40, 0xc1, 0x0f, 0xaf, 0xa9, 0x52, 0x37, 0x3e, 0x37, 0x19, 0xf2, 0x3e, 0x5a,
	0xe6, 0x71, 0xe5, 0x9b, 0x18, 0x40, 0x98, 0xd6, 0xa8, 0x04, 0x29, 0x7d, 0x42, 0xb9, 0xdf, 0xe6,
	0x12, 0xd6, 0x63, 0xb4, 0x0e, 0x89, 0x81, 0xc5, 0xbb, 0xea, 0xe4, 0xcd, 0x25, 0x2c, 0x47, 0xe8,
	0x3a, 0x24, 0x19, 0xe9, 0x90, 0x73, 0xb9, 0x68, 0x46, 0x26, 0xb6, 0x18, 0xa2, 0x1a, 0x14, 0xda,
	0x96, 0x47, 0x4c, 0x8f, 0xb8, 0x9e, 0xc3, 0x9d, 0x11, 0xd1, 0x29, 0x3a, 0xef, 0xce, 0xc9, 0x0b,
	0x8d, 0x63, 0x5f, 0x01, 0xbd, 0x05, 0x69, 0xed, 0x5e, 0x9d, 0xa9, 0x37, 0xa7, 0x4a, 0x43, 0x4d,
	0x2a, 0xf7, 0x60, 0x1f, 0x2b, 0xd4, 0x7c, 0x06, 0xa0, 0x3a, 0xf1, 0xcd, 0x59, 0xcd, 0x48, 0x9e,
	0x96, 0x30, 0xec, 0x63, 0xd1, 0x01, 0x14, 0x3f, 0x1e, 0x12, 0x36, 0x36, 0x07, 0x16, 0xb3, 0xfa,
	0x44, 0x5f, 0x93, 0x42, 0xff, 0x6e, 0x54, 0xff, 0xc7, 0x02, 0x75, 0xe4, 0x83, 0x7c, 0x3b, 0x2b,
	0x1f, 0x47, 0xc4, 0x5e, 0x7d, 0x03, 0x0a, 0xc2, 0x41, 0xa6, 0x37, 0x20, 0x6d, 0xe7, 0x85, 0x43,
	0x98, 0x9f, 0xb8, 0x9f, 0xc5, 0x00, 0xc2, 0x26, 0x8c, 0xfe, 0x0f, 0x72, 0x56, 0xaf, 0x47, 0xcf,
	0x4c, 0xca, 0x9c, 0x8e, 0xe3, 0xca, 0xbc, 0xcd, 0xe0, 0xac, 0x94, 0x1d, 0x4a, 0x11, 0xba, 0x0b,
	0x79, 0x05, 0xe9, 0x13, 0xde, 0xa5, 0xb6, 0xa7, 0x93, 0x4f, 0xe9, 0xed, 0x2b, 0x59, 0x08, 0x0a,
	0xe9, 0x4f, 0x08, 0xf2, 0x79, 0xcf, 0xab, 0x50, 0x20, 0xe7, 0x03, 0x1a, 0xb6, 0x57, 0x19, 0x95,
	0x0c, 0xce, 0x2b, 0xa9, 0x0f, 0xdb, 0x80, 0x74, 0xdf, 0x3a, 0x37, 0xad, 0x8e, 0xf2, 0x7c, 0x06,
	0xa7, 0xfa, 0xd6, 0x79, 0xad, 0x43, 0x04, 0x99, 0x50, 0x8b, 0xb4, 0x19, 0xb1, 0x89, 0xcb, 0x1d,
	0xab, 0xe7, 0xe9, 0xa6, 0x30, 0x97, 0x4c, 0x48, 0xa5, 0x9d, 0x50, 0x07, 0x3d, 0x82, 0x34, 0x71,
	0xad, 0xd3, 0x1e, 0xb1, 0xaf, 0xc0, 0x45, 0x7c, 0x68, 0xe5, 0xaf, 0xab, 0x90, 0x9d, 0x68, 0xa3,
	0xa8, 0x0c, 0x69, 0x5d, 0xa6, 0x41, 0xb6, 0xfa, 0x02, 0xf4, 0x1a, 0x14, 0xf4, 0x4f, 0x7d, 0xd6,
	0x20, 0x71, 0xf3, 0x5a, 0xae, 0x4e, 0x8b, 0xf6, 0x60, 0xf5, 0x4c, 0xb7, 0x85, 0x90, 0x07, 0xc4,
	0x67, 0x35, 0xba, 0xa9, 0xee, 0xd1, 0x5c, 0xc2, 0xc5, 0xb3, 0xa8, 0xc8, 0x9b, 0x51, 0x8d, 0x89,
	0x6f, 0x51, 0x8d, 0x22, 0x40, 0xaa, 0xdc, 0x4c, 0x46, 0xce, 0x98, 0xc3, 0xfd, 0x00, 0xe4, 0x95,
	0x14, 0x2b, 0x21, 0xba, 0x0b, 0x39, 0xc1, 0x95, 0x03, 0x50, 0x4a, 0x1e, 0xcd, 0xc0, 0x59, 0x21,
	0xf5, 0x41, 0x4d, 0x58, 0xb5, 0x86, 0x9c, 0x9a, 0x11, 0xe4, 0x42, 0x6f, 0x37, 0x0d, 0xbc, 0x22,
	0xd4, 0x9a, 0x13, 0x96, 0xde, 0x86, 0xb4, 0x28, 0x2d, 0x3a, 0xe4, 0x9a, 0x53, 0xdc, 0xb8, 0xa0,
	0xbf, 0xab, 0x29, 0x7e, 0x3d, 0xf1, 0xdb, 0x2f, 0x6f, 0x1b, 0xd8, 0xc7, 0xa3, 0x26, 0xe4, 0x18,
	0xe1, 0xa2, 0xac, 0x64, 0xba, 0x6b, 0x96, 0xf1, 0xea, 0xa5, 0x57, 0x63, 0x15, 0x0b, 0xb4, 0x26,
	0x28, 0x59, 0x16, 0x0e, 0x90, 0x05, 0xd7, 0x7c, 0xae, 0xd4, 0x77, 0x18, 0xa3, 0xcc, 0x37, 0x09,
	0xd2, 0xe4, 0x1b, 0xf3, 0x4c, 0x4a, 0xb5, 0x7d, 0xa9, 0xa5, 0x4d, 0xfb, 0xc4, 0x69, 0x52, 0x88,
	0xde, 0x86, 0xe5, 0x01, 0x73, 0x28, 0x73, 0xf8, 0xb8, 0x94, 0x95, 0xec, 0xf2, 0xe5, 0x8b, 0x56,
	0x1d, 0xb7, 0x73, 0xa4, 0x41, 0x38, 0x80, 0xcf, 0x61, 0x72, 0xb9, 0xef, 0xc0, 0xe4, 0xa6, 0x98,
	0x65, 0xfe, 0xea, 0xcc, 0xf2, 0x10, 0xae, 0x3b, 0x6e, 0xbb, 0x37, 0xb4, 0x89, 0x39, 0xea, 0x9a,
	0x93, 0x46, 0x0a, 0x0b, 0xeb, 0x6d, 0x4d, 0x6b, 0x9e, 0x74, 0x71, 0x68, 0xb0, 0x01, 0xd9, 0xae,
	0xe5, 0x75, 0x7d, 0xa7, 0xaf, 0xc8, 0xad, 0xbc, 0x72, 0xb9, 0xd3, 0x9b, 0x96, 0xd7, 0xd5, 0xbe,
	0x86, 0x6e, 0xf0, 0x1b, 0xbd, 0x03, 0xf9, 0xa1, 0x47, 0xcc, 0x33, 0x72, 0xea, 0xd1, 0xf6, 0x47,
	0x84, 0x97, 0x8a, 0x0b, 0xb7, 0x93, 0x1b, 0x7a, 0xe4, 0x7d, 0x1f, 0x1f, 0x90, 0xdb, 0xd5, 0x2b,
	0x91, 0xdb, 0x39, 0x4c, 0x15, 0x7d, 0x7f, 0x4c, 0x75, 0x6d, 0xfe, 0x43, 0xef, 0x17, 0x06, 0xdc,
	0xf6, 0x7b, 0x93, 0x4b, 0xb9, 0xf9, 0x82, 0x0e, 0x5d, 0x3b, 0xa0, 0x49, 0x66, 0x9b, 0xda, 0xa4,
	0xb4, 0x2e, 0xd3, 0xef, 0xad, 0xcb, 0xfd, 0xab, 0x3b, 0xce, 0x01, 0xe5, 0xef, 0x0a, 0x75, 0x9f,
	0x28, 0xed, 0x50, 0x9b, 0x68, 0x22, 0xf3, 0x89, 0xe4, 0xa6, 0x37, 0xdb, 0x97, 0x03, 0xcb, 0x9f,
	0x1a, 0x90, 0x9d, 0x28, 0x38, 0x74, 0x43, 0xd0, 0x51, 0x51, 0xad, 0xd4, 0xd5, 0x6f, 0xf4, 0xb4,
	0x1c, 0x1f, 0xba, 0xe8, 0x09, 0x64, 0xdd, 0x61, 0xdf, 0x14, 0x43, 0x87, 0x78, 0x57, 0x21, 0x2b,
	0x18, 0xdc, 0x61, 0x1f, 0x2b, 0x3c, 0x7a, 0x0a, 0x2b, 0x03, 0xc2, 0x4c, 0x61, 0xdb, 0x6f, 0x25,
	0xf1, 0xab, 0xb5, 0x92, 0xfc, 0x80, 0xb0, 0x16, 0x1b, 0xb7, 0x94, 0x56, 0xf9, 0xa7, 0xb0, 0x36,
	0xa3, 0x9e, 0xd1, 0xdd, 0xa9, 0xab, 0x60, 0x92, 0x68, 0x05, 0x77, 0xc2, 0x6d, 0xc8, 0x4e, 0x50,
	0x39, 0x7d, 0x8d, 0x42, 0xc8, 0xe1, 0xca, 0xdf, 0xc4, 0x01, 0xc2, 0xc4, 0x45, 0x0d, 0x48, 0xe9,
	0xbb, 0x43, 0xbd, 0x06, 0x5e, 0xbf, 0x4a, 0xba, 0xeb, 0x1c, 0x12, 0xcc, 0x49, 0x29, 0x0b, 0x33,
	0x6d, 0x4a, 0x3f, 0x72, 0xfc, 0x87, 0xc1, 0xd5, 0xcc, 0xec, 0x48, 0x15, 0x61, 0x46, 0x29, 0xa3,
	0x01, 0x5c, 0x6b, 0x53, 0xd7, 0x25, 0x12, 0x69, 0x0e, 0x18, 0x1d, 0x10, 0xc6, 0x1d, 0xe2, 0x5f,
	0x56, 0x6f, 0x5f, 0xd1, 0xaa, 0x6f, 0xe1, 0x28, 0x30, 0xd0, 0x5c, 0xc2, 0xeb, 0xed, 0x19, 0xf2,
	0xf2, 0x23, 0x48, 0xe9, 0x4b, 0xf2, 0x1e, 0x64, 0xd5, 0x61, 0xcc, 0xd9, 0x5c, 0x16, 0xd4, 0xec,
	0x81, 0xd5, 0x27, 0xe5, 0x9f, 0x40, 0x4a, 0xed, 0x7d, 0x11, 0xf5, 0x7d, 0x00, 0x71, 0xce, 0x7b,
	0xc1, 0x6b, 0x69, 0x41, 0x1e, 0x08, 0x6c, 0xf9, 0x21, 0xac, 0xcf, 0x3a, 0x01, 0xba, 0x09, 0x19,
	0x8f, 0x0e, 0x59, 0x9b, 0x98, 0xce, 0x40, 0x2e, 0xb7, 0x8c, 0x97, 0x95, 0xe0, 0xd9, 0xa0, 0x7e,
	0x03, 0x8a, 0xaa, 0x6b, 0x5d, 0x24, 0x63, 0x0d, 0xb8, 0x39, 0xa7, 0x90, 0xd0, 0x06, 0xac, 0x1d,
	0x37, 0xf0, 0xc9, 0xb3, 0x9d, 0x86, 0xf9, 0xfc, 0xa0, 0x76, 0x52, 0x7b, 0xb6, 0x57, 0xab, 0xef,
	0x89, 0xc7, 0x64, 0x1e, 0x32, 0x07, 0x87, 0x2d, 0xf3, 0xdd, 0xc3, 0xe7, 0x07, 0xbb, 0x45, 0xa3,
	0x5e, 0x86, 0x55, 0xbf, 0xa0, 0xa7, 0x97, 0xa8, 0x97, 0xe0, 0xfa, 0xe4, 0x0d, 0x1c, 0x02, 0x2a,
	0x7f, 0x88, 0x41, 0x21, 0xfa, 0xbe, 0x13, 0x2c, 0x4e, 0x83, 0xf5, 0xa3, 0x50, 0x55, 0x61, 0x4e,
	0xdd, 0xeb, 0xfa, 0xe1, 0x77, 0x17, 0xf2, 0x92, 0x5a, 0x06, 0x20, 0xcd, 0x07, 0x85, 0x30, 0x00,
	0x9d, 0x42, 0x3e, 0xda, 0x51, 0xe2, 0xb2, 0xa3, 0x3c, 0x98, 0xf7, 0xbc, 0x0c, 0x86, 0x97, 0x76,
	0x93, 0x1c, 0x9b, 0x98, 0xa9, 0x9c, 0xc1, 0xfa, 0x2c, 0x0d, 0x74, 0x0d, 0x56, 0xf7, 0x0f, 0x4f,
	0x1a, 0xbb, 0xe6, 0x51, 0x03, 0xef, 0xd7, 0x0e, 0x1a, 0x07, 0xad, 0xbd, 0x0f, 0x8b, 0x4b, 0x28,
	0x03, 0x49, 0xed, 0x30, 0xe1, 0xbf, 0xe3, 0x46, 0xc3, 0x3c, 0x6c, 0x35, 0x1b, 0xb8, 0x18, 0x43,
	0xd7, 0x01, 0xb5, 0x1a, 0xfb, 0x47, 0x87, 0xb8, 0x86, 0x3f, 0x34, 0x71, 0x63, 0xf7, 0x19, 0x6e,
	0xec, 0xb4, 0x8a, 0x71, 0x21, 0x0f, 0x4c, 0x84, 0xf2, 0x44, 0xe5, 0x67, 0xb0, 0x3e, 0xeb, 0xdd,
	0x88, 0x5e, 0x81, 0x94, 0xc7, 0x2d, 0x3e, 0xf4, 0xa4, 0xdf, 0xf2, 0xf5, 0x9c, 0xd8, 0x7a, 0xfa,
	0x5e, 0xb2, 0xf8, 0xf7, 0xc4, 0xa6, 0x8d, 0xf5, 0x9c, 0xb8, 0x42, 0x4e, 0xa9, 0x3d, 0xd6, 0x89,
	0x37, 0x75, 0x85, 0xec, 0x5a, 0xdc, 0x3a, 0x96, 0x99, 0x83, 0x25, 0xaa, 0xf2, 0x08, 0x32, 0xc1,
	0x9b, 0x18, 0xbd, 0x06, 0x19, 0x91, 0x73, 0x32, 0x2f, 0x2f, 0xa6, 0x75, 0x38, 0x57, 0xf9, 0xa5,
	0x01, 0x85, 0xe8, 0x77, 0x23, 0xd1, 0xa2, 0x06, 0x16, 0xe7, 0x84, 0xcd, 0xd0, 0xf4, 0x67, 0x82,
	0x92, 0x89, 0xcd, 0x2e, 0x99, 0x87, 0x90, 0x52, 0x8f, 0x00, 0x1d, 0xce, 0xe9, 0x27, 0x91, 0xee,
	0x8c, 0x12, 0x82, 0x35, 0xb4, 0xf2, 0xbb, 0x0c, 0x64, 0x82, 0x9b, 0x1c, 0x3d, 0x81, 0xa4, 0xc7,
	0x05, 0xb5, 0x37, 0xbe, 0xcd, 0x7b, 0x13, 0xb0, 0xd2, 0x12, 0x3d, 0xd4, 0x76, 0x3c, 0xc1, 0xc7,
	0x27, 0x7b, 0xa8, 0x16, 0xbd, 0x47, 0xc6, 0x68, 0x17, 0xd2, 0xea, 0xa5, 0xee, 0x7f, 0xd3, 0xbb,
	0x75, 0x09, 0x5f, 0xa9, 0xaa, 0xa0, 0x45, 0x3f, 0x0c, 0x6a, 0xd5, 0xf2, 0xbf, 0xd3, 0x90, 0xd2,
	0x41, 0x7d, 0x0e, 0x05, 0x5d, 0xdb, 0x93, 0x1d, 0x3e, 0x3b, 0xfd, 0xe5, 0x6f, 0xda, 0x6e, 0x55,
	0x45, 0x31, 0x24, 0xeb, 0x79, 0x6f, 0x52, 0x80, 0x6c, 0x58, 0xb3, 0x89, 0xc7, 0x1d, 0x57, 0x06,
	0x2c, 0xb0, 0xad, 0x92, 0xe2, 0xc1, 0x02, 0xdb, 0xbb, 0xa1, 0x66, 0xb8, 0x00, 0xb2, 0x2f, 0x48,
	0xd1, 0x07, 0xb0, 0x32, 0xc5, 0x0b, 0x75, 0xbb, 0x7e, 0x63, 0xc1, 0x0a, 0x38, 0x42, 0x07, 0x9b,
	0x4b, 0xb8, 0x10, 0x25, 0x88, 0xc2, 0x2d, 0x82, 0x6e, 0x70, 0x22, 0xd8, 0x0c, 0x23, 0x9e, 0xa7,
	0x5f, 0x1a, 0xf7, 0x17, 0x1a, 0x16, 0x4a, 0x35, 0xa5, 0x23, 0xdc, 0xc2, 0x26, 0x05, 0x68, 0x0f,
	0xb2, 0x1d, 0xe2, 0x12, 0xe6, 0xb4, 0x65, 0x7c, 0xd5, 0xcb, 0xfb, 0xff, 0x17, 0xd8, 0x7c, 0xaa,
	0x34, 0xde, 0x23, 0xe3, 0xe6, 0x12, 0x86, 0x4e, 0x30, 0x42, 0x26, 0x20, 0x7d, 0x6f, 0x8c, 0x44,
	0x3e, 0xe9, 0x27, 0x91, 0x7a, 0x31, 0x6e, 0x2d, 0x30, 0x3a, 0xc1, 0xc5, 0xe4, 0xe3, 0x48, 0xbc,
	0xb7, 0xba, 0x53, 0xb2, 0xf2, 0x0a, 0xe4, 0x23, 0x71, 0x2e, 0xaf, 0x03, 0xba, 0x18, 0x9c, 0xb2,
	0x2b, 0x3a, 0x6d, 0xc4, 0x7d, 0xdf, 0xe2, 0x46, 0x43, 0x6f, 0x42, 0xc1, 0x26, 0x5e, 0x9b, 0x39,
	0x03, 0x4e, 0x59, 0x98, 0xf6, 0x93, 0xf0, 0x7c, 0x08, 0x10, 0x44, 0x62, 0x05, 0xf2, 0x11, 0x3f,
	0x97, 0xeb, 0x00, 0xa1, 0x93, 0xd0, 0x23, 0x28, 0x4e, 0x18, 0x94, 0xae, 0xb9, 0xb8, 0x83, 0x95,
	0x10, 0x22, 0x0f, 0x5c, 0xfe, 0x8b, 0x01, 0xc5, 0x69, 0xa7, 0xfc, 0x77, 0xa6, 0xd0, 0x13, 0xc8,
	0x91, 0xf3, 0x01, 0x69, 0x73, 0x1d, 0x91, 0xd8, 0x42, 0x16, 0x9e, 0x55, 0x78, 0xb5, 0x68, 0x2d,
	0xfc, 0xc6, 0x12, 0x5f, 0xf8, 0x8d, 0x25, 0x5a, 0xe0, 0x5a, 0x4f, 0x5c, 0xca, 0xaa, 0xd6, 0x2f,
	0x5e, 0xca, 0x23, 0xc8, 0x47, 0x0c, 0x2c, 0xe2, 0x11, 0xeb, 0x90, 0x54, 0xe7, 0x56, 0xcd, 0x48,
	0x0d, 0xd0, 0x9b, 0x93, 0x5f, 0xa6, 0xe6, 0x9f, 0x4d, 0x01, 0x2b, 0x3f, 0x87, 0x6b, 0x33, 0x3f,
	0xee, 0x5c, 0x79, 0xfd, 0xf8, 0xcc, 0xf5, 0x13, 0x57, 0x5c, 0x7f, 0xfb, 0x4b, 0x03, 0xae, 0x49,
	0xda, 0xb6, 0xeb, 0xff, 0x6b, 0xef, 0x98, 0xb0, 0x91, 0xd3, 0x26, 0xe8, 0x39, 0xe4, 0x8e, 0x39,
	0x23, 0x56, 0x1f, 0xab, 0xff, 0x84, 0xdc, 0x9a, 0xfe, 0x86, 0xaa, 0xf1, 0x3a, 0xc7, 0xcb, 0xb7,
	0x2f, 0x9d, 0x57, 0xd7, 0x65, 0x65, 0x69, 0xd3, 0x78, 0xd3, 0x40, 0x14, 0xb2, 0xef, 0x12, 0xde,
	0xee, 0xfe, 0xaf, 0xac, 0xde, 0xfe, 0xe4, 0x6f, 0xff, 0xfa, 0x4d, 0xec, 0x46, 0x65, 0x7d, 0x6b,
	0xb4, 0x1d, 0xfe, 0x7f, 0xf2, 0xb1, 0xfa, 0xf7, 0xcd, 0x63, 0xe3, 0x5e, 0x3d, 0xf7, 0xe7, 0xaf,
	0x6e, 0x19, 0x5f, 0x7c, 0x75, 0xcb, 0xf8, 0xe7, 0x57, 0xb7, 0x8c, 0xd3, 0x94, 0x74, 0xc5, 0xc3,
	0xff, 0x04, 0x00, 0x00, 0xff, 0xff, 0xb7, 0xcf, 0xaa, 0x91, 0x0c, 0x1d, 0x00, 0x00,
}
