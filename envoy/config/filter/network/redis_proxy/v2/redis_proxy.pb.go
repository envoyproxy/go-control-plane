// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.10
// 	protoc        v5.29.3
// source: envoy/config/filter/network/redis_proxy/v2/redis_proxy.proto

package redis_proxyv2

import (
	_ "github.com/cncf/xds/go/udpa/annotations"
	_ "github.com/envoyproxy/go-control-plane/envoy/annotations"
	core "github.com/envoyproxy/go-control-plane/envoy/api/v2/core"
	_ "github.com/envoyproxy/protoc-gen-validate/validate"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	wrapperspb "google.golang.org/protobuf/types/known/wrapperspb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// ReadPolicy controls how Envoy routes read commands to Redis nodes. This is currently
// supported for Redis Cluster. All ReadPolicy settings except MASTER may return stale data
// because replication is asynchronous and requires some delay. You need to ensure that your
// application can tolerate stale data.
type RedisProxy_ConnPoolSettings_ReadPolicy int32

const (
	// Default mode. Read from the current primary node.
	RedisProxy_ConnPoolSettings_MASTER RedisProxy_ConnPoolSettings_ReadPolicy = 0
	// Read from the primary, but if it is unavailable, read from replica nodes.
	RedisProxy_ConnPoolSettings_PREFER_MASTER RedisProxy_ConnPoolSettings_ReadPolicy = 1
	// Read from replica nodes. If multiple replica nodes are present within a shard, a random
	// node is selected. Healthy nodes have precedent over unhealthy nodes.
	RedisProxy_ConnPoolSettings_REPLICA RedisProxy_ConnPoolSettings_ReadPolicy = 2
	// Read from the replica nodes (similar to REPLICA), but if all replicas are unavailable (not
	// present or unhealthy), read from the primary.
	RedisProxy_ConnPoolSettings_PREFER_REPLICA RedisProxy_ConnPoolSettings_ReadPolicy = 3
	// Read from any node of the cluster. A random node is selected among the primary and
	// replicas, healthy nodes have precedent over unhealthy nodes.
	RedisProxy_ConnPoolSettings_ANY RedisProxy_ConnPoolSettings_ReadPolicy = 4
)

// Enum value maps for RedisProxy_ConnPoolSettings_ReadPolicy.
var (
	RedisProxy_ConnPoolSettings_ReadPolicy_name = map[int32]string{
		0: "MASTER",
		1: "PREFER_MASTER",
		2: "REPLICA",
		3: "PREFER_REPLICA",
		4: "ANY",
	}
	RedisProxy_ConnPoolSettings_ReadPolicy_value = map[string]int32{
		"MASTER":         0,
		"PREFER_MASTER":  1,
		"REPLICA":        2,
		"PREFER_REPLICA": 3,
		"ANY":            4,
	}
)

func (x RedisProxy_ConnPoolSettings_ReadPolicy) Enum() *RedisProxy_ConnPoolSettings_ReadPolicy {
	p := new(RedisProxy_ConnPoolSettings_ReadPolicy)
	*p = x
	return p
}

func (x RedisProxy_ConnPoolSettings_ReadPolicy) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (RedisProxy_ConnPoolSettings_ReadPolicy) Descriptor() protoreflect.EnumDescriptor {
	return file_envoy_config_filter_network_redis_proxy_v2_redis_proxy_proto_enumTypes[0].Descriptor()
}

func (RedisProxy_ConnPoolSettings_ReadPolicy) Type() protoreflect.EnumType {
	return &file_envoy_config_filter_network_redis_proxy_v2_redis_proxy_proto_enumTypes[0]
}

func (x RedisProxy_ConnPoolSettings_ReadPolicy) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use RedisProxy_ConnPoolSettings_ReadPolicy.Descriptor instead.
func (RedisProxy_ConnPoolSettings_ReadPolicy) EnumDescriptor() ([]byte, []int) {
	return file_envoy_config_filter_network_redis_proxy_v2_redis_proxy_proto_rawDescGZIP(), []int{0, 0, 0}
}

// [#next-free-field: 7]
type RedisProxy struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The prefix to use when emitting :ref:`statistics <config_network_filters_redis_proxy_stats>`.
	StatPrefix string `protobuf:"bytes,1,opt,name=stat_prefix,json=statPrefix,proto3" json:"stat_prefix,omitempty"`
	// Name of cluster from cluster manager. See the :ref:`configuration section
	// <arch_overview_redis_configuration>` of the architecture overview for recommendations on
	// configuring the backing cluster.
	//
	// .. attention::
	//
	//	This field is deprecated. Use a :ref:`catch_all
	//	route<envoy_api_field_config.filter.network.redis_proxy.v2.RedisProxy.PrefixRoutes.catch_all_route>`
	//	instead.
	//
	// Deprecated: Marked as deprecated in envoy/config/filter/network/redis_proxy/v2/redis_proxy.proto.
	Cluster string `protobuf:"bytes,2,opt,name=cluster,proto3" json:"cluster,omitempty"`
	// Network settings for the connection pool to the upstream clusters.
	Settings *RedisProxy_ConnPoolSettings `protobuf:"bytes,3,opt,name=settings,proto3" json:"settings,omitempty"`
	// Indicates that latency stat should be computed in microseconds. By default it is computed in
	// milliseconds.
	LatencyInMicros bool `protobuf:"varint,4,opt,name=latency_in_micros,json=latencyInMicros,proto3" json:"latency_in_micros,omitempty"`
	// List of **unique** prefixes used to separate keys from different workloads to different
	// clusters. Envoy will always favor the longest match first in case of overlap. A catch-all
	// cluster can be used to forward commands when there is no match. Time complexity of the
	// lookups are in O(min(longest key prefix, key length)).
	//
	// Example:
	//
	// .. code-block:: yaml
	//
	//	prefix_routes:
	//	  routes:
	//	    - prefix: "ab"
	//	      cluster: "cluster_a"
	//	    - prefix: "abc"
	//	      cluster: "cluster_b"
	//
	// When using the above routes, the following prefixes would be sent to:
	//
	//   - “get abc:users“ would retrieve the key 'abc:users' from cluster_b.
	//   - “get ab:users“ would retrieve the key 'ab:users' from cluster_a.
	//   - “get z:users“ would return a NoUpstreamHost error. A :ref:`catch-all
	//     route<envoy_api_field_config.filter.network.redis_proxy.v2.RedisProxy.PrefixRoutes.catch_all_route>`
	//     would have retrieved the key from that cluster instead.
	//
	// See the :ref:`configuration section
	// <arch_overview_redis_configuration>` of the architecture overview for recommendations on
	// configuring the backing clusters.
	PrefixRoutes *RedisProxy_PrefixRoutes `protobuf:"bytes,5,opt,name=prefix_routes,json=prefixRoutes,proto3" json:"prefix_routes,omitempty"`
	// Authenticate Redis client connections locally by forcing downstream clients to issue a `Redis
	// AUTH command <https://redis.io/commands/auth>`_ with this password before enabling any other
	// command. If an AUTH command's password matches this password, an "OK" response will be returned
	// to the client. If the AUTH command password does not match this password, then an "ERR invalid
	// password" error will be returned. If any other command is received before AUTH when this
	// password is set, then a "NOAUTH Authentication required." error response will be sent to the
	// client. If an AUTH command is received when the password is not set, then an "ERR Client sent
	// AUTH, but no password is set" error will be returned.
	DownstreamAuthPassword *core.DataSource `protobuf:"bytes,6,opt,name=downstream_auth_password,json=downstreamAuthPassword,proto3" json:"downstream_auth_password,omitempty"`
	unknownFields          protoimpl.UnknownFields
	sizeCache              protoimpl.SizeCache
}

func (x *RedisProxy) Reset() {
	*x = RedisProxy{}
	mi := &file_envoy_config_filter_network_redis_proxy_v2_redis_proxy_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RedisProxy) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RedisProxy) ProtoMessage() {}

func (x *RedisProxy) ProtoReflect() protoreflect.Message {
	mi := &file_envoy_config_filter_network_redis_proxy_v2_redis_proxy_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RedisProxy.ProtoReflect.Descriptor instead.
func (*RedisProxy) Descriptor() ([]byte, []int) {
	return file_envoy_config_filter_network_redis_proxy_v2_redis_proxy_proto_rawDescGZIP(), []int{0}
}

func (x *RedisProxy) GetStatPrefix() string {
	if x != nil {
		return x.StatPrefix
	}
	return ""
}

// Deprecated: Marked as deprecated in envoy/config/filter/network/redis_proxy/v2/redis_proxy.proto.
func (x *RedisProxy) GetCluster() string {
	if x != nil {
		return x.Cluster
	}
	return ""
}

func (x *RedisProxy) GetSettings() *RedisProxy_ConnPoolSettings {
	if x != nil {
		return x.Settings
	}
	return nil
}

func (x *RedisProxy) GetLatencyInMicros() bool {
	if x != nil {
		return x.LatencyInMicros
	}
	return false
}

func (x *RedisProxy) GetPrefixRoutes() *RedisProxy_PrefixRoutes {
	if x != nil {
		return x.PrefixRoutes
	}
	return nil
}

func (x *RedisProxy) GetDownstreamAuthPassword() *core.DataSource {
	if x != nil {
		return x.DownstreamAuthPassword
	}
	return nil
}

// RedisProtocolOptions specifies Redis upstream protocol options. This object is used in
// :ref:`typed_extension_protocol_options<envoy_api_field_Cluster.typed_extension_protocol_options>`,
// keyed by the name `envoy.filters.network.redis_proxy`.
type RedisProtocolOptions struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Upstream server password as defined by the `requirepass` directive
	// <https://redis.io/topics/config>`_ in the server's configuration file.
	AuthPassword  *core.DataSource `protobuf:"bytes,1,opt,name=auth_password,json=authPassword,proto3" json:"auth_password,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RedisProtocolOptions) Reset() {
	*x = RedisProtocolOptions{}
	mi := &file_envoy_config_filter_network_redis_proxy_v2_redis_proxy_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RedisProtocolOptions) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RedisProtocolOptions) ProtoMessage() {}

func (x *RedisProtocolOptions) ProtoReflect() protoreflect.Message {
	mi := &file_envoy_config_filter_network_redis_proxy_v2_redis_proxy_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RedisProtocolOptions.ProtoReflect.Descriptor instead.
func (*RedisProtocolOptions) Descriptor() ([]byte, []int) {
	return file_envoy_config_filter_network_redis_proxy_v2_redis_proxy_proto_rawDescGZIP(), []int{1}
}

func (x *RedisProtocolOptions) GetAuthPassword() *core.DataSource {
	if x != nil {
		return x.AuthPassword
	}
	return nil
}

// Redis connection pool settings.
// [#next-free-field: 9]
type RedisProxy_ConnPoolSettings struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Per-operation timeout in milliseconds. The timer starts when the first
	// command of a pipeline is written to the backend connection. Each response received from Redis
	// resets the timer since it signifies that the next command is being processed by the backend.
	// The only exception to this behavior is when a connection to a backend is not yet established.
	// In that case, the connect timeout on the cluster will govern the timeout until the connection
	// is ready.
	OpTimeout *durationpb.Duration `protobuf:"bytes,1,opt,name=op_timeout,json=opTimeout,proto3" json:"op_timeout,omitempty"`
	// Use hash tagging on every redis key to guarantee that keys with the same hash tag will be
	// forwarded to the same upstream. The hash key used for determining the upstream in a
	// consistent hash ring configuration will be computed from the hash tagged key instead of the
	// whole key. The algorithm used to compute the hash tag is identical to the `redis-cluster
	// implementation <https://redis.io/topics/cluster-spec#keys-hash-tags>`_.
	//
	// Examples:
	//
	// * '{user1000}.following' and '{user1000}.followers' **will** be sent to the same upstream
	// * '{user1000}.following' and '{user1001}.following' **might** be sent to the same upstream
	EnableHashtagging bool `protobuf:"varint,2,opt,name=enable_hashtagging,json=enableHashtagging,proto3" json:"enable_hashtagging,omitempty"`
	// Accept `moved and ask redirection
	// <https://redis.io/topics/cluster-spec#redirection-and-resharding>`_ errors from upstream
	// redis servers, and retry commands to the specified target server. The target server does not
	// need to be known to the cluster manager. If the command cannot be redirected, then the
	// original error is passed downstream unchanged. By default, this support is not enabled.
	EnableRedirection bool `protobuf:"varint,3,opt,name=enable_redirection,json=enableRedirection,proto3" json:"enable_redirection,omitempty"`
	// Maximum size of encoded request buffer before flush is triggered and encoded requests
	// are sent upstream. If this is unset, the buffer flushes whenever it receives data
	// and performs no batching.
	// This feature makes it possible for multiple clients to send requests to Envoy and have
	// them batched- for example if one is running several worker processes, each with its own
	// Redis connection. There is no benefit to using this with a single downstream process.
	// Recommended size (if enabled) is 1024 bytes.
	MaxBufferSizeBeforeFlush uint32 `protobuf:"varint,4,opt,name=max_buffer_size_before_flush,json=maxBufferSizeBeforeFlush,proto3" json:"max_buffer_size_before_flush,omitempty"`
	// The encoded request buffer is flushed N milliseconds after the first request has been
	// encoded, unless the buffer size has already exceeded `max_buffer_size_before_flush`.
	// If `max_buffer_size_before_flush` is not set, this flush timer is not used. Otherwise,
	// the timer should be set according to the number of clients, overall request rate and
	// desired maximum latency for a single command. For example, if there are many requests
	// being batched together at a high rate, the buffer will likely be filled before the timer
	// fires. Alternatively, if the request rate is lower the buffer will not be filled as often
	// before the timer fires.
	// If `max_buffer_size_before_flush` is set, but `buffer_flush_timeout` is not, the latter
	// defaults to 3ms.
	BufferFlushTimeout *durationpb.Duration `protobuf:"bytes,5,opt,name=buffer_flush_timeout,json=bufferFlushTimeout,proto3" json:"buffer_flush_timeout,omitempty"`
	// `max_upstream_unknown_connections` controls how many upstream connections to unknown hosts
	// can be created at any given time by any given worker thread (see `enable_redirection` for
	// more details). If the host is unknown and a connection cannot be created due to enforcing
	// this limit, then redirection will fail and the original redirection error will be passed
	// downstream unchanged. This limit defaults to 100.
	MaxUpstreamUnknownConnections *wrapperspb.UInt32Value `protobuf:"bytes,6,opt,name=max_upstream_unknown_connections,json=maxUpstreamUnknownConnections,proto3" json:"max_upstream_unknown_connections,omitempty"`
	// Enable per-command statistics per upstream cluster, in addition to the filter level aggregate
	// count.
	EnableCommandStats bool `protobuf:"varint,8,opt,name=enable_command_stats,json=enableCommandStats,proto3" json:"enable_command_stats,omitempty"`
	// Read policy. The default is to read from the primary.
	ReadPolicy    RedisProxy_ConnPoolSettings_ReadPolicy `protobuf:"varint,7,opt,name=read_policy,json=readPolicy,proto3,enum=envoy.config.filter.network.redis_proxy.v2.RedisProxy_ConnPoolSettings_ReadPolicy" json:"read_policy,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RedisProxy_ConnPoolSettings) Reset() {
	*x = RedisProxy_ConnPoolSettings{}
	mi := &file_envoy_config_filter_network_redis_proxy_v2_redis_proxy_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RedisProxy_ConnPoolSettings) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RedisProxy_ConnPoolSettings) ProtoMessage() {}

func (x *RedisProxy_ConnPoolSettings) ProtoReflect() protoreflect.Message {
	mi := &file_envoy_config_filter_network_redis_proxy_v2_redis_proxy_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RedisProxy_ConnPoolSettings.ProtoReflect.Descriptor instead.
func (*RedisProxy_ConnPoolSettings) Descriptor() ([]byte, []int) {
	return file_envoy_config_filter_network_redis_proxy_v2_redis_proxy_proto_rawDescGZIP(), []int{0, 0}
}

func (x *RedisProxy_ConnPoolSettings) GetOpTimeout() *durationpb.Duration {
	if x != nil {
		return x.OpTimeout
	}
	return nil
}

func (x *RedisProxy_ConnPoolSettings) GetEnableHashtagging() bool {
	if x != nil {
		return x.EnableHashtagging
	}
	return false
}

func (x *RedisProxy_ConnPoolSettings) GetEnableRedirection() bool {
	if x != nil {
		return x.EnableRedirection
	}
	return false
}

func (x *RedisProxy_ConnPoolSettings) GetMaxBufferSizeBeforeFlush() uint32 {
	if x != nil {
		return x.MaxBufferSizeBeforeFlush
	}
	return 0
}

func (x *RedisProxy_ConnPoolSettings) GetBufferFlushTimeout() *durationpb.Duration {
	if x != nil {
		return x.BufferFlushTimeout
	}
	return nil
}

func (x *RedisProxy_ConnPoolSettings) GetMaxUpstreamUnknownConnections() *wrapperspb.UInt32Value {
	if x != nil {
		return x.MaxUpstreamUnknownConnections
	}
	return nil
}

func (x *RedisProxy_ConnPoolSettings) GetEnableCommandStats() bool {
	if x != nil {
		return x.EnableCommandStats
	}
	return false
}

func (x *RedisProxy_ConnPoolSettings) GetReadPolicy() RedisProxy_ConnPoolSettings_ReadPolicy {
	if x != nil {
		return x.ReadPolicy
	}
	return RedisProxy_ConnPoolSettings_MASTER
}

type RedisProxy_PrefixRoutes struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// List of prefix routes.
	Routes []*RedisProxy_PrefixRoutes_Route `protobuf:"bytes,1,rep,name=routes,proto3" json:"routes,omitempty"`
	// Indicates that prefix matching should be case insensitive.
	CaseInsensitive bool `protobuf:"varint,2,opt,name=case_insensitive,json=caseInsensitive,proto3" json:"case_insensitive,omitempty"`
	// Optional catch-all route to forward commands that doesn't match any of the routes. The
	// catch-all route becomes required when no routes are specified.
	// .. attention::
	//
	//	This field is deprecated. Use a :ref:`catch_all
	//	route<envoy_api_field_config.filter.network.redis_proxy.v2.RedisProxy.PrefixRoutes.catch_all_route>`
	//	instead.
	//
	// Deprecated: Marked as deprecated in envoy/config/filter/network/redis_proxy/v2/redis_proxy.proto.
	CatchAllCluster string `protobuf:"bytes,3,opt,name=catch_all_cluster,json=catchAllCluster,proto3" json:"catch_all_cluster,omitempty"`
	// Optional catch-all route to forward commands that doesn't match any of the routes. The
	// catch-all route becomes required when no routes are specified.
	CatchAllRoute *RedisProxy_PrefixRoutes_Route `protobuf:"bytes,4,opt,name=catch_all_route,json=catchAllRoute,proto3" json:"catch_all_route,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RedisProxy_PrefixRoutes) Reset() {
	*x = RedisProxy_PrefixRoutes{}
	mi := &file_envoy_config_filter_network_redis_proxy_v2_redis_proxy_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RedisProxy_PrefixRoutes) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RedisProxy_PrefixRoutes) ProtoMessage() {}

func (x *RedisProxy_PrefixRoutes) ProtoReflect() protoreflect.Message {
	mi := &file_envoy_config_filter_network_redis_proxy_v2_redis_proxy_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RedisProxy_PrefixRoutes.ProtoReflect.Descriptor instead.
func (*RedisProxy_PrefixRoutes) Descriptor() ([]byte, []int) {
	return file_envoy_config_filter_network_redis_proxy_v2_redis_proxy_proto_rawDescGZIP(), []int{0, 1}
}

func (x *RedisProxy_PrefixRoutes) GetRoutes() []*RedisProxy_PrefixRoutes_Route {
	if x != nil {
		return x.Routes
	}
	return nil
}

func (x *RedisProxy_PrefixRoutes) GetCaseInsensitive() bool {
	if x != nil {
		return x.CaseInsensitive
	}
	return false
}

// Deprecated: Marked as deprecated in envoy/config/filter/network/redis_proxy/v2/redis_proxy.proto.
func (x *RedisProxy_PrefixRoutes) GetCatchAllCluster() string {
	if x != nil {
		return x.CatchAllCluster
	}
	return ""
}

func (x *RedisProxy_PrefixRoutes) GetCatchAllRoute() *RedisProxy_PrefixRoutes_Route {
	if x != nil {
		return x.CatchAllRoute
	}
	return nil
}

type RedisProxy_PrefixRoutes_Route struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// String prefix that must match the beginning of the keys. Envoy will always favor the
	// longest match.
	Prefix string `protobuf:"bytes,1,opt,name=prefix,proto3" json:"prefix,omitempty"`
	// Indicates if the prefix needs to be removed from the key when forwarded.
	RemovePrefix bool `protobuf:"varint,2,opt,name=remove_prefix,json=removePrefix,proto3" json:"remove_prefix,omitempty"`
	// Upstream cluster to forward the command to.
	Cluster string `protobuf:"bytes,3,opt,name=cluster,proto3" json:"cluster,omitempty"`
	// Indicates that the route has a request mirroring policy.
	RequestMirrorPolicy []*RedisProxy_PrefixRoutes_Route_RequestMirrorPolicy `protobuf:"bytes,4,rep,name=request_mirror_policy,json=requestMirrorPolicy,proto3" json:"request_mirror_policy,omitempty"`
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *RedisProxy_PrefixRoutes_Route) Reset() {
	*x = RedisProxy_PrefixRoutes_Route{}
	mi := &file_envoy_config_filter_network_redis_proxy_v2_redis_proxy_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RedisProxy_PrefixRoutes_Route) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RedisProxy_PrefixRoutes_Route) ProtoMessage() {}

func (x *RedisProxy_PrefixRoutes_Route) ProtoReflect() protoreflect.Message {
	mi := &file_envoy_config_filter_network_redis_proxy_v2_redis_proxy_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RedisProxy_PrefixRoutes_Route.ProtoReflect.Descriptor instead.
func (*RedisProxy_PrefixRoutes_Route) Descriptor() ([]byte, []int) {
	return file_envoy_config_filter_network_redis_proxy_v2_redis_proxy_proto_rawDescGZIP(), []int{0, 1, 0}
}

func (x *RedisProxy_PrefixRoutes_Route) GetPrefix() string {
	if x != nil {
		return x.Prefix
	}
	return ""
}

func (x *RedisProxy_PrefixRoutes_Route) GetRemovePrefix() bool {
	if x != nil {
		return x.RemovePrefix
	}
	return false
}

func (x *RedisProxy_PrefixRoutes_Route) GetCluster() string {
	if x != nil {
		return x.Cluster
	}
	return ""
}

func (x *RedisProxy_PrefixRoutes_Route) GetRequestMirrorPolicy() []*RedisProxy_PrefixRoutes_Route_RequestMirrorPolicy {
	if x != nil {
		return x.RequestMirrorPolicy
	}
	return nil
}

// The router is capable of shadowing traffic from one cluster to another. The current
// implementation is "fire and forget," meaning Envoy will not wait for the shadow cluster to
// respond before returning the response from the primary cluster. All normal statistics are
// collected for the shadow cluster making this feature useful for testing.
type RedisProxy_PrefixRoutes_Route_RequestMirrorPolicy struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Specifies the cluster that requests will be mirrored to. The cluster must
	// exist in the cluster manager configuration.
	Cluster string `protobuf:"bytes,1,opt,name=cluster,proto3" json:"cluster,omitempty"`
	// If not specified or the runtime key is not present, all requests to the target cluster
	// will be mirrored.
	//
	// If specified, Envoy will lookup the runtime key to get the percentage of requests to the
	// mirror.
	RuntimeFraction *core.RuntimeFractionalPercent `protobuf:"bytes,2,opt,name=runtime_fraction,json=runtimeFraction,proto3" json:"runtime_fraction,omitempty"`
	// Set this to TRUE to only mirror write commands, this is effectively replicating the
	// writes in a "fire and forget" manner.
	ExcludeReadCommands bool `protobuf:"varint,3,opt,name=exclude_read_commands,json=excludeReadCommands,proto3" json:"exclude_read_commands,omitempty"`
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *RedisProxy_PrefixRoutes_Route_RequestMirrorPolicy) Reset() {
	*x = RedisProxy_PrefixRoutes_Route_RequestMirrorPolicy{}
	mi := &file_envoy_config_filter_network_redis_proxy_v2_redis_proxy_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RedisProxy_PrefixRoutes_Route_RequestMirrorPolicy) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RedisProxy_PrefixRoutes_Route_RequestMirrorPolicy) ProtoMessage() {}

func (x *RedisProxy_PrefixRoutes_Route_RequestMirrorPolicy) ProtoReflect() protoreflect.Message {
	mi := &file_envoy_config_filter_network_redis_proxy_v2_redis_proxy_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RedisProxy_PrefixRoutes_Route_RequestMirrorPolicy.ProtoReflect.Descriptor instead.
func (*RedisProxy_PrefixRoutes_Route_RequestMirrorPolicy) Descriptor() ([]byte, []int) {
	return file_envoy_config_filter_network_redis_proxy_v2_redis_proxy_proto_rawDescGZIP(), []int{0, 1, 0, 0}
}

func (x *RedisProxy_PrefixRoutes_Route_RequestMirrorPolicy) GetCluster() string {
	if x != nil {
		return x.Cluster
	}
	return ""
}

func (x *RedisProxy_PrefixRoutes_Route_RequestMirrorPolicy) GetRuntimeFraction() *core.RuntimeFractionalPercent {
	if x != nil {
		return x.RuntimeFraction
	}
	return nil
}

func (x *RedisProxy_PrefixRoutes_Route_RequestMirrorPolicy) GetExcludeReadCommands() bool {
	if x != nil {
		return x.ExcludeReadCommands
	}
	return false
}

var File_envoy_config_filter_network_redis_proxy_v2_redis_proxy_proto protoreflect.FileDescriptor

const file_envoy_config_filter_network_redis_proxy_v2_redis_proxy_proto_rawDesc = "" +
	"\n" +
	"<envoy/config/filter/network/redis_proxy/v2/redis_proxy.proto\x12*envoy.config.filter.network.redis_proxy.v2\x1a\x1cenvoy/api/v2/core/base.proto\x1a\x1egoogle/protobuf/duration.proto\x1a\x1egoogle/protobuf/wrappers.proto\x1a#envoy/annotations/deprecation.proto\x1a\x1eudpa/annotations/migrate.proto\x1a udpa/annotations/sensitive.proto\x1a\x1dudpa/annotations/status.proto\x1a\x17validate/validate.proto\"\x80\x0f\n" +
	"\n" +
	"RedisProxy\x12(\n" +
	"\vstat_prefix\x18\x01 \x01(\tB\a\xfaB\x04r\x02 \x01R\n" +
	"statPrefix\x12\"\n" +
	"\acluster\x18\x02 \x01(\tB\b\xb8\xee\xf2\xd2\x05\x01\x18\x01R\acluster\x12m\n" +
	"\bsettings\x18\x03 \x01(\v2G.envoy.config.filter.network.redis_proxy.v2.RedisProxy.ConnPoolSettingsB\b\xfaB\x05\x8a\x01\x02\x10\x01R\bsettings\x12*\n" +
	"\x11latency_in_micros\x18\x04 \x01(\bR\x0flatencyInMicros\x12h\n" +
	"\rprefix_routes\x18\x05 \x01(\v2C.envoy.config.filter.network.redis_proxy.v2.RedisProxy.PrefixRoutesR\fprefixRoutes\x12_\n" +
	"\x18downstream_auth_password\x18\x06 \x01(\v2\x1d.envoy.api.v2.core.DataSourceB\x06\xb8\xb7\x8b\xa4\x02\x01R\x16downstreamAuthPassword\x1a\xb0\x05\n" +
	"\x10ConnPoolSettings\x12B\n" +
	"\n" +
	"op_timeout\x18\x01 \x01(\v2\x19.google.protobuf.DurationB\b\xfaB\x05\xaa\x01\x02\b\x01R\topTimeout\x12-\n" +
	"\x12enable_hashtagging\x18\x02 \x01(\bR\x11enableHashtagging\x12-\n" +
	"\x12enable_redirection\x18\x03 \x01(\bR\x11enableRedirection\x12>\n" +
	"\x1cmax_buffer_size_before_flush\x18\x04 \x01(\rR\x18maxBufferSizeBeforeFlush\x12K\n" +
	"\x14buffer_flush_timeout\x18\x05 \x01(\v2\x19.google.protobuf.DurationR\x12bufferFlushTimeout\x12e\n" +
	" max_upstream_unknown_connections\x18\x06 \x01(\v2\x1c.google.protobuf.UInt32ValueR\x1dmaxUpstreamUnknownConnections\x120\n" +
	"\x14enable_command_stats\x18\b \x01(\bR\x12enableCommandStats\x12}\n" +
	"\vread_policy\x18\a \x01(\x0e2R.envoy.config.filter.network.redis_proxy.v2.RedisProxy.ConnPoolSettings.ReadPolicyB\b\xfaB\x05\x82\x01\x02\x10\x01R\n" +
	"readPolicy\"U\n" +
	"\n" +
	"ReadPolicy\x12\n" +
	"\n" +
	"\x06MASTER\x10\x00\x12\x11\n" +
	"\rPREFER_MASTER\x10\x01\x12\v\n" +
	"\aREPLICA\x10\x02\x12\x12\n" +
	"\x0ePREFER_REPLICA\x10\x03\x12\a\n" +
	"\x03ANY\x10\x04\x1a\x8a\x06\n" +
	"\fPrefixRoutes\x12a\n" +
	"\x06routes\x18\x01 \x03(\v2I.envoy.config.filter.network.redis_proxy.v2.RedisProxy.PrefixRoutes.RouteR\x06routes\x12)\n" +
	"\x10case_insensitive\x18\x02 \x01(\bR\x0fcaseInsensitive\x124\n" +
	"\x11catch_all_cluster\x18\x03 \x01(\tB\b\xb8\xee\xf2\xd2\x05\x01\x18\x01R\x0fcatchAllCluster\x12q\n" +
	"\x0fcatch_all_route\x18\x04 \x01(\v2I.envoy.config.filter.network.redis_proxy.v2.RedisProxy.PrefixRoutes.RouteR\rcatchAllRoute\x1a\xc2\x03\n" +
	"\x05Route\x12\x16\n" +
	"\x06prefix\x18\x01 \x01(\tR\x06prefix\x12#\n" +
	"\rremove_prefix\x18\x02 \x01(\bR\fremovePrefix\x12!\n" +
	"\acluster\x18\x03 \x01(\tB\a\xfaB\x04r\x02 \x01R\acluster\x12\x91\x01\n" +
	"\x15request_mirror_policy\x18\x04 \x03(\v2].envoy.config.filter.network.redis_proxy.v2.RedisProxy.PrefixRoutes.Route.RequestMirrorPolicyR\x13requestMirrorPolicy\x1a\xc4\x01\n" +
	"\x13RequestMirrorPolicy\x12!\n" +
	"\acluster\x18\x01 \x01(\tB\a\xfaB\x04r\x02 \x01R\acluster\x12V\n" +
	"\x10runtime_fraction\x18\x02 \x01(\v2+.envoy.api.v2.core.RuntimeFractionalPercentR\x0fruntimeFraction\x122\n" +
	"\x15exclude_read_commands\x18\x03 \x01(\bR\x13excludeReadCommands\"b\n" +
	"\x14RedisProtocolOptions\x12J\n" +
	"\rauth_password\x18\x01 \x01(\v2\x1d.envoy.api.v2.core.DataSourceB\x06\xb8\xb7\x8b\xa4\x02\x01R\fauthPasswordB\xed\x01\xf2\x98\xfe\x8f\x051\x12/envoy.extensions.filters.network.redis_proxy.v3\xba\x80\xc8\xd1\x06\x02\x10\x01\n" +
	"8io.envoyproxy.envoy.config.filter.network.redis_proxy.v2B\x0fRedisProxyProtoP\x01Z_github.com/envoyproxy/go-control-plane/envoy/config/filter/network/redis_proxy/v2;redis_proxyv2b\x06proto3"

var (
	file_envoy_config_filter_network_redis_proxy_v2_redis_proxy_proto_rawDescOnce sync.Once
	file_envoy_config_filter_network_redis_proxy_v2_redis_proxy_proto_rawDescData []byte
)

func file_envoy_config_filter_network_redis_proxy_v2_redis_proxy_proto_rawDescGZIP() []byte {
	file_envoy_config_filter_network_redis_proxy_v2_redis_proxy_proto_rawDescOnce.Do(func() {
		file_envoy_config_filter_network_redis_proxy_v2_redis_proxy_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_envoy_config_filter_network_redis_proxy_v2_redis_proxy_proto_rawDesc), len(file_envoy_config_filter_network_redis_proxy_v2_redis_proxy_proto_rawDesc)))
	})
	return file_envoy_config_filter_network_redis_proxy_v2_redis_proxy_proto_rawDescData
}

var file_envoy_config_filter_network_redis_proxy_v2_redis_proxy_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_envoy_config_filter_network_redis_proxy_v2_redis_proxy_proto_msgTypes = make([]protoimpl.MessageInfo, 6)
var file_envoy_config_filter_network_redis_proxy_v2_redis_proxy_proto_goTypes = []any{
	(RedisProxy_ConnPoolSettings_ReadPolicy)(0),               // 0: envoy.config.filter.network.redis_proxy.v2.RedisProxy.ConnPoolSettings.ReadPolicy
	(*RedisProxy)(nil),                                        // 1: envoy.config.filter.network.redis_proxy.v2.RedisProxy
	(*RedisProtocolOptions)(nil),                              // 2: envoy.config.filter.network.redis_proxy.v2.RedisProtocolOptions
	(*RedisProxy_ConnPoolSettings)(nil),                       // 3: envoy.config.filter.network.redis_proxy.v2.RedisProxy.ConnPoolSettings
	(*RedisProxy_PrefixRoutes)(nil),                           // 4: envoy.config.filter.network.redis_proxy.v2.RedisProxy.PrefixRoutes
	(*RedisProxy_PrefixRoutes_Route)(nil),                     // 5: envoy.config.filter.network.redis_proxy.v2.RedisProxy.PrefixRoutes.Route
	(*RedisProxy_PrefixRoutes_Route_RequestMirrorPolicy)(nil), // 6: envoy.config.filter.network.redis_proxy.v2.RedisProxy.PrefixRoutes.Route.RequestMirrorPolicy
	(*core.DataSource)(nil),                                   // 7: envoy.api.v2.core.DataSource
	(*durationpb.Duration)(nil),                               // 8: google.protobuf.Duration
	(*wrapperspb.UInt32Value)(nil),                            // 9: google.protobuf.UInt32Value
	(*core.RuntimeFractionalPercent)(nil),                     // 10: envoy.api.v2.core.RuntimeFractionalPercent
}
var file_envoy_config_filter_network_redis_proxy_v2_redis_proxy_proto_depIdxs = []int32{
	3,  // 0: envoy.config.filter.network.redis_proxy.v2.RedisProxy.settings:type_name -> envoy.config.filter.network.redis_proxy.v2.RedisProxy.ConnPoolSettings
	4,  // 1: envoy.config.filter.network.redis_proxy.v2.RedisProxy.prefix_routes:type_name -> envoy.config.filter.network.redis_proxy.v2.RedisProxy.PrefixRoutes
	7,  // 2: envoy.config.filter.network.redis_proxy.v2.RedisProxy.downstream_auth_password:type_name -> envoy.api.v2.core.DataSource
	7,  // 3: envoy.config.filter.network.redis_proxy.v2.RedisProtocolOptions.auth_password:type_name -> envoy.api.v2.core.DataSource
	8,  // 4: envoy.config.filter.network.redis_proxy.v2.RedisProxy.ConnPoolSettings.op_timeout:type_name -> google.protobuf.Duration
	8,  // 5: envoy.config.filter.network.redis_proxy.v2.RedisProxy.ConnPoolSettings.buffer_flush_timeout:type_name -> google.protobuf.Duration
	9,  // 6: envoy.config.filter.network.redis_proxy.v2.RedisProxy.ConnPoolSettings.max_upstream_unknown_connections:type_name -> google.protobuf.UInt32Value
	0,  // 7: envoy.config.filter.network.redis_proxy.v2.RedisProxy.ConnPoolSettings.read_policy:type_name -> envoy.config.filter.network.redis_proxy.v2.RedisProxy.ConnPoolSettings.ReadPolicy
	5,  // 8: envoy.config.filter.network.redis_proxy.v2.RedisProxy.PrefixRoutes.routes:type_name -> envoy.config.filter.network.redis_proxy.v2.RedisProxy.PrefixRoutes.Route
	5,  // 9: envoy.config.filter.network.redis_proxy.v2.RedisProxy.PrefixRoutes.catch_all_route:type_name -> envoy.config.filter.network.redis_proxy.v2.RedisProxy.PrefixRoutes.Route
	6,  // 10: envoy.config.filter.network.redis_proxy.v2.RedisProxy.PrefixRoutes.Route.request_mirror_policy:type_name -> envoy.config.filter.network.redis_proxy.v2.RedisProxy.PrefixRoutes.Route.RequestMirrorPolicy
	10, // 11: envoy.config.filter.network.redis_proxy.v2.RedisProxy.PrefixRoutes.Route.RequestMirrorPolicy.runtime_fraction:type_name -> envoy.api.v2.core.RuntimeFractionalPercent
	12, // [12:12] is the sub-list for method output_type
	12, // [12:12] is the sub-list for method input_type
	12, // [12:12] is the sub-list for extension type_name
	12, // [12:12] is the sub-list for extension extendee
	0,  // [0:12] is the sub-list for field type_name
}

func init() { file_envoy_config_filter_network_redis_proxy_v2_redis_proxy_proto_init() }
func file_envoy_config_filter_network_redis_proxy_v2_redis_proxy_proto_init() {
	if File_envoy_config_filter_network_redis_proxy_v2_redis_proxy_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_envoy_config_filter_network_redis_proxy_v2_redis_proxy_proto_rawDesc), len(file_envoy_config_filter_network_redis_proxy_v2_redis_proxy_proto_rawDesc)),
			NumEnums:      1,
			NumMessages:   6,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_envoy_config_filter_network_redis_proxy_v2_redis_proxy_proto_goTypes,
		DependencyIndexes: file_envoy_config_filter_network_redis_proxy_v2_redis_proxy_proto_depIdxs,
		EnumInfos:         file_envoy_config_filter_network_redis_proxy_v2_redis_proxy_proto_enumTypes,
		MessageInfos:      file_envoy_config_filter_network_redis_proxy_v2_redis_proxy_proto_msgTypes,
	}.Build()
	File_envoy_config_filter_network_redis_proxy_v2_redis_proxy_proto = out.File
	file_envoy_config_filter_network_redis_proxy_v2_redis_proxy_proto_goTypes = nil
	file_envoy_config_filter_network_redis_proxy_v2_redis_proxy_proto_depIdxs = nil
}
