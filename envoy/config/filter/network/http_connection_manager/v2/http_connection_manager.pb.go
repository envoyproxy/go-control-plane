// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: envoy/config/filter/network/http_connection_manager/v2/http_connection_manager.proto

/*
	Package v2 is a generated protocol buffer package.

	It is generated from these files:
		envoy/config/filter/network/http_connection_manager/v2/http_connection_manager.proto

	It has these top-level messages:
		HttpConnectionManager
		Rds
		HttpFilter
*/
package v2

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import envoy_api_v2_core2 "github.com/envoyproxy/go-control-plane/envoy/api/v2/core"
import envoy_api_v2_core3 "github.com/envoyproxy/go-control-plane/envoy/api/v2/core"
import envoy_api_v21 "github.com/envoyproxy/go-control-plane/envoy/api/v2"
import envoy_config_filter_accesslog_v2 "github.com/envoyproxy/go-control-plane/envoy/config/filter/accesslog/v2"
import envoy_type1 "github.com/envoyproxy/go-control-plane/envoy/type"
import _ "github.com/gogo/protobuf/types"
import google_protobuf "github.com/gogo/protobuf/types"
import google_protobuf1 "github.com/gogo/protobuf/types"
import _ "github.com/lyft/protoc-gen-validate/validate"
import _ "github.com/gogo/protobuf/gogoproto"

import time "time"

import github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type HttpConnectionManager_CodecType int32

const (
	// For every new connection, the connection manager will determine which
	// codec to use. This mode supports both ALPN for TLS listeners as well as
	// protocol inference for plaintext listeners. If ALPN data is available, it
	// is preferred, otherwise protocol inference is used. In almost all cases,
	// this is the right option to choose for this setting.
	AUTO HttpConnectionManager_CodecType = 0
	// The connection manager will assume that the client is speaking HTTP/1.1.
	HTTP1 HttpConnectionManager_CodecType = 1
	// The connection manager will assume that the client is speaking HTTP/2
	// (Envoy does not require HTTP/2 to take place over TLS or to use ALPN.
	// Prior knowledge is allowed).
	HTTP2 HttpConnectionManager_CodecType = 2
)

var HttpConnectionManager_CodecType_name = map[int32]string{
	0: "AUTO",
	1: "HTTP1",
	2: "HTTP2",
}
var HttpConnectionManager_CodecType_value = map[string]int32{
	"AUTO":  0,
	"HTTP1": 1,
	"HTTP2": 2,
}

func (x HttpConnectionManager_CodecType) String() string {
	return proto.EnumName(HttpConnectionManager_CodecType_name, int32(x))
}
func (HttpConnectionManager_CodecType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorHttpConnectionManager, []int{0, 0}
}

// How to handle the :ref:`config_http_conn_man_headers_x-forwarded-client-cert` (XFCC) HTTP
// header.
type HttpConnectionManager_ForwardClientCertDetails int32

const (
	// Do not send the XFCC header to the next hop. This is the default value.
	SANITIZE HttpConnectionManager_ForwardClientCertDetails = 0
	// When the client connection is mTLS (Mutual TLS), forward the XFCC header
	// in the request.
	FORWARD_ONLY HttpConnectionManager_ForwardClientCertDetails = 1
	// When the client connection is mTLS, append the client certificate
	// information to the request’s XFCC header and forward it.
	APPEND_FORWARD HttpConnectionManager_ForwardClientCertDetails = 2
	// When the client connection is mTLS, reset the XFCC header with the client
	// certificate information and send it to the next hop.
	SANITIZE_SET HttpConnectionManager_ForwardClientCertDetails = 3
	// Always forward the XFCC header in the request, regardless of whether the
	// client connection is mTLS.
	ALWAYS_FORWARD_ONLY HttpConnectionManager_ForwardClientCertDetails = 4
)

var HttpConnectionManager_ForwardClientCertDetails_name = map[int32]string{
	0: "SANITIZE",
	1: "FORWARD_ONLY",
	2: "APPEND_FORWARD",
	3: "SANITIZE_SET",
	4: "ALWAYS_FORWARD_ONLY",
}
var HttpConnectionManager_ForwardClientCertDetails_value = map[string]int32{
	"SANITIZE":            0,
	"FORWARD_ONLY":        1,
	"APPEND_FORWARD":      2,
	"SANITIZE_SET":        3,
	"ALWAYS_FORWARD_ONLY": 4,
}

func (x HttpConnectionManager_ForwardClientCertDetails) String() string {
	return proto.EnumName(HttpConnectionManager_ForwardClientCertDetails_name, int32(x))
}
func (HttpConnectionManager_ForwardClientCertDetails) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorHttpConnectionManager, []int{0, 1}
}

type HttpConnectionManager_Tracing_OperationName int32

const (
	// The HTTP listener is used for ingress/incoming requests.
	INGRESS HttpConnectionManager_Tracing_OperationName = 0
	// The HTTP listener is used for egress/outgoing requests.
	EGRESS HttpConnectionManager_Tracing_OperationName = 1
)

var HttpConnectionManager_Tracing_OperationName_name = map[int32]string{
	0: "INGRESS",
	1: "EGRESS",
}
var HttpConnectionManager_Tracing_OperationName_value = map[string]int32{
	"INGRESS": 0,
	"EGRESS":  1,
}

func (x HttpConnectionManager_Tracing_OperationName) String() string {
	return proto.EnumName(HttpConnectionManager_Tracing_OperationName_name, int32(x))
}
func (HttpConnectionManager_Tracing_OperationName) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorHttpConnectionManager, []int{0, 0, 0}
}

// [#comment:next free field: 21]
type HttpConnectionManager struct {
	// Supplies the type of codec that the connection manager should use.
	CodecType HttpConnectionManager_CodecType `protobuf:"varint,1,opt,name=codec_type,json=codecType,proto3,enum=envoy.config.filter.network.http_connection_manager.v2.HttpConnectionManager_CodecType" json:"codec_type,omitempty"`
	// The human readable prefix to use when emitting statistics for the
	// connection manager. See the :ref:`statistics documentation <config_http_conn_man_stats>` for
	// more information.
	StatPrefix string `protobuf:"bytes,2,opt,name=stat_prefix,json=statPrefix,proto3" json:"stat_prefix,omitempty"`
	// Types that are valid to be assigned to RouteSpecifier:
	//	*HttpConnectionManager_Rds
	//	*HttpConnectionManager_RouteConfig
	RouteSpecifier isHttpConnectionManager_RouteSpecifier `protobuf_oneof:"route_specifier"`
	// A list of individual HTTP filters that make up the filter chain for
	// requests made to the connection manager. Order matters as the filters are
	// processed sequentially as request events happen.
	HttpFilters []*HttpFilter `protobuf:"bytes,5,rep,name=http_filters,json=httpFilters" json:"http_filters,omitempty"`
	// Whether the connection manager manipulates the :ref:`config_http_conn_man_headers_user-agent`
	// and :ref:`config_http_conn_man_headers_downstream-service-cluster` headers. See the linked
	// documentation for more information. Defaults to false.
	AddUserAgent *google_protobuf1.BoolValue `protobuf:"bytes,6,opt,name=add_user_agent,json=addUserAgent" json:"add_user_agent,omitempty"`
	// Presence of the object defines whether the connection manager
	// emits :ref:`tracing <arch_overview_tracing>` data to the :ref:`configured tracing provider
	// <envoy_api_msg_config.trace.v2.Tracing>`.
	Tracing *HttpConnectionManager_Tracing `protobuf:"bytes,7,opt,name=tracing" json:"tracing,omitempty"`
	// Additional HTTP/1 settings that are passed to the HTTP/1 codec.
	HttpProtocolOptions *envoy_api_v2_core3.Http1ProtocolOptions `protobuf:"bytes,8,opt,name=http_protocol_options,json=httpProtocolOptions" json:"http_protocol_options,omitempty"`
	// Additional HTTP/2 settings that are passed directly to the HTTP/2 codec.
	Http2ProtocolOptions *envoy_api_v2_core3.Http2ProtocolOptions `protobuf:"bytes,9,opt,name=http2_protocol_options,json=http2ProtocolOptions" json:"http2_protocol_options,omitempty"`
	// An optional override that the connection manager will write to the server
	// header in responses. If not set, the default is *envoy*.
	ServerName string `protobuf:"bytes,10,opt,name=server_name,json=serverName,proto3" json:"server_name,omitempty"`
	// The idle timeout for connections managed by the connection manager. The
	// idle timeout is defined as the period in which there are no active
	// requests. If not set, there is no idle timeout. When the idle timeout is
	// reached the connection will be closed. If the connection is an HTTP/2
	// connection a drain sequence will occur prior to closing the connection. See
	// :ref:`drain_timeout
	// <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.drain_timeout>`.
	IdleTimeout *time.Duration `protobuf:"bytes,11,opt,name=idle_timeout,json=idleTimeout,stdduration" json:"idle_timeout,omitempty"`
	// The time that Envoy will wait between sending an HTTP/2 “shutdown
	// notification” (GOAWAY frame with max stream ID) and a final GOAWAY frame.
	// This is used so that Envoy provides a grace period for new streams that
	// race with the final GOAWAY frame. During this grace period, Envoy will
	// continue to accept new streams. After the grace period, a final GOAWAY
	// frame is sent and Envoy will start refusing new streams. Draining occurs
	// both when a connection hits the idle timeout or during general server
	// draining. The default grace period is 5000 milliseconds (5 seconds) if this
	// option is not specified.
	DrainTimeout *time.Duration `protobuf:"bytes,12,opt,name=drain_timeout,json=drainTimeout,stdduration" json:"drain_timeout,omitempty"`
	// Configuration for :ref:`HTTP access logs <arch_overview_access_logs>`
	// emitted by the connection manager.
	AccessLog []*envoy_config_filter_accesslog_v2.AccessLog `protobuf:"bytes,13,rep,name=access_log,json=accessLog" json:"access_log,omitempty"`
	// If set to true, the connection manager will use the real remote address
	// of the client connection when determining internal versus external origin and manipulating
	// various headers. If set to false or absent, the connection manager will use the
	// :ref:`config_http_conn_man_headers_x-forwarded-for` HTTP header. See the documentation for
	// :ref:`config_http_conn_man_headers_x-forwarded-for`,
	// :ref:`config_http_conn_man_headers_x-envoy-internal`, and
	// :ref:`config_http_conn_man_headers_x-envoy-external-address` for more information.
	UseRemoteAddress *google_protobuf1.BoolValue `protobuf:"bytes,14,opt,name=use_remote_address,json=useRemoteAddress" json:"use_remote_address,omitempty"`
	// The number of additional ingress proxy hops from the right side of the
	// :ref:`config_http_conn_man_headers_x-forwarded-for` HTTP header to trust when
	// determining the origin client's IP address. The default is zero if this option
	// is not specified. See the documentation for
	// :ref:`config_http_conn_man_headers_x-forwarded-for` for more information.
	XffNumTrustedHops uint32 `protobuf:"varint,19,opt,name=xff_num_trusted_hops,json=xffNumTrustedHops,proto3" json:"xff_num_trusted_hops,omitempty"`
	// of the client connection as the origin client address if *use_remote_address* is true
	// Whether the connection manager will generate the :ref:`x-request-id
	// <config_http_conn_man_headers_x-request-id>` header if it does not exist. This defaults to
	// true. Generating a random UUID4 is expensive so in high throughput scenarios where this feature
	// is not desired it can be disabled.
	GenerateRequestId *google_protobuf1.BoolValue `protobuf:"bytes,15,opt,name=generate_request_id,json=generateRequestId" json:"generate_request_id,omitempty"`
	// How to handle the :ref:`config_http_conn_man_headers_x-forwarded-client-cert` (XFCC) HTTP
	// header.
	ForwardClientCertDetails HttpConnectionManager_ForwardClientCertDetails `protobuf:"varint,16,opt,name=forward_client_cert_details,json=forwardClientCertDetails,proto3,enum=envoy.config.filter.network.http_connection_manager.v2.HttpConnectionManager_ForwardClientCertDetails" json:"forward_client_cert_details,omitempty"`
	// This field is valid only when :ref:`forward_client_cert_details
	// <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.forward_client_cert_details>`
	// is APPEND_FORWARD or SANITIZE_SET and the client connection is mTLS. It specifies the fields in
	// the client certificate to be forwarded. Note that in the
	// :ref:`config_http_conn_man_headers_x-forwarded-client-cert` header, *Hash* is always set, and
	// *By* is always set when the client certificate presents the SAN value.
	SetCurrentClientCertDetails *HttpConnectionManager_SetCurrentClientCertDetails `protobuf:"bytes,17,opt,name=set_current_client_cert_details,json=setCurrentClientCertDetails" json:"set_current_client_cert_details,omitempty"`
	// If proxy_100_continue is true, Envoy will proxy incoming "Expect:
	// 100-continue" headers upstream, and forward "100 Continue" responses
	// downstream. If this is false or not set, Envoy will instead strip the
	// "Expect: 100-continue" header, and send a "100 Continue" response itself.
	Proxy_100Continue bool `protobuf:"varint,18,opt,name=proxy_100_continue,json=proxy100Continue,proto3" json:"proxy_100_continue,omitempty"`
	// If
	// :ref:`use_remote_address
	// <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.use_remote_address>`
	// is true and represent_ipv4_remote_address_as_ipv4_mapped_ipv6 is true and the remote address is
	// an IPv4 address, the address will be mapped to IPv6 before it is appended to *x-forwarded-for*.
	// This is useful for testing compatibility of upstream services that parse the header value. For
	// example, 50.0.0.1 is represented as ::FFFF:50.0.0.1. See `IPv4-Mapped IPv6 Addresses
	// <https://tools.ietf.org/html/rfc4291#section-2.5.5.2>`_ for details. This will also affect the
	// :ref:`config_http_conn_man_headers_x-envoy-external-address` header. See
	// :ref:`http_connection_manager.represent_ipv4_remote_address_as_ipv4_mapped_ipv6
	// <config_http_conn_man_runtime_represent_ipv4_remote_address_as_ipv4_mapped_ipv6>` for runtime
	// control.
	RepresentIpv4RemoteAddressAsIpv4MappedIpv6 bool `protobuf:"varint,20,opt,name=represent_ipv4_remote_address_as_ipv4_mapped_ipv6,json=representIpv4RemoteAddressAsIpv4MappedIpv6,proto3" json:"represent_ipv4_remote_address_as_ipv4_mapped_ipv6,omitempty"`
}

func (m *HttpConnectionManager) Reset()         { *m = HttpConnectionManager{} }
func (m *HttpConnectionManager) String() string { return proto.CompactTextString(m) }
func (*HttpConnectionManager) ProtoMessage()    {}
func (*HttpConnectionManager) Descriptor() ([]byte, []int) {
	return fileDescriptorHttpConnectionManager, []int{0}
}

type isHttpConnectionManager_RouteSpecifier interface {
	isHttpConnectionManager_RouteSpecifier()
	MarshalTo([]byte) (int, error)
	Size() int
}

type HttpConnectionManager_Rds struct {
	Rds *Rds `protobuf:"bytes,3,opt,name=rds,oneof"`
}
type HttpConnectionManager_RouteConfig struct {
	RouteConfig *envoy_api_v21.RouteConfiguration `protobuf:"bytes,4,opt,name=route_config,json=routeConfig,oneof"`
}

func (*HttpConnectionManager_Rds) isHttpConnectionManager_RouteSpecifier()         {}
func (*HttpConnectionManager_RouteConfig) isHttpConnectionManager_RouteSpecifier() {}

func (m *HttpConnectionManager) GetRouteSpecifier() isHttpConnectionManager_RouteSpecifier {
	if m != nil {
		return m.RouteSpecifier
	}
	return nil
}

func (m *HttpConnectionManager) GetCodecType() HttpConnectionManager_CodecType {
	if m != nil {
		return m.CodecType
	}
	return AUTO
}

func (m *HttpConnectionManager) GetStatPrefix() string {
	if m != nil {
		return m.StatPrefix
	}
	return ""
}

func (m *HttpConnectionManager) GetRds() *Rds {
	if x, ok := m.GetRouteSpecifier().(*HttpConnectionManager_Rds); ok {
		return x.Rds
	}
	return nil
}

func (m *HttpConnectionManager) GetRouteConfig() *envoy_api_v21.RouteConfiguration {
	if x, ok := m.GetRouteSpecifier().(*HttpConnectionManager_RouteConfig); ok {
		return x.RouteConfig
	}
	return nil
}

func (m *HttpConnectionManager) GetHttpFilters() []*HttpFilter {
	if m != nil {
		return m.HttpFilters
	}
	return nil
}

func (m *HttpConnectionManager) GetAddUserAgent() *google_protobuf1.BoolValue {
	if m != nil {
		return m.AddUserAgent
	}
	return nil
}

func (m *HttpConnectionManager) GetTracing() *HttpConnectionManager_Tracing {
	if m != nil {
		return m.Tracing
	}
	return nil
}

func (m *HttpConnectionManager) GetHttpProtocolOptions() *envoy_api_v2_core3.Http1ProtocolOptions {
	if m != nil {
		return m.HttpProtocolOptions
	}
	return nil
}

func (m *HttpConnectionManager) GetHttp2ProtocolOptions() *envoy_api_v2_core3.Http2ProtocolOptions {
	if m != nil {
		return m.Http2ProtocolOptions
	}
	return nil
}

func (m *HttpConnectionManager) GetServerName() string {
	if m != nil {
		return m.ServerName
	}
	return ""
}

func (m *HttpConnectionManager) GetIdleTimeout() *time.Duration {
	if m != nil {
		return m.IdleTimeout
	}
	return nil
}

func (m *HttpConnectionManager) GetDrainTimeout() *time.Duration {
	if m != nil {
		return m.DrainTimeout
	}
	return nil
}

func (m *HttpConnectionManager) GetAccessLog() []*envoy_config_filter_accesslog_v2.AccessLog {
	if m != nil {
		return m.AccessLog
	}
	return nil
}

func (m *HttpConnectionManager) GetUseRemoteAddress() *google_protobuf1.BoolValue {
	if m != nil {
		return m.UseRemoteAddress
	}
	return nil
}

func (m *HttpConnectionManager) GetXffNumTrustedHops() uint32 {
	if m != nil {
		return m.XffNumTrustedHops
	}
	return 0
}

func (m *HttpConnectionManager) GetGenerateRequestId() *google_protobuf1.BoolValue {
	if m != nil {
		return m.GenerateRequestId
	}
	return nil
}

func (m *HttpConnectionManager) GetForwardClientCertDetails() HttpConnectionManager_ForwardClientCertDetails {
	if m != nil {
		return m.ForwardClientCertDetails
	}
	return SANITIZE
}

func (m *HttpConnectionManager) GetSetCurrentClientCertDetails() *HttpConnectionManager_SetCurrentClientCertDetails {
	if m != nil {
		return m.SetCurrentClientCertDetails
	}
	return nil
}

func (m *HttpConnectionManager) GetProxy_100Continue() bool {
	if m != nil {
		return m.Proxy_100Continue
	}
	return false
}

func (m *HttpConnectionManager) GetRepresentIpv4RemoteAddressAsIpv4MappedIpv6() bool {
	if m != nil {
		return m.RepresentIpv4RemoteAddressAsIpv4MappedIpv6
	}
	return false
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*HttpConnectionManager) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _HttpConnectionManager_OneofMarshaler, _HttpConnectionManager_OneofUnmarshaler, _HttpConnectionManager_OneofSizer, []interface{}{
		(*HttpConnectionManager_Rds)(nil),
		(*HttpConnectionManager_RouteConfig)(nil),
	}
}

func _HttpConnectionManager_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*HttpConnectionManager)
	// route_specifier
	switch x := m.RouteSpecifier.(type) {
	case *HttpConnectionManager_Rds:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Rds); err != nil {
			return err
		}
	case *HttpConnectionManager_RouteConfig:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.RouteConfig); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("HttpConnectionManager.RouteSpecifier has unexpected type %T", x)
	}
	return nil
}

func _HttpConnectionManager_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*HttpConnectionManager)
	switch tag {
	case 3: // route_specifier.rds
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Rds)
		err := b.DecodeMessage(msg)
		m.RouteSpecifier = &HttpConnectionManager_Rds{msg}
		return true, err
	case 4: // route_specifier.route_config
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(envoy_api_v21.RouteConfiguration)
		err := b.DecodeMessage(msg)
		m.RouteSpecifier = &HttpConnectionManager_RouteConfig{msg}
		return true, err
	default:
		return false, nil
	}
}

func _HttpConnectionManager_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*HttpConnectionManager)
	// route_specifier
	switch x := m.RouteSpecifier.(type) {
	case *HttpConnectionManager_Rds:
		s := proto.Size(x.Rds)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *HttpConnectionManager_RouteConfig:
		s := proto.Size(x.RouteConfig)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type HttpConnectionManager_Tracing struct {
	// The span name will be derived from this field.
	OperationName HttpConnectionManager_Tracing_OperationName `protobuf:"varint,1,opt,name=operation_name,json=operationName,proto3,enum=envoy.config.filter.network.http_connection_manager.v2.HttpConnectionManager_Tracing_OperationName" json:"operation_name,omitempty"`
	// A list of header names used to create tags for the active span. The header name is used to
	// populate the tag name, and the header value is used to populate the tag value. The tag is
	// created if the specified header name is present in the request's headers.
	RequestHeadersForTags []string `protobuf:"bytes,2,rep,name=request_headers_for_tags,json=requestHeadersForTags" json:"request_headers_for_tags,omitempty"`
	// Target percentage of requests managed by this HTTP connection manager that will be force
	// traced if the :ref:`x-client-trace-id <config_http_conn_man_headers_x-client-trace-id>`
	// header is set. This field is a direct analog for the runtime variable
	// 'tracing.client_sampling' in the :ref:`HTTP Connection Manager
	// <config_http_conn_man_runtime>`.
	// Default: 100%
	ClientSampling *envoy_type1.Percent `protobuf:"bytes,3,opt,name=client_sampling,json=clientSampling" json:"client_sampling,omitempty"`
	// Target percentage of requests managed by this HTTP connection manager that will be randomly
	// selected for trace generation, if not requested by the client or not forced. This field is
	// a direct analog for the runtime variable 'tracing.random_sampling' in the
	// :ref:`HTTP Connection Manager <config_http_conn_man_runtime>`.
	// Default: 100%
	RandomSampling *envoy_type1.Percent `protobuf:"bytes,4,opt,name=random_sampling,json=randomSampling" json:"random_sampling,omitempty"`
	// Target percentage of requests managed by this HTTP connection manager that will be traced
	// after all other sampling checks have been applied (client-directed, force tracing, random
	// sampling). This field functions as an upper limit on the total configured sampling rate. For
	// instance, setting client_sampling to 100% but overall_sampling to 1% will result in only 1%
	// of client requests with the appropriate headers to be force traced. This field is a direct
	// analog for the runtime variable 'tracing.global_enabled' in the
	// :ref:`HTTP Connection Manager <config_http_conn_man_runtime>`.
	// Default: 100%
	OverallSampling *envoy_type1.Percent `protobuf:"bytes,5,opt,name=overall_sampling,json=overallSampling" json:"overall_sampling,omitempty"`
}

func (m *HttpConnectionManager_Tracing) Reset()         { *m = HttpConnectionManager_Tracing{} }
func (m *HttpConnectionManager_Tracing) String() string { return proto.CompactTextString(m) }
func (*HttpConnectionManager_Tracing) ProtoMessage()    {}
func (*HttpConnectionManager_Tracing) Descriptor() ([]byte, []int) {
	return fileDescriptorHttpConnectionManager, []int{0, 0}
}

func (m *HttpConnectionManager_Tracing) GetOperationName() HttpConnectionManager_Tracing_OperationName {
	if m != nil {
		return m.OperationName
	}
	return INGRESS
}

func (m *HttpConnectionManager_Tracing) GetRequestHeadersForTags() []string {
	if m != nil {
		return m.RequestHeadersForTags
	}
	return nil
}

func (m *HttpConnectionManager_Tracing) GetClientSampling() *envoy_type1.Percent {
	if m != nil {
		return m.ClientSampling
	}
	return nil
}

func (m *HttpConnectionManager_Tracing) GetRandomSampling() *envoy_type1.Percent {
	if m != nil {
		return m.RandomSampling
	}
	return nil
}

func (m *HttpConnectionManager_Tracing) GetOverallSampling() *envoy_type1.Percent {
	if m != nil {
		return m.OverallSampling
	}
	return nil
}

type HttpConnectionManager_SetCurrentClientCertDetails struct {
	// Whether to forward the subject of the client cert. Defaults to false.
	Subject *google_protobuf1.BoolValue `protobuf:"bytes,1,opt,name=subject" json:"subject,omitempty"`
	// Whether to forward the SAN of the client cert. Defaults to false.
	San *google_protobuf1.BoolValue `protobuf:"bytes,2,opt,name=san" json:"san,omitempty"`
	// Whether to forward the entire client cert in URL encoded PEM format. This will appear in the
	// XFCC header comma separated from other values with the value Cert="PEM".
	// Defaults to false.
	Cert bool `protobuf:"varint,3,opt,name=cert,proto3" json:"cert,omitempty"`
}

func (m *HttpConnectionManager_SetCurrentClientCertDetails) Reset() {
	*m = HttpConnectionManager_SetCurrentClientCertDetails{}
}
func (m *HttpConnectionManager_SetCurrentClientCertDetails) String() string {
	return proto.CompactTextString(m)
}
func (*HttpConnectionManager_SetCurrentClientCertDetails) ProtoMessage() {}
func (*HttpConnectionManager_SetCurrentClientCertDetails) Descriptor() ([]byte, []int) {
	return fileDescriptorHttpConnectionManager, []int{0, 1}
}

func (m *HttpConnectionManager_SetCurrentClientCertDetails) GetSubject() *google_protobuf1.BoolValue {
	if m != nil {
		return m.Subject
	}
	return nil
}

func (m *HttpConnectionManager_SetCurrentClientCertDetails) GetSan() *google_protobuf1.BoolValue {
	if m != nil {
		return m.San
	}
	return nil
}

func (m *HttpConnectionManager_SetCurrentClientCertDetails) GetCert() bool {
	if m != nil {
		return m.Cert
	}
	return false
}

type Rds struct {
	// Configuration source specifier for RDS.
	ConfigSource envoy_api_v2_core2.ConfigSource `protobuf:"bytes,1,opt,name=config_source,json=configSource" json:"config_source"`
	// The name of the route configuration. This name will be passed to the RDS
	// API. This allows an Envoy configuration with multiple HTTP listeners (and
	// associated HTTP connection manager filters) to use different route
	// configurations.
	RouteConfigName string `protobuf:"bytes,2,opt,name=route_config_name,json=routeConfigName,proto3" json:"route_config_name,omitempty"`
}

func (m *Rds) Reset()                    { *m = Rds{} }
func (m *Rds) String() string            { return proto.CompactTextString(m) }
func (*Rds) ProtoMessage()               {}
func (*Rds) Descriptor() ([]byte, []int) { return fileDescriptorHttpConnectionManager, []int{1} }

func (m *Rds) GetConfigSource() envoy_api_v2_core2.ConfigSource {
	if m != nil {
		return m.ConfigSource
	}
	return envoy_api_v2_core2.ConfigSource{}
}

func (m *Rds) GetRouteConfigName() string {
	if m != nil {
		return m.RouteConfigName
	}
	return ""
}

type HttpFilter struct {
	// The name of the filter to instantiate. The name must match a supported
	// filter. The built-in filters are:
	//
	// [#comment:TODO(mattklein123): Auto generate the following list]
	// * :ref:`envoy.buffer <config_http_filters_buffer>`
	// * :ref:`envoy.cors <config_http_filters_cors>`
	// * :ref:`envoy.fault <config_http_filters_fault_injection>`
	// * :ref:`envoy.gzip <config_http_filters_gzip>`
	// * :ref:`envoy.http_dynamo_filter <config_http_filters_dynamo>`
	// * :ref:`envoy.grpc_http1_bridge <config_http_filters_grpc_bridge>`
	// * :ref:`envoy.grpc_json_transcoder <config_http_filters_grpc_json_transcoder>`
	// * :ref:`envoy.grpc_web <config_http_filters_grpc_web>`
	// * :ref:`envoy.health_check <config_http_filters_health_check>`
	// * :ref:`envoy.ip_tagging <config_http_filters_ip_tagging>`
	// * :ref:`envoy.lua <config_http_filters_lua>`
	// * :ref:`envoy.rate_limit <config_http_filters_rate_limit>`
	// * :ref:`envoy.router <config_http_filters_router>`
	// * :ref:`envoy.squash <config_http_filters_squash>`
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Filter specific configuration which depends on the filter being
	// instantiated. See the supported filters for further documentation.
	Config *google_protobuf.Struct `protobuf:"bytes,2,opt,name=config" json:"config,omitempty"`
	// [#not-implemented-hide:]
	// This is hidden as type has been deprecated and is no longer required.
	DeprecatedV1 *HttpFilter_DeprecatedV1 `protobuf:"bytes,3,opt,name=deprecated_v1,json=deprecatedV1" json:"deprecated_v1,omitempty"`
}

func (m *HttpFilter) Reset()                    { *m = HttpFilter{} }
func (m *HttpFilter) String() string            { return proto.CompactTextString(m) }
func (*HttpFilter) ProtoMessage()               {}
func (*HttpFilter) Descriptor() ([]byte, []int) { return fileDescriptorHttpConnectionManager, []int{2} }

func (m *HttpFilter) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *HttpFilter) GetConfig() *google_protobuf.Struct {
	if m != nil {
		return m.Config
	}
	return nil
}

func (m *HttpFilter) GetDeprecatedV1() *HttpFilter_DeprecatedV1 {
	if m != nil {
		return m.DeprecatedV1
	}
	return nil
}

// [#not-implemented-hide:]
// This is hidden as type has been deprecated and is no longer required.
type HttpFilter_DeprecatedV1 struct {
	Type string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
}

func (m *HttpFilter_DeprecatedV1) Reset()         { *m = HttpFilter_DeprecatedV1{} }
func (m *HttpFilter_DeprecatedV1) String() string { return proto.CompactTextString(m) }
func (*HttpFilter_DeprecatedV1) ProtoMessage()    {}
func (*HttpFilter_DeprecatedV1) Descriptor() ([]byte, []int) {
	return fileDescriptorHttpConnectionManager, []int{2, 0}
}

func (m *HttpFilter_DeprecatedV1) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func init() {
	proto.RegisterType((*HttpConnectionManager)(nil), "envoy.config.filter.network.http_connection_manager.v2.HttpConnectionManager")
	proto.RegisterType((*HttpConnectionManager_Tracing)(nil), "envoy.config.filter.network.http_connection_manager.v2.HttpConnectionManager.Tracing")
	proto.RegisterType((*HttpConnectionManager_SetCurrentClientCertDetails)(nil), "envoy.config.filter.network.http_connection_manager.v2.HttpConnectionManager.SetCurrentClientCertDetails")
	proto.RegisterType((*Rds)(nil), "envoy.config.filter.network.http_connection_manager.v2.Rds")
	proto.RegisterType((*HttpFilter)(nil), "envoy.config.filter.network.http_connection_manager.v2.HttpFilter")
	proto.RegisterType((*HttpFilter_DeprecatedV1)(nil), "envoy.config.filter.network.http_connection_manager.v2.HttpFilter.DeprecatedV1")
	proto.RegisterEnum("envoy.config.filter.network.http_connection_manager.v2.HttpConnectionManager_CodecType", HttpConnectionManager_CodecType_name, HttpConnectionManager_CodecType_value)
	proto.RegisterEnum("envoy.config.filter.network.http_connection_manager.v2.HttpConnectionManager_ForwardClientCertDetails", HttpConnectionManager_ForwardClientCertDetails_name, HttpConnectionManager_ForwardClientCertDetails_value)
	proto.RegisterEnum("envoy.config.filter.network.http_connection_manager.v2.HttpConnectionManager_Tracing_OperationName", HttpConnectionManager_Tracing_OperationName_name, HttpConnectionManager_Tracing_OperationName_value)
}
func (m *HttpConnectionManager) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HttpConnectionManager) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CodecType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHttpConnectionManager(dAtA, i, uint64(m.CodecType))
	}
	if len(m.StatPrefix) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintHttpConnectionManager(dAtA, i, uint64(len(m.StatPrefix)))
		i += copy(dAtA[i:], m.StatPrefix)
	}
	if m.RouteSpecifier != nil {
		nn1, err := m.RouteSpecifier.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn1
	}
	if len(m.HttpFilters) > 0 {
		for _, msg := range m.HttpFilters {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintHttpConnectionManager(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.AddUserAgent != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintHttpConnectionManager(dAtA, i, uint64(m.AddUserAgent.Size()))
		n2, err := m.AddUserAgent.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.Tracing != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintHttpConnectionManager(dAtA, i, uint64(m.Tracing.Size()))
		n3, err := m.Tracing.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.HttpProtocolOptions != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintHttpConnectionManager(dAtA, i, uint64(m.HttpProtocolOptions.Size()))
		n4, err := m.HttpProtocolOptions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.Http2ProtocolOptions != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintHttpConnectionManager(dAtA, i, uint64(m.Http2ProtocolOptions.Size()))
		n5, err := m.Http2ProtocolOptions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if len(m.ServerName) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintHttpConnectionManager(dAtA, i, uint64(len(m.ServerName)))
		i += copy(dAtA[i:], m.ServerName)
	}
	if m.IdleTimeout != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintHttpConnectionManager(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdDuration(*m.IdleTimeout)))
		n6, err := github_com_gogo_protobuf_types.StdDurationMarshalTo(*m.IdleTimeout, dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.DrainTimeout != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintHttpConnectionManager(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdDuration(*m.DrainTimeout)))
		n7, err := github_com_gogo_protobuf_types.StdDurationMarshalTo(*m.DrainTimeout, dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if len(m.AccessLog) > 0 {
		for _, msg := range m.AccessLog {
			dAtA[i] = 0x6a
			i++
			i = encodeVarintHttpConnectionManager(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.UseRemoteAddress != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintHttpConnectionManager(dAtA, i, uint64(m.UseRemoteAddress.Size()))
		n8, err := m.UseRemoteAddress.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.GenerateRequestId != nil {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintHttpConnectionManager(dAtA, i, uint64(m.GenerateRequestId.Size()))
		n9, err := m.GenerateRequestId.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.ForwardClientCertDetails != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintHttpConnectionManager(dAtA, i, uint64(m.ForwardClientCertDetails))
	}
	if m.SetCurrentClientCertDetails != nil {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintHttpConnectionManager(dAtA, i, uint64(m.SetCurrentClientCertDetails.Size()))
		n10, err := m.SetCurrentClientCertDetails.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.Proxy_100Continue {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		if m.Proxy_100Continue {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XffNumTrustedHops != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintHttpConnectionManager(dAtA, i, uint64(m.XffNumTrustedHops))
	}
	if m.RepresentIpv4RemoteAddressAsIpv4MappedIpv6 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		if m.RepresentIpv4RemoteAddressAsIpv4MappedIpv6 {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *HttpConnectionManager_Rds) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Rds != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintHttpConnectionManager(dAtA, i, uint64(m.Rds.Size()))
		n11, err := m.Rds.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}
func (m *HttpConnectionManager_RouteConfig) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.RouteConfig != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintHttpConnectionManager(dAtA, i, uint64(m.RouteConfig.Size()))
		n12, err := m.RouteConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}
func (m *HttpConnectionManager_Tracing) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HttpConnectionManager_Tracing) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OperationName != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHttpConnectionManager(dAtA, i, uint64(m.OperationName))
	}
	if len(m.RequestHeadersForTags) > 0 {
		for _, s := range m.RequestHeadersForTags {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.ClientSampling != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintHttpConnectionManager(dAtA, i, uint64(m.ClientSampling.Size()))
		n13, err := m.ClientSampling.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.RandomSampling != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintHttpConnectionManager(dAtA, i, uint64(m.RandomSampling.Size()))
		n14, err := m.RandomSampling.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.OverallSampling != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintHttpConnectionManager(dAtA, i, uint64(m.OverallSampling.Size()))
		n15, err := m.OverallSampling.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	return i, nil
}

func (m *HttpConnectionManager_SetCurrentClientCertDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HttpConnectionManager_SetCurrentClientCertDetails) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Subject != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintHttpConnectionManager(dAtA, i, uint64(m.Subject.Size()))
		n16, err := m.Subject.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.San != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintHttpConnectionManager(dAtA, i, uint64(m.San.Size()))
		n17, err := m.San.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if m.Cert {
		dAtA[i] = 0x18
		i++
		if m.Cert {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *Rds) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Rds) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintHttpConnectionManager(dAtA, i, uint64(m.ConfigSource.Size()))
	n18, err := m.ConfigSource.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n18
	if len(m.RouteConfigName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintHttpConnectionManager(dAtA, i, uint64(len(m.RouteConfigName)))
		i += copy(dAtA[i:], m.RouteConfigName)
	}
	return i, nil
}

func (m *HttpFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HttpFilter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintHttpConnectionManager(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Config != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintHttpConnectionManager(dAtA, i, uint64(m.Config.Size()))
		n19, err := m.Config.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if m.DeprecatedV1 != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintHttpConnectionManager(dAtA, i, uint64(m.DeprecatedV1.Size()))
		n20, err := m.DeprecatedV1.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	return i, nil
}

func (m *HttpFilter_DeprecatedV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HttpFilter_DeprecatedV1) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintHttpConnectionManager(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	return i, nil
}

func encodeVarintHttpConnectionManager(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *HttpConnectionManager) Size() (n int) {
	var l int
	_ = l
	if m.CodecType != 0 {
		n += 1 + sovHttpConnectionManager(uint64(m.CodecType))
	}
	l = len(m.StatPrefix)
	if l > 0 {
		n += 1 + l + sovHttpConnectionManager(uint64(l))
	}
	if m.RouteSpecifier != nil {
		n += m.RouteSpecifier.Size()
	}
	if len(m.HttpFilters) > 0 {
		for _, e := range m.HttpFilters {
			l = e.Size()
			n += 1 + l + sovHttpConnectionManager(uint64(l))
		}
	}
	if m.AddUserAgent != nil {
		l = m.AddUserAgent.Size()
		n += 1 + l + sovHttpConnectionManager(uint64(l))
	}
	if m.Tracing != nil {
		l = m.Tracing.Size()
		n += 1 + l + sovHttpConnectionManager(uint64(l))
	}
	if m.HttpProtocolOptions != nil {
		l = m.HttpProtocolOptions.Size()
		n += 1 + l + sovHttpConnectionManager(uint64(l))
	}
	if m.Http2ProtocolOptions != nil {
		l = m.Http2ProtocolOptions.Size()
		n += 1 + l + sovHttpConnectionManager(uint64(l))
	}
	l = len(m.ServerName)
	if l > 0 {
		n += 1 + l + sovHttpConnectionManager(uint64(l))
	}
	if m.IdleTimeout != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdDuration(*m.IdleTimeout)
		n += 1 + l + sovHttpConnectionManager(uint64(l))
	}
	if m.DrainTimeout != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdDuration(*m.DrainTimeout)
		n += 1 + l + sovHttpConnectionManager(uint64(l))
	}
	if len(m.AccessLog) > 0 {
		for _, e := range m.AccessLog {
			l = e.Size()
			n += 1 + l + sovHttpConnectionManager(uint64(l))
		}
	}
	if m.UseRemoteAddress != nil {
		l = m.UseRemoteAddress.Size()
		n += 1 + l + sovHttpConnectionManager(uint64(l))
	}
	if m.GenerateRequestId != nil {
		l = m.GenerateRequestId.Size()
		n += 1 + l + sovHttpConnectionManager(uint64(l))
	}
	if m.ForwardClientCertDetails != 0 {
		n += 2 + sovHttpConnectionManager(uint64(m.ForwardClientCertDetails))
	}
	if m.SetCurrentClientCertDetails != nil {
		l = m.SetCurrentClientCertDetails.Size()
		n += 2 + l + sovHttpConnectionManager(uint64(l))
	}
	if m.Proxy_100Continue {
		n += 3
	}
	if m.XffNumTrustedHops != 0 {
		n += 2 + sovHttpConnectionManager(uint64(m.XffNumTrustedHops))
	}
	if m.RepresentIpv4RemoteAddressAsIpv4MappedIpv6 {
		n += 3
	}
	return n
}

func (m *HttpConnectionManager_Rds) Size() (n int) {
	var l int
	_ = l
	if m.Rds != nil {
		l = m.Rds.Size()
		n += 1 + l + sovHttpConnectionManager(uint64(l))
	}
	return n
}
func (m *HttpConnectionManager_RouteConfig) Size() (n int) {
	var l int
	_ = l
	if m.RouteConfig != nil {
		l = m.RouteConfig.Size()
		n += 1 + l + sovHttpConnectionManager(uint64(l))
	}
	return n
}
func (m *HttpConnectionManager_Tracing) Size() (n int) {
	var l int
	_ = l
	if m.OperationName != 0 {
		n += 1 + sovHttpConnectionManager(uint64(m.OperationName))
	}
	if len(m.RequestHeadersForTags) > 0 {
		for _, s := range m.RequestHeadersForTags {
			l = len(s)
			n += 1 + l + sovHttpConnectionManager(uint64(l))
		}
	}
	if m.ClientSampling != nil {
		l = m.ClientSampling.Size()
		n += 1 + l + sovHttpConnectionManager(uint64(l))
	}
	if m.RandomSampling != nil {
		l = m.RandomSampling.Size()
		n += 1 + l + sovHttpConnectionManager(uint64(l))
	}
	if m.OverallSampling != nil {
		l = m.OverallSampling.Size()
		n += 1 + l + sovHttpConnectionManager(uint64(l))
	}
	return n
}

func (m *HttpConnectionManager_SetCurrentClientCertDetails) Size() (n int) {
	var l int
	_ = l
	if m.Subject != nil {
		l = m.Subject.Size()
		n += 1 + l + sovHttpConnectionManager(uint64(l))
	}
	if m.San != nil {
		l = m.San.Size()
		n += 1 + l + sovHttpConnectionManager(uint64(l))
	}
	if m.Cert {
		n += 2
	}
	return n
}

func (m *Rds) Size() (n int) {
	var l int
	_ = l
	l = m.ConfigSource.Size()
	n += 1 + l + sovHttpConnectionManager(uint64(l))
	l = len(m.RouteConfigName)
	if l > 0 {
		n += 1 + l + sovHttpConnectionManager(uint64(l))
	}
	return n
}

func (m *HttpFilter) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovHttpConnectionManager(uint64(l))
	}
	if m.Config != nil {
		l = m.Config.Size()
		n += 1 + l + sovHttpConnectionManager(uint64(l))
	}
	if m.DeprecatedV1 != nil {
		l = m.DeprecatedV1.Size()
		n += 1 + l + sovHttpConnectionManager(uint64(l))
	}
	return n
}

func (m *HttpFilter_DeprecatedV1) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovHttpConnectionManager(uint64(l))
	}
	return n
}

func sovHttpConnectionManager(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozHttpConnectionManager(x uint64) (n int) {
	return sovHttpConnectionManager(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *HttpConnectionManager) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHttpConnectionManager
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HttpConnectionManager: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HttpConnectionManager: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CodecType", wireType)
			}
			m.CodecType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CodecType |= (HttpConnectionManager_CodecType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatPrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StatPrefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Rds{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RouteSpecifier = &HttpConnectionManager_Rds{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &envoy_api_v21.RouteConfiguration{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RouteSpecifier = &HttpConnectionManager_RouteConfig{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpFilters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HttpFilters = append(m.HttpFilters, &HttpFilter{})
			if err := m.HttpFilters[len(m.HttpFilters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddUserAgent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AddUserAgent == nil {
				m.AddUserAgent = &google_protobuf1.BoolValue{}
			}
			if err := m.AddUserAgent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tracing", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tracing == nil {
				m.Tracing = &HttpConnectionManager_Tracing{}
			}
			if err := m.Tracing.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpProtocolOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HttpProtocolOptions == nil {
				m.HttpProtocolOptions = &envoy_api_v2_core3.Http1ProtocolOptions{}
			}
			if err := m.HttpProtocolOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Http2ProtocolOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Http2ProtocolOptions == nil {
				m.Http2ProtocolOptions = &envoy_api_v2_core3.Http2ProtocolOptions{}
			}
			if err := m.Http2ProtocolOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdleTimeout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdleTimeout == nil {
				m.IdleTimeout = new(time.Duration)
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(m.IdleTimeout, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DrainTimeout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DrainTimeout == nil {
				m.DrainTimeout = new(time.Duration)
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(m.DrainTimeout, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessLog", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessLog = append(m.AccessLog, &envoy_config_filter_accesslog_v2.AccessLog{})
			if err := m.AccessLog[len(m.AccessLog)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseRemoteAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UseRemoteAddress == nil {
				m.UseRemoteAddress = &google_protobuf1.BoolValue{}
			}
			if err := m.UseRemoteAddress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GenerateRequestId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GenerateRequestId == nil {
				m.GenerateRequestId = &google_protobuf1.BoolValue{}
			}
			if err := m.GenerateRequestId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForwardClientCertDetails", wireType)
			}
			m.ForwardClientCertDetails = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ForwardClientCertDetails |= (HttpConnectionManager_ForwardClientCertDetails(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetCurrentClientCertDetails", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SetCurrentClientCertDetails == nil {
				m.SetCurrentClientCertDetails = &HttpConnectionManager_SetCurrentClientCertDetails{}
			}
			if err := m.SetCurrentClientCertDetails.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proxy_100Continue", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Proxy_100Continue = bool(v != 0)
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field XffNumTrustedHops", wireType)
			}
			m.XffNumTrustedHops = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.XffNumTrustedHops |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepresentIpv4RemoteAddressAsIpv4MappedIpv6", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RepresentIpv4RemoteAddressAsIpv4MappedIpv6 = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipHttpConnectionManager(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HttpConnectionManager_Tracing) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHttpConnectionManager
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Tracing: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Tracing: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperationName", wireType)
			}
			m.OperationName = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperationName |= (HttpConnectionManager_Tracing_OperationName(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeadersForTags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestHeadersForTags = append(m.RequestHeadersForTags, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientSampling", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClientSampling == nil {
				m.ClientSampling = &envoy_type1.Percent{}
			}
			if err := m.ClientSampling.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RandomSampling", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RandomSampling == nil {
				m.RandomSampling = &envoy_type1.Percent{}
			}
			if err := m.RandomSampling.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverallSampling", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OverallSampling == nil {
				m.OverallSampling = &envoy_type1.Percent{}
			}
			if err := m.OverallSampling.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHttpConnectionManager(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HttpConnectionManager_SetCurrentClientCertDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHttpConnectionManager
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetCurrentClientCertDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetCurrentClientCertDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subject", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Subject == nil {
				m.Subject = &google_protobuf1.BoolValue{}
			}
			if err := m.Subject.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field San", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.San == nil {
				m.San = &google_protobuf1.BoolValue{}
			}
			if err := m.San.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cert", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Cert = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipHttpConnectionManager(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Rds) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHttpConnectionManager
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Rds: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Rds: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigSource", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ConfigSource.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteConfigName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RouteConfigName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHttpConnectionManager(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HttpFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHttpConnectionManager
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HttpFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HttpFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Config == nil {
				m.Config = &google_protobuf.Struct{}
			}
			if err := m.Config.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeprecatedV1", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeprecatedV1 == nil {
				m.DeprecatedV1 = &HttpFilter_DeprecatedV1{}
			}
			if err := m.DeprecatedV1.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHttpConnectionManager(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HttpFilter_DeprecatedV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHttpConnectionManager
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeprecatedV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeprecatedV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHttpConnectionManager(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHttpConnectionManager
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipHttpConnectionManager(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowHttpConnectionManager
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowHttpConnectionManager
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthHttpConnectionManager
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowHttpConnectionManager
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipHttpConnectionManager(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthHttpConnectionManager = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowHttpConnectionManager   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("envoy/config/filter/network/http_connection_manager/v2/http_connection_manager.proto", fileDescriptorHttpConnectionManager)
}

var fileDescriptorHttpConnectionManager = []byte{
	// 1406 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x56, 0xcd, 0x6e, 0x1b, 0x47,
	0x12, 0xd6, 0x90, 0xd4, 0x0f, 0x8b, 0x94, 0x34, 0x6a, 0xc9, 0xf6, 0xac, 0xbc, 0x2b, 0x11, 0x02,
	0x16, 0x2b, 0x78, 0x8d, 0xa1, 0xc8, 0xf5, 0x7a, 0x0f, 0xbb, 0x58, 0x2c, 0xa9, 0x9f, 0x95, 0x0c,
	0x5b, 0x12, 0x86, 0xb4, 0x0d, 0x3b, 0x08, 0x1a, 0xed, 0x99, 0x26, 0x35, 0x09, 0x39, 0x3d, 0xe9,
	0xee, 0xa1, 0xa5, 0x53, 0x00, 0x9f, 0x82, 0x1c, 0x03, 0x24, 0xc8, 0x2d, 0x87, 0x3c, 0x40, 0x90,
	0x5b, 0x90, 0x93, 0x6f, 0xf1, 0x31, 0x4f, 0x90, 0x04, 0xbe, 0xf9, 0x15, 0x72, 0x0a, 0xba, 0x7b,
	0x86, 0x12, 0xf5, 0xe7, 0xc0, 0x76, 0x6e, 0x3d, 0x55, 0xdf, 0xf7, 0x55, 0x4d, 0x77, 0x75, 0x75,
	0x41, 0x9b, 0x46, 0x03, 0x76, 0x54, 0xf5, 0x59, 0xd4, 0x09, 0xbb, 0xd5, 0x4e, 0xd8, 0x93, 0x94,
	0x57, 0x23, 0x2a, 0x9f, 0x32, 0xfe, 0x61, 0xf5, 0x40, 0xca, 0x18, 0xfb, 0x2c, 0x8a, 0xa8, 0x2f,
	0x43, 0x16, 0xe1, 0x3e, 0x89, 0x48, 0x97, 0xf2, 0xea, 0xa0, 0x7e, 0x91, 0xcb, 0x8d, 0x39, 0x93,
	0x0c, 0xdd, 0xd6, 0xaa, 0xae, 0x51, 0x75, 0x8d, 0xaa, 0x9b, 0xaa, 0xba, 0x17, 0x51, 0x07, 0xf5,
	0xc5, 0xbf, 0x9a, 0x6c, 0x48, 0x1c, 0xaa, 0x18, 0x3e, 0xe3, 0x34, 0xcd, 0x0c, 0x0b, 0x96, 0x70,
	0x9f, 0x1a, 0xf9, 0xc5, 0xca, 0x59, 0x98, 0x76, 0xf8, 0xac, 0x97, 0x22, 0xae, 0x8e, 0x20, 0x78,
	0x20, 0x52, 0xfb, 0xda, 0x79, 0xbf, 0x4b, 0x7c, 0x9f, 0x0a, 0xd1, 0x63, 0x5d, 0x85, 0x1d, 0x7e,
	0xa4, 0x0c, 0xc7, 0x30, 0xe4, 0x51, 0x4c, 0xab, 0x31, 0xe5, 0x3e, 0x8d, 0x64, 0xea, 0x59, 0xea,
	0x32, 0xd6, 0xed, 0xa5, 0xa1, 0x9f, 0x24, 0x9d, 0x6a, 0x90, 0x70, 0xa2, 0xfe, 0x28, 0xf5, 0xff,
	0xf9, 0xb4, 0x5f, 0x48, 0x9e, 0xf8, 0x17, 0xb2, 0x9f, 0x72, 0x12, 0xc7, 0x94, 0x67, 0x99, 0x5e,
	0x1b, 0x90, 0x5e, 0x18, 0x10, 0x49, 0xab, 0xd9, 0x22, 0x75, 0x2c, 0x74, 0x59, 0x97, 0xe9, 0x65,
	0x55, 0xad, 0x8c, 0x75, 0xe5, 0xab, 0x05, 0xb8, 0xb2, 0x2d, 0x65, 0xbc, 0x3e, 0xdc, 0xd7, 0x7b,
	0x66, 0x5b, 0xd1, 0x33, 0x0b, 0xc0, 0x67, 0x01, 0xf5, 0xb1, 0xfa, 0x07, 0xc7, 0xaa, 0x58, 0xab,
	0x33, 0xf5, 0x87, 0xee, 0x9b, 0x9d, 0x90, 0x7b, 0x6e, 0x0c, 0x77, 0x5d, 0xe9, 0xb7, 0x8f, 0x62,
	0xda, 0x84, 0xef, 0x5f, 0x3d, 0xcf, 0x8f, 0x3f, 0xb3, 0x72, 0xb6, 0xe5, 0x15, 0xfd, 0xcc, 0x8c,
	0x6e, 0x40, 0x49, 0x48, 0x22, 0x71, 0xcc, 0x69, 0x27, 0x3c, 0x74, 0x72, 0x15, 0x6b, 0xb5, 0xd8,
	0x2c, 0x2a, 0x6c, 0x81, 0xe7, 0x2a, 0x96, 0x07, 0xca, 0xbb, 0xaf, 0x9d, 0x68, 0x0f, 0xf2, 0x3c,
	0x10, 0x4e, 0xbe, 0x62, 0xad, 0x96, 0xea, 0xff, 0x7e, 0xd3, 0x44, 0xbd, 0x40, 0x6c, 0x8f, 0x79,
	0x4a, 0x09, 0x6d, 0x42, 0x99, 0xb3, 0x44, 0x52, 0x6c, 0x44, 0x9c, 0x82, 0x56, 0xae, 0xa4, 0xca,
	0x24, 0x0e, 0x35, 0x5e, 0x21, 0xd6, 0x35, 0x20, 0x3d, 0xc6, 0xed, 0x31, 0xaf, 0xc4, 0x8f, 0xad,
	0x88, 0x42, 0x59, 0xc7, 0x33, 0x39, 0x08, 0x67, 0xbc, 0x92, 0x5f, 0x2d, 0xd5, 0x9b, 0x6f, 0xb3,
	0x93, 0x5b, 0x1a, 0xed, 0x95, 0x0e, 0x86, 0x6b, 0x81, 0xfe, 0x07, 0x33, 0x24, 0x08, 0x70, 0x22,
	0x28, 0xc7, 0xa4, 0x4b, 0x23, 0xe9, 0x4c, 0xe8, 0x7c, 0x17, 0x5d, 0x53, 0x31, 0x6e, 0x56, 0x31,
	0x6e, 0x93, 0xb1, 0xde, 0x03, 0xd2, 0x4b, 0xa8, 0x57, 0x26, 0x41, 0x70, 0x5f, 0x50, 0xde, 0x50,
	0x78, 0xc4, 0x60, 0x52, 0x72, 0xe2, 0x87, 0x51, 0xd7, 0x99, 0xd4, 0xd4, 0xfb, 0xef, 0xf6, 0xb4,
	0xdb, 0x46, 0xdc, 0xcb, 0xa2, 0xa0, 0xf7, 0xe0, 0x8a, 0x16, 0xc9, 0x2e, 0x21, 0x66, 0xb1, 0xc2,
	0x0b, 0x67, 0x4a, 0x87, 0xff, 0xdb, 0xe8, 0x4e, 0xab, 0xfb, 0xaa, 0x95, 0x6b, 0xfb, 0x29, 0x7e,
	0xcf, 0xc0, 0xbd, 0x79, 0xa5, 0x72, 0xca, 0x88, 0xde, 0x87, 0xab, 0xca, 0x5c, 0x3f, 0xab, 0x5e,
	0xbc, 0x54, 0xbd, 0x7e, 0x5a, 0x7d, 0xe1, 0xe0, 0x1c, 0x2b, 0x5a, 0x86, 0x92, 0xa0, 0x7c, 0x40,
	0x39, 0x8e, 0x48, 0x9f, 0x3a, 0xa0, 0x2a, 0xd3, 0x03, 0x63, 0xda, 0x25, 0x7d, 0x8a, 0x9a, 0x50,
	0x0e, 0x83, 0x1e, 0xc5, 0x32, 0xec, 0x53, 0x96, 0x48, 0xa7, 0xa4, 0xa3, 0xfe, 0xe9, 0xcc, 0x69,
	0x6c, 0xa4, 0x65, 0xd3, 0x2c, 0x7c, 0xf9, 0xf3, 0xb2, 0xe5, 0x95, 0x14, 0xa9, 0x6d, 0x38, 0x68,
	0x03, 0xa6, 0x03, 0x4e, 0xc2, 0x68, 0x28, 0x52, 0xfe, 0x7d, 0x22, 0x65, 0xcd, 0xca, 0x54, 0xee,
	0x00, 0x98, 0xee, 0x84, 0x7b, 0xac, 0xeb, 0x4c, 0xeb, 0xf2, 0xfb, 0xfb, 0xb9, 0x47, 0x7b, 0xdc,
	0xc4, 0x06, 0x75, 0xb7, 0xa1, 0x3f, 0xee, 0xb2, 0xae, 0x57, 0x24, 0xd9, 0x12, 0x6d, 0x03, 0x4a,
	0x04, 0xc5, 0x9c, 0xf6, 0x99, 0xa4, 0x98, 0x04, 0x01, 0xa7, 0x42, 0x38, 0x33, 0xaf, 0xad, 0x34,
	0x3b, 0x11, 0xd4, 0xd3, 0xa4, 0x86, 0xe1, 0xa0, 0x3b, 0x30, 0xdf, 0xa5, 0x11, 0xe5, 0x44, 0x2a,
	0xb9, 0x8f, 0x12, 0x2a, 0x24, 0x0e, 0x03, 0x67, 0xf6, 0xb5, 0x52, 0x73, 0x19, 0xcd, 0x33, 0xac,
	0x9d, 0x00, 0x7d, 0x6b, 0xc1, 0xf5, 0x0e, 0xe3, 0x4f, 0x09, 0x0f, 0xb0, 0xdf, 0x0b, 0x69, 0x24,
	0xb1, 0x4f, 0xb9, 0xc4, 0x01, 0x95, 0x24, 0xec, 0x09, 0xc7, 0xd6, 0xcd, 0xab, 0xf3, 0x6e, 0xcb,
	0x79, 0xcb, 0x04, 0x5c, 0xd7, 0xf1, 0xd6, 0x29, 0x97, 0x1b, 0x26, 0xda, 0x48, 0x2f, 0x73, 0x3a,
	0x17, 0xa0, 0xd0, 0x37, 0x16, 0x2c, 0x0b, 0x2a, 0xb1, 0x9f, 0x70, 0xae, 0x13, 0x3e, 0x27, 0xef,
	0x39, 0xbd, 0x19, 0xe1, 0xbb, 0xcd, 0xbb, 0x45, 0xe5, 0xba, 0x89, 0x79, 0x26, 0x29, 0xef, 0xba,
	0xb8, 0xd8, 0x89, 0x6e, 0x02, 0x8a, 0x39, 0x3b, 0x3c, 0xc2, 0xb5, 0xb5, 0x35, 0x15, 0x51, 0x86,
	0x51, 0x42, 0x1d, 0x54, 0xb1, 0x56, 0xa7, 0x3c, 0x5b, 0x7b, 0x6a, 0x6b, 0x6b, 0xeb, 0xa9, 0x1d,
	0x55, 0x61, 0xe1, 0xb0, 0xd3, 0xc1, 0x51, 0xd2, 0xc7, 0x92, 0x27, 0x42, 0xd2, 0x00, 0x1f, 0xb0,
	0x58, 0x38, 0xf3, 0x15, 0x6b, 0x75, 0xda, 0x9b, 0x3b, 0xec, 0x74, 0x76, 0x93, 0x7e, 0xdb, 0x78,
	0xb6, 0x59, 0x2c, 0x10, 0x85, 0x1a, 0xa7, 0x31, 0xa7, 0x42, 0x6d, 0x43, 0x18, 0x0f, 0x6e, 0x9d,
	0xaa, 0x32, 0x4c, 0x84, 0x31, 0xf7, 0xd5, 0x83, 0x17, 0xa8, 0xf5, 0x6d, 0x67, 0x41, 0x47, 0xbf,
	0x31, 0x24, 0xee, 0xc4, 0x83, 0x5b, 0x23, 0x75, 0xd6, 0x10, 0xca, 0x74, 0x4f, 0x53, 0x76, 0xe2,
	0xc1, 0xed, 0xc5, 0x1f, 0xf2, 0x30, 0x99, 0x76, 0x22, 0xf4, 0x85, 0x05, 0x33, 0x2c, 0xa6, 0xe6,
	0xee, 0x98, 0x8b, 0x6c, 0xde, 0x39, 0xff, 0x0f, 0xe9, 0x7c, 0xee, 0x5e, 0x16, 0x4b, 0x75, 0x88,
	0x91, 0x3a, 0x99, 0x66, 0x27, 0x5d, 0xe8, 0x5f, 0xe0, 0x64, 0x77, 0xe2, 0x80, 0x92, 0x80, 0x72,
	0x81, 0x3b, 0x8c, 0x63, 0x49, 0xba, 0xc2, 0xc9, 0x55, 0xf2, 0xab, 0x45, 0xef, 0x4a, 0xea, 0xdf,
	0x36, 0xee, 0x2d, 0xc6, 0xdb, 0xa4, 0x2b, 0xd0, 0x7f, 0x60, 0x36, 0x2d, 0x24, 0x41, 0xfa, 0x71,
	0x4f, 0xf5, 0x72, 0xf3, 0x20, 0xce, 0xa7, 0x7f, 0xa4, 0x1e, 0x73, 0x77, 0xdf, 0x0c, 0x24, 0xde,
	0x8c, 0xc1, 0xb6, 0x52, 0xa8, 0x62, 0x73, 0x12, 0x05, 0xac, 0x7f, 0xcc, 0x2e, 0x5c, 0xc2, 0x36,
	0xd8, 0x21, 0xfb, 0xbf, 0x60, 0xb3, 0x01, 0xe5, 0xa4, 0xd7, 0x3b, 0xa6, 0x8f, 0x5f, 0x4c, 0x9f,
	0x4d, 0xc1, 0x19, 0x7f, 0xc5, 0x85, 0xe9, 0x91, 0x0d, 0x42, 0x25, 0x98, 0xdc, 0xd9, 0xfd, 0xbf,
	0xb7, 0xd9, 0x6a, 0xd9, 0x63, 0x08, 0x60, 0x62, 0xd3, 0xac, 0xad, 0xc5, 0xc2, 0x27, 0x5f, 0x2f,
	0x8d, 0x2d, 0x7e, 0x6e, 0xc1, 0xf5, 0x4b, 0x8a, 0x19, 0xdd, 0x82, 0x49, 0x91, 0x3c, 0xf9, 0x80,
	0xfa, 0x52, 0x9f, 0xea, 0xe5, 0x5d, 0x25, 0x83, 0xa2, 0x9b, 0x90, 0x17, 0x24, 0xd2, 0xa3, 0xc6,
	0xe5, 0x0c, 0x05, 0x43, 0x08, 0x0a, 0xea, 0xc6, 0xea, 0x4d, 0x9e, 0xf2, 0xf4, 0x7a, 0xa5, 0x06,
	0xc5, 0xe1, 0x60, 0x83, 0xa6, 0xa0, 0xd0, 0xb8, 0xdf, 0xde, 0xb3, 0xc7, 0x50, 0x11, 0xc6, 0xb7,
	0xdb, 0xed, 0xfd, 0x9a, 0x6d, 0x65, 0xcb, 0xba, 0x9d, 0x33, 0xbf, 0xb2, 0xf2, 0x31, 0x38, 0x17,
	0xb5, 0x13, 0x54, 0x86, 0xa9, 0x56, 0x63, 0x77, 0xa7, 0xbd, 0xf3, 0x78, 0xd3, 0x1e, 0x43, 0x36,
	0x94, 0xb7, 0xf6, 0xbc, 0x87, 0x0d, 0x6f, 0x03, 0xef, 0xed, 0xde, 0x7d, 0x64, 0x5b, 0x08, 0xc1,
	0x4c, 0x63, 0x7f, 0x7f, 0x73, 0x77, 0x03, 0xa7, 0x0e, 0x3b, 0xa7, 0x50, 0x19, 0x07, 0xb7, 0x36,
	0xdb, 0x76, 0x1e, 0x5d, 0x83, 0xf9, 0xc6, 0xdd, 0x87, 0x8d, 0x47, 0x2d, 0x3c, 0x42, 0x2f, 0x98,
	0x04, 0x9a, 0x0e, 0xcc, 0x9a, 0x59, 0x47, 0xc4, 0xd4, 0x0f, 0x3b, 0x21, 0xe5, 0x68, 0xfc, 0xbb,
	0x57, 0xcf, 0xf3, 0xd6, 0xca, 0x67, 0x16, 0xe4, 0xbd, 0x40, 0xa0, 0x36, 0x4c, 0x8f, 0xcc, 0xd4,
	0xe9, 0x9e, 0x2e, 0x9f, 0xf3, 0x8c, 0x9a, 0xc1, 0xa7, 0xa5, 0x61, 0xcd, 0x99, 0x17, 0x3f, 0x2d,
	0x8f, 0xe9, 0x4a, 0xff, 0x54, 0x57, 0x7a, 0xd9, 0x3f, 0xe1, 0x45, 0xff, 0x84, 0xb9, 0x93, 0x33,
	0x96, 0xb9, 0x83, 0x67, 0xc6, 0xbc, 0xd9, 0x13, 0xf3, 0x94, 0xaa, 0x8c, 0x95, 0x5f, 0x2d, 0x80,
	0xe3, 0x41, 0x08, 0xfd, 0x05, 0x0a, 0xc3, 0xcb, 0x3b, 0x42, 0xd4, 0x66, 0x54, 0x85, 0x89, 0x74,
	0x84, 0x33, 0xa7, 0x7a, 0xed, 0xcc, 0xa9, 0xb6, 0xf4, 0x88, 0xed, 0xa5, 0x30, 0x74, 0x08, 0xd3,
	0x81, 0xea, 0x28, 0x3e, 0x51, 0x6d, 0x6b, 0x50, 0x4b, 0xef, 0xd0, 0xde, 0xdb, 0xcf, 0x6c, 0xee,
	0xc6, 0x50, 0xf7, 0x41, 0xad, 0x99, 0x73, 0xd4, 0x5b, 0x7d, 0xc2, 0xb2, 0xb8, 0x02, 0xe5, 0x93,
	0x08, 0x55, 0x5f, 0xc3, 0xf1, 0xbb, 0xe8, 0xe9, 0x75, 0xd3, 0x7e, 0xf1, 0x72, 0xc9, 0xfa, 0xf1,
	0xe5, 0x92, 0xf5, 0xcb, 0xcb, 0x25, 0xeb, 0x71, 0x6e, 0x50, 0x7f, 0x32, 0xa1, 0x7f, 0xe4, 0x1f,
	0xbf, 0x05, 0x00, 0x00, 0xff, 0xff, 0x7e, 0xc8, 0x6b, 0x0a, 0x96, 0x0d, 0x00, 0x00,
}
