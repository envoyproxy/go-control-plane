// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: envoy/data/accesslog/v2/accesslog.proto

package envoy_data_accesslog_v2

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import core "github.com/envoyproxy/go-control-plane/envoy/api/v2/core"
import _ "github.com/gogo/protobuf/gogoproto"
import types "github.com/gogo/protobuf/types"
import _ "github.com/lyft/protoc-gen-validate/validate"

import time "time"

import encoding_binary "encoding/binary"
import github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// HTTP version
type HTTPAccessLogEntry_HTTPVersion int32

const (
	HTTPAccessLogEntry_PROTOCOL_UNSPECIFIED HTTPAccessLogEntry_HTTPVersion = 0
	HTTPAccessLogEntry_HTTP10               HTTPAccessLogEntry_HTTPVersion = 1
	HTTPAccessLogEntry_HTTP11               HTTPAccessLogEntry_HTTPVersion = 2
	HTTPAccessLogEntry_HTTP2                HTTPAccessLogEntry_HTTPVersion = 3
)

var HTTPAccessLogEntry_HTTPVersion_name = map[int32]string{
	0: "PROTOCOL_UNSPECIFIED",
	1: "HTTP10",
	2: "HTTP11",
	3: "HTTP2",
}
var HTTPAccessLogEntry_HTTPVersion_value = map[string]int32{
	"PROTOCOL_UNSPECIFIED": 0,
	"HTTP10":               1,
	"HTTP11":               2,
	"HTTP2":                3,
}

func (x HTTPAccessLogEntry_HTTPVersion) String() string {
	return proto.EnumName(HTTPAccessLogEntry_HTTPVersion_name, int32(x))
}
func (HTTPAccessLogEntry_HTTPVersion) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_accesslog_f7d38ea1e253147a, []int{1, 0}
}

// Reasons why the request was unauthorized
type ResponseFlags_Unauthorized_Reason int32

const (
	ResponseFlags_Unauthorized_REASON_UNSPECIFIED ResponseFlags_Unauthorized_Reason = 0
	// The request was denied by the external authorization service.
	ResponseFlags_Unauthorized_EXTERNAL_SERVICE ResponseFlags_Unauthorized_Reason = 1
)

var ResponseFlags_Unauthorized_Reason_name = map[int32]string{
	0: "REASON_UNSPECIFIED",
	1: "EXTERNAL_SERVICE",
}
var ResponseFlags_Unauthorized_Reason_value = map[string]int32{
	"REASON_UNSPECIFIED": 0,
	"EXTERNAL_SERVICE":   1,
}

func (x ResponseFlags_Unauthorized_Reason) String() string {
	return proto.EnumName(ResponseFlags_Unauthorized_Reason_name, int32(x))
}
func (ResponseFlags_Unauthorized_Reason) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_accesslog_f7d38ea1e253147a, []int{3, 0, 0}
}

type TLSProperties_TLSVersion int32

const (
	TLSProperties_VERSION_UNSPECIFIED TLSProperties_TLSVersion = 0
	TLSProperties_TLSv1               TLSProperties_TLSVersion = 1
	TLSProperties_TLSv1_1             TLSProperties_TLSVersion = 2
	TLSProperties_TLSv1_2             TLSProperties_TLSVersion = 3
	TLSProperties_TLSv1_3             TLSProperties_TLSVersion = 4
)

var TLSProperties_TLSVersion_name = map[int32]string{
	0: "VERSION_UNSPECIFIED",
	1: "TLSv1",
	2: "TLSv1_1",
	3: "TLSv1_2",
	4: "TLSv1_3",
}
var TLSProperties_TLSVersion_value = map[string]int32{
	"VERSION_UNSPECIFIED": 0,
	"TLSv1":               1,
	"TLSv1_1":             2,
	"TLSv1_2":             3,
	"TLSv1_3":             4,
}

func (x TLSProperties_TLSVersion) String() string {
	return proto.EnumName(TLSProperties_TLSVersion_name, int32(x))
}
func (TLSProperties_TLSVersion) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_accesslog_f7d38ea1e253147a, []int{4, 0}
}

// [#not-implemented-hide:]
type TCPAccessLogEntry struct {
	// Common properties shared by all Envoy access logs.
	CommonProperties     *AccessLogCommon `protobuf:"bytes,1,opt,name=common_properties,json=commonProperties" json:"common_properties,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *TCPAccessLogEntry) Reset()         { *m = TCPAccessLogEntry{} }
func (m *TCPAccessLogEntry) String() string { return proto.CompactTextString(m) }
func (*TCPAccessLogEntry) ProtoMessage()    {}
func (*TCPAccessLogEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_accesslog_f7d38ea1e253147a, []int{0}
}
func (m *TCPAccessLogEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TCPAccessLogEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TCPAccessLogEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TCPAccessLogEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TCPAccessLogEntry.Merge(dst, src)
}
func (m *TCPAccessLogEntry) XXX_Size() int {
	return m.Size()
}
func (m *TCPAccessLogEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_TCPAccessLogEntry.DiscardUnknown(m)
}

var xxx_messageInfo_TCPAccessLogEntry proto.InternalMessageInfo

func (m *TCPAccessLogEntry) GetCommonProperties() *AccessLogCommon {
	if m != nil {
		return m.CommonProperties
	}
	return nil
}

type HTTPAccessLogEntry struct {
	// Common properties shared by all Envoy access logs.
	CommonProperties *AccessLogCommon               `protobuf:"bytes,1,opt,name=common_properties,json=commonProperties" json:"common_properties,omitempty"`
	ProtocolVersion  HTTPAccessLogEntry_HTTPVersion `protobuf:"varint,2,opt,name=protocol_version,json=protocolVersion,proto3,enum=envoy.data.accesslog.v2.HTTPAccessLogEntry_HTTPVersion" json:"protocol_version,omitempty"`
	// Description of the incoming HTTP request.
	Request *HTTPRequestProperties `protobuf:"bytes,3,opt,name=request" json:"request,omitempty"`
	// Description of the outgoing HTTP response.
	Response             *HTTPResponseProperties `protobuf:"bytes,4,opt,name=response" json:"response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *HTTPAccessLogEntry) Reset()         { *m = HTTPAccessLogEntry{} }
func (m *HTTPAccessLogEntry) String() string { return proto.CompactTextString(m) }
func (*HTTPAccessLogEntry) ProtoMessage()    {}
func (*HTTPAccessLogEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_accesslog_f7d38ea1e253147a, []int{1}
}
func (m *HTTPAccessLogEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HTTPAccessLogEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HTTPAccessLogEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *HTTPAccessLogEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HTTPAccessLogEntry.Merge(dst, src)
}
func (m *HTTPAccessLogEntry) XXX_Size() int {
	return m.Size()
}
func (m *HTTPAccessLogEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_HTTPAccessLogEntry.DiscardUnknown(m)
}

var xxx_messageInfo_HTTPAccessLogEntry proto.InternalMessageInfo

func (m *HTTPAccessLogEntry) GetCommonProperties() *AccessLogCommon {
	if m != nil {
		return m.CommonProperties
	}
	return nil
}

func (m *HTTPAccessLogEntry) GetProtocolVersion() HTTPAccessLogEntry_HTTPVersion {
	if m != nil {
		return m.ProtocolVersion
	}
	return HTTPAccessLogEntry_PROTOCOL_UNSPECIFIED
}

func (m *HTTPAccessLogEntry) GetRequest() *HTTPRequestProperties {
	if m != nil {
		return m.Request
	}
	return nil
}

func (m *HTTPAccessLogEntry) GetResponse() *HTTPResponseProperties {
	if m != nil {
		return m.Response
	}
	return nil
}

// Defines fields that are shared by all Envoy access logs.
type AccessLogCommon struct {
	// [#not-implemented-hide:]
	// This field indicates the rate at which this log entry was sampled.
	// Valid range is (0.0, 1.0].
	SampleRate float64 `protobuf:"fixed64,1,opt,name=sample_rate,json=sampleRate,proto3" json:"sample_rate,omitempty"`
	// This field is the remote/origin address on which the request from the user was received.
	// Note: This may not be the physical peer. E.g, if the remote address is inferred from for
	// example the x-forwarder-for header, proxy protocol, etc.
	DownstreamRemoteAddress *core.Address `protobuf:"bytes,2,opt,name=downstream_remote_address,json=downstreamRemoteAddress" json:"downstream_remote_address,omitempty"`
	// This field is the local/destination address on which the request from the user was received.
	DownstreamLocalAddress *core.Address `protobuf:"bytes,3,opt,name=downstream_local_address,json=downstreamLocalAddress" json:"downstream_local_address,omitempty"`
	// [#not-implemented-hide:]
	// If the connection is secure,S this field will contain TLS properties.
	TlsProperties *TLSProperties `protobuf:"bytes,4,opt,name=tls_properties,json=tlsProperties" json:"tls_properties,omitempty"`
	// The time that Envoy started servicing this request. This is effectively the time that the first
	// downstream byte is received.
	StartTime *time.Time `protobuf:"bytes,5,opt,name=start_time,json=startTime,stdtime" json:"start_time,omitempty"`
	// Interval between the first downstream byte received and the last
	// downstream byte received (i.e. time it takes to receive a request).
	TimeToLastRxByte *time.Duration `protobuf:"bytes,6,opt,name=time_to_last_rx_byte,json=timeToLastRxByte,stdduration" json:"time_to_last_rx_byte,omitempty"`
	// Interval between the first downstream byte received and the first upstream byte sent. There may
	// by considerable delta between *time_to_last_rx_byte* and this value due to filters.
	// Additionally, the same caveats apply as documented in *time_to_last_downstream_tx_byte* about
	// not accounting for kernel socket buffer time, etc.
	TimeToFirstUpstreamTxByte *time.Duration `protobuf:"bytes,7,opt,name=time_to_first_upstream_tx_byte,json=timeToFirstUpstreamTxByte,stdduration" json:"time_to_first_upstream_tx_byte,omitempty"`
	// Interval between the first downstream byte received and the last upstream byte sent. There may
	// by considerable delta between *time_to_last_rx_byte* and this value due to filters.
	// Additionally, the same caveats apply as documented in *time_to_last_downstream_tx_byte* about
	// not accounting for kernel socket buffer time, etc.
	TimeToLastUpstreamTxByte *time.Duration `protobuf:"bytes,8,opt,name=time_to_last_upstream_tx_byte,json=timeToLastUpstreamTxByte,stdduration" json:"time_to_last_upstream_tx_byte,omitempty"`
	// Interval between the first downstream byte received and the first upstream
	// byte received (i.e. time it takes to start receiving a response).
	TimeToFirstUpstreamRxByte *time.Duration `protobuf:"bytes,9,opt,name=time_to_first_upstream_rx_byte,json=timeToFirstUpstreamRxByte,stdduration" json:"time_to_first_upstream_rx_byte,omitempty"`
	// Interval between the first downstream byte received and the last upstream
	// byte received (i.e. time it takes to receive a complete response).
	TimeToLastUpstreamRxByte *time.Duration `protobuf:"bytes,10,opt,name=time_to_last_upstream_rx_byte,json=timeToLastUpstreamRxByte,stdduration" json:"time_to_last_upstream_rx_byte,omitempty"`
	// Interval between the first downstream byte received and the first downstream byte sent.
	// There may be a considerable delta between the *time_to_first_upstream_rx_byte* and this field
	// due to filters. Additionally, the same caveats apply as documented in
	// *time_to_last_downstream_tx_byte* about not accounting for kernel socket buffer time, etc.
	TimeToFirstDownstreamTxByte *time.Duration `protobuf:"bytes,11,opt,name=time_to_first_downstream_tx_byte,json=timeToFirstDownstreamTxByte,stdduration" json:"time_to_first_downstream_tx_byte,omitempty"`
	// Interval between the first downstream byte received and the last downstream byte sent.
	// Depending on protocol, buffering, windowing, filters, etc. there may be a considerable delta
	// between *time_to_last_upstream_rx_byte* and this field. Note also that this is an approximate
	// time. In the current implementation it does not include kernel socket buffer time. In the
	// current implementation it also does not include send window buffering inside the HTTP/2 codec.
	// In the future it is likely that work will be done to make this duration more accurate.
	TimeToLastDownstreamTxByte *time.Duration `protobuf:"bytes,12,opt,name=time_to_last_downstream_tx_byte,json=timeToLastDownstreamTxByte,stdduration" json:"time_to_last_downstream_tx_byte,omitempty"`
	// The upstream remote/destination address that handles this exchange. This does not include
	// retries.
	UpstreamRemoteAddress *core.Address `protobuf:"bytes,13,opt,name=upstream_remote_address,json=upstreamRemoteAddress" json:"upstream_remote_address,omitempty"`
	// The upstream local/origin address that handles this exchange. This does not include retries.
	UpstreamLocalAddress *core.Address `protobuf:"bytes,14,opt,name=upstream_local_address,json=upstreamLocalAddress" json:"upstream_local_address,omitempty"`
	// The upstream cluster that *upstream_remote_address* belongs to.
	UpstreamCluster string `protobuf:"bytes,15,opt,name=upstream_cluster,json=upstreamCluster,proto3" json:"upstream_cluster,omitempty"`
	// Flags indicating occurrences during request/response processing.
	ResponseFlags *ResponseFlags `protobuf:"bytes,16,opt,name=response_flags,json=responseFlags" json:"response_flags,omitempty"`
	// All metadata encountered during request processing, including endpoint
	// selection.
	//
	// This can be used to associate IDs attached to the various configurations
	// used to process this request with the access log entry. For example, a
	// route created from a higher level forwarding rule with some ID can place
	// that ID in this field and cross reference later. It can also be used to
	// determine if a canary endpoint was used or not.
	Metadata             *core.Metadata `protobuf:"bytes,17,opt,name=metadata" json:"metadata,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *AccessLogCommon) Reset()         { *m = AccessLogCommon{} }
func (m *AccessLogCommon) String() string { return proto.CompactTextString(m) }
func (*AccessLogCommon) ProtoMessage()    {}
func (*AccessLogCommon) Descriptor() ([]byte, []int) {
	return fileDescriptor_accesslog_f7d38ea1e253147a, []int{2}
}
func (m *AccessLogCommon) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccessLogCommon) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccessLogCommon.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *AccessLogCommon) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccessLogCommon.Merge(dst, src)
}
func (m *AccessLogCommon) XXX_Size() int {
	return m.Size()
}
func (m *AccessLogCommon) XXX_DiscardUnknown() {
	xxx_messageInfo_AccessLogCommon.DiscardUnknown(m)
}

var xxx_messageInfo_AccessLogCommon proto.InternalMessageInfo

func (m *AccessLogCommon) GetSampleRate() float64 {
	if m != nil {
		return m.SampleRate
	}
	return 0
}

func (m *AccessLogCommon) GetDownstreamRemoteAddress() *core.Address {
	if m != nil {
		return m.DownstreamRemoteAddress
	}
	return nil
}

func (m *AccessLogCommon) GetDownstreamLocalAddress() *core.Address {
	if m != nil {
		return m.DownstreamLocalAddress
	}
	return nil
}

func (m *AccessLogCommon) GetTlsProperties() *TLSProperties {
	if m != nil {
		return m.TlsProperties
	}
	return nil
}

func (m *AccessLogCommon) GetStartTime() *time.Time {
	if m != nil {
		return m.StartTime
	}
	return nil
}

func (m *AccessLogCommon) GetTimeToLastRxByte() *time.Duration {
	if m != nil {
		return m.TimeToLastRxByte
	}
	return nil
}

func (m *AccessLogCommon) GetTimeToFirstUpstreamTxByte() *time.Duration {
	if m != nil {
		return m.TimeToFirstUpstreamTxByte
	}
	return nil
}

func (m *AccessLogCommon) GetTimeToLastUpstreamTxByte() *time.Duration {
	if m != nil {
		return m.TimeToLastUpstreamTxByte
	}
	return nil
}

func (m *AccessLogCommon) GetTimeToFirstUpstreamRxByte() *time.Duration {
	if m != nil {
		return m.TimeToFirstUpstreamRxByte
	}
	return nil
}

func (m *AccessLogCommon) GetTimeToLastUpstreamRxByte() *time.Duration {
	if m != nil {
		return m.TimeToLastUpstreamRxByte
	}
	return nil
}

func (m *AccessLogCommon) GetTimeToFirstDownstreamTxByte() *time.Duration {
	if m != nil {
		return m.TimeToFirstDownstreamTxByte
	}
	return nil
}

func (m *AccessLogCommon) GetTimeToLastDownstreamTxByte() *time.Duration {
	if m != nil {
		return m.TimeToLastDownstreamTxByte
	}
	return nil
}

func (m *AccessLogCommon) GetUpstreamRemoteAddress() *core.Address {
	if m != nil {
		return m.UpstreamRemoteAddress
	}
	return nil
}

func (m *AccessLogCommon) GetUpstreamLocalAddress() *core.Address {
	if m != nil {
		return m.UpstreamLocalAddress
	}
	return nil
}

func (m *AccessLogCommon) GetUpstreamCluster() string {
	if m != nil {
		return m.UpstreamCluster
	}
	return ""
}

func (m *AccessLogCommon) GetResponseFlags() *ResponseFlags {
	if m != nil {
		return m.ResponseFlags
	}
	return nil
}

func (m *AccessLogCommon) GetMetadata() *core.Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

// Flags indicating occurrences during request/response processing.
type ResponseFlags struct {
	// Indicates local server healthcheck failed.
	FailedLocalHealthcheck bool `protobuf:"varint,1,opt,name=failed_local_healthcheck,json=failedLocalHealthcheck,proto3" json:"failed_local_healthcheck,omitempty"`
	// Indicates there was no healthy upstream.
	NoHealthyUpstream bool `protobuf:"varint,2,opt,name=no_healthy_upstream,json=noHealthyUpstream,proto3" json:"no_healthy_upstream,omitempty"`
	// Indicates an there was an upstream request timeout.
	UpstreamRequestTimeout bool `protobuf:"varint,3,opt,name=upstream_request_timeout,json=upstreamRequestTimeout,proto3" json:"upstream_request_timeout,omitempty"`
	// Indicates local codec level reset was sent on the stream.
	LocalReset bool `protobuf:"varint,4,opt,name=local_reset,json=localReset,proto3" json:"local_reset,omitempty"`
	// Indicates remote codec level reset was received on the stream.
	UpstreamRemoteReset bool `protobuf:"varint,5,opt,name=upstream_remote_reset,json=upstreamRemoteReset,proto3" json:"upstream_remote_reset,omitempty"`
	// Indicates there was a local reset by a connection pool due to an initial connection failure.
	UpstreamConnectionFailure bool `protobuf:"varint,6,opt,name=upstream_connection_failure,json=upstreamConnectionFailure,proto3" json:"upstream_connection_failure,omitempty"`
	// Indicates the stream was reset locally due to connection termination.
	UpstreamConnectionTermination bool `protobuf:"varint,7,opt,name=upstream_connection_termination,json=upstreamConnectionTermination,proto3" json:"upstream_connection_termination,omitempty"`
	// Indicates the stream was reset because of a resource overflow.
	UpstreamOverflow bool `protobuf:"varint,8,opt,name=upstream_overflow,json=upstreamOverflow,proto3" json:"upstream_overflow,omitempty"`
	// Indicates no route was found for the request.
	NoRouteFound bool `protobuf:"varint,9,opt,name=no_route_found,json=noRouteFound,proto3" json:"no_route_found,omitempty"`
	// Indicates that the request was delayed before proxying.
	DelayInjected bool `protobuf:"varint,10,opt,name=delay_injected,json=delayInjected,proto3" json:"delay_injected,omitempty"`
	// Indicates that the request was aborted with an injected error code.
	FaultInjected bool `protobuf:"varint,11,opt,name=fault_injected,json=faultInjected,proto3" json:"fault_injected,omitempty"`
	// Indicates that the request was rate-limited locally.
	RateLimited bool `protobuf:"varint,12,opt,name=rate_limited,json=rateLimited,proto3" json:"rate_limited,omitempty"`
	// Indicates if the request was deemed unauthorized and the reason for it.
	UnauthorizedDetails *ResponseFlags_Unauthorized `protobuf:"bytes,13,opt,name=unauthorized_details,json=unauthorizedDetails" json:"unauthorized_details,omitempty"`
	// Indicates that the request was rejected because there was an error in rate limit service.
	RateLimitServiceError bool     `protobuf:"varint,14,opt,name=rate_limit_service_error,json=rateLimitServiceError,proto3" json:"rate_limit_service_error,omitempty"`
	XXX_NoUnkeyedLiteral  struct{} `json:"-"`
	XXX_unrecognized      []byte   `json:"-"`
	XXX_sizecache         int32    `json:"-"`
}

func (m *ResponseFlags) Reset()         { *m = ResponseFlags{} }
func (m *ResponseFlags) String() string { return proto.CompactTextString(m) }
func (*ResponseFlags) ProtoMessage()    {}
func (*ResponseFlags) Descriptor() ([]byte, []int) {
	return fileDescriptor_accesslog_f7d38ea1e253147a, []int{3}
}
func (m *ResponseFlags) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResponseFlags) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResponseFlags.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ResponseFlags) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResponseFlags.Merge(dst, src)
}
func (m *ResponseFlags) XXX_Size() int {
	return m.Size()
}
func (m *ResponseFlags) XXX_DiscardUnknown() {
	xxx_messageInfo_ResponseFlags.DiscardUnknown(m)
}

var xxx_messageInfo_ResponseFlags proto.InternalMessageInfo

func (m *ResponseFlags) GetFailedLocalHealthcheck() bool {
	if m != nil {
		return m.FailedLocalHealthcheck
	}
	return false
}

func (m *ResponseFlags) GetNoHealthyUpstream() bool {
	if m != nil {
		return m.NoHealthyUpstream
	}
	return false
}

func (m *ResponseFlags) GetUpstreamRequestTimeout() bool {
	if m != nil {
		return m.UpstreamRequestTimeout
	}
	return false
}

func (m *ResponseFlags) GetLocalReset() bool {
	if m != nil {
		return m.LocalReset
	}
	return false
}

func (m *ResponseFlags) GetUpstreamRemoteReset() bool {
	if m != nil {
		return m.UpstreamRemoteReset
	}
	return false
}

func (m *ResponseFlags) GetUpstreamConnectionFailure() bool {
	if m != nil {
		return m.UpstreamConnectionFailure
	}
	return false
}

func (m *ResponseFlags) GetUpstreamConnectionTermination() bool {
	if m != nil {
		return m.UpstreamConnectionTermination
	}
	return false
}

func (m *ResponseFlags) GetUpstreamOverflow() bool {
	if m != nil {
		return m.UpstreamOverflow
	}
	return false
}

func (m *ResponseFlags) GetNoRouteFound() bool {
	if m != nil {
		return m.NoRouteFound
	}
	return false
}

func (m *ResponseFlags) GetDelayInjected() bool {
	if m != nil {
		return m.DelayInjected
	}
	return false
}

func (m *ResponseFlags) GetFaultInjected() bool {
	if m != nil {
		return m.FaultInjected
	}
	return false
}

func (m *ResponseFlags) GetRateLimited() bool {
	if m != nil {
		return m.RateLimited
	}
	return false
}

func (m *ResponseFlags) GetUnauthorizedDetails() *ResponseFlags_Unauthorized {
	if m != nil {
		return m.UnauthorizedDetails
	}
	return nil
}

func (m *ResponseFlags) GetRateLimitServiceError() bool {
	if m != nil {
		return m.RateLimitServiceError
	}
	return false
}

type ResponseFlags_Unauthorized struct {
	Reason               ResponseFlags_Unauthorized_Reason `protobuf:"varint,1,opt,name=reason,proto3,enum=envoy.data.accesslog.v2.ResponseFlags_Unauthorized_Reason" json:"reason,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                          `json:"-"`
	XXX_unrecognized     []byte                            `json:"-"`
	XXX_sizecache        int32                             `json:"-"`
}

func (m *ResponseFlags_Unauthorized) Reset()         { *m = ResponseFlags_Unauthorized{} }
func (m *ResponseFlags_Unauthorized) String() string { return proto.CompactTextString(m) }
func (*ResponseFlags_Unauthorized) ProtoMessage()    {}
func (*ResponseFlags_Unauthorized) Descriptor() ([]byte, []int) {
	return fileDescriptor_accesslog_f7d38ea1e253147a, []int{3, 0}
}
func (m *ResponseFlags_Unauthorized) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResponseFlags_Unauthorized) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResponseFlags_Unauthorized.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ResponseFlags_Unauthorized) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResponseFlags_Unauthorized.Merge(dst, src)
}
func (m *ResponseFlags_Unauthorized) XXX_Size() int {
	return m.Size()
}
func (m *ResponseFlags_Unauthorized) XXX_DiscardUnknown() {
	xxx_messageInfo_ResponseFlags_Unauthorized.DiscardUnknown(m)
}

var xxx_messageInfo_ResponseFlags_Unauthorized proto.InternalMessageInfo

func (m *ResponseFlags_Unauthorized) GetReason() ResponseFlags_Unauthorized_Reason {
	if m != nil {
		return m.Reason
	}
	return ResponseFlags_Unauthorized_REASON_UNSPECIFIED
}

// [#not-implemented-hide:]
// Properties of a negotiated TLS connection.
type TLSProperties struct {
	// Version of TLS that was negotiated.
	TlsVersion TLSProperties_TLSVersion `protobuf:"varint,1,opt,name=tls_version,json=tlsVersion,proto3,enum=envoy.data.accesslog.v2.TLSProperties_TLSVersion" json:"tls_version,omitempty"`
	// TLS cipher suite negotiated during handshake. The value is a
	// four-digit hex code defined by the IANA TLS Cipher Suite Registry
	// (e.g. ``009C`` for ``TLS_RSA_WITH_AES_128_GCM_SHA256``).
	//
	// Here it is expressed as an integer.
	TlsCipherSuite *types.UInt32Value `protobuf:"bytes,2,opt,name=tls_cipher_suite,json=tlsCipherSuite" json:"tls_cipher_suite,omitempty"`
	// SNI hostname from handshake.
	TlsSniHostname       string   `protobuf:"bytes,3,opt,name=tls_sni_hostname,json=tlsSniHostname,proto3" json:"tls_sni_hostname,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TLSProperties) Reset()         { *m = TLSProperties{} }
func (m *TLSProperties) String() string { return proto.CompactTextString(m) }
func (*TLSProperties) ProtoMessage()    {}
func (*TLSProperties) Descriptor() ([]byte, []int) {
	return fileDescriptor_accesslog_f7d38ea1e253147a, []int{4}
}
func (m *TLSProperties) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLSProperties) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLSProperties.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TLSProperties) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLSProperties.Merge(dst, src)
}
func (m *TLSProperties) XXX_Size() int {
	return m.Size()
}
func (m *TLSProperties) XXX_DiscardUnknown() {
	xxx_messageInfo_TLSProperties.DiscardUnknown(m)
}

var xxx_messageInfo_TLSProperties proto.InternalMessageInfo

func (m *TLSProperties) GetTlsVersion() TLSProperties_TLSVersion {
	if m != nil {
		return m.TlsVersion
	}
	return TLSProperties_VERSION_UNSPECIFIED
}

func (m *TLSProperties) GetTlsCipherSuite() *types.UInt32Value {
	if m != nil {
		return m.TlsCipherSuite
	}
	return nil
}

func (m *TLSProperties) GetTlsSniHostname() string {
	if m != nil {
		return m.TlsSniHostname
	}
	return ""
}

type HTTPRequestProperties struct {
	// The request method (RFC 7231/2616).
	// [#comment:TODO(htuch): add (validate.rules).enum.defined_only = true once
	// https://github.com/lyft/protoc-gen-validate/issues/42 is resolved.]
	RequestMethod core.RequestMethod `protobuf:"varint,1,opt,name=request_method,json=requestMethod,proto3,enum=envoy.api.v2.core.RequestMethod" json:"request_method,omitempty"`
	// The scheme portion of the incoming request URI.
	Scheme string `protobuf:"bytes,2,opt,name=scheme,proto3" json:"scheme,omitempty"`
	// HTTP/2 ``:authority`` or HTTP/1.1 ``Host`` header value.
	Authority string `protobuf:"bytes,3,opt,name=authority,proto3" json:"authority,omitempty"`
	// The port of the incoming request URI
	// (unused currently, as port is composed onto authority).
	Port *types.UInt32Value `protobuf:"bytes,4,opt,name=port" json:"port,omitempty"`
	// The path portion from the incoming request URI.
	Path string `protobuf:"bytes,5,opt,name=path,proto3" json:"path,omitempty"`
	// Value of the ``User-Agent`` request header.
	UserAgent string `protobuf:"bytes,6,opt,name=user_agent,json=userAgent,proto3" json:"user_agent,omitempty"`
	// Value of the ``Referer`` request header.
	Referer string `protobuf:"bytes,7,opt,name=referer,proto3" json:"referer,omitempty"`
	// Value of the ``X-Forwarded-For`` request header.
	ForwardedFor string `protobuf:"bytes,8,opt,name=forwarded_for,json=forwardedFor,proto3" json:"forwarded_for,omitempty"`
	// Value of the ``X-Request-Id`` request header
	//
	// This header is used by Envoy to uniquely identify a request.
	// It will be generated for all external requests and internal requests that
	// do not already have a request ID.
	RequestId string `protobuf:"bytes,9,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	// Value of the ``X-Envoy-Original-Path`` request header.
	OriginalPath string `protobuf:"bytes,10,opt,name=original_path,json=originalPath,proto3" json:"original_path,omitempty"`
	// Size of the HTTP request headers in bytes.
	//
	// This value is captured from the OSI layer 7 perspective, i.e. it does not
	// include overhead from framing or encoding at other networking layers.
	RequestHeadersBytes uint64 `protobuf:"varint,11,opt,name=request_headers_bytes,json=requestHeadersBytes,proto3" json:"request_headers_bytes,omitempty"`
	// Size of the HTTP request body in bytes.
	//
	// This value is captured from the OSI layer 7 perspective, i.e. it does not
	// include overhead from framing or encoding at other networking layers.
	RequestBodyBytes uint64 `protobuf:"varint,12,opt,name=request_body_bytes,json=requestBodyBytes,proto3" json:"request_body_bytes,omitempty"`
	// Map of additional headers that have been configured to be logged.
	RequestHeaders       map[string]string `protobuf:"bytes,13,rep,name=request_headers,json=requestHeaders" json:"request_headers,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *HTTPRequestProperties) Reset()         { *m = HTTPRequestProperties{} }
func (m *HTTPRequestProperties) String() string { return proto.CompactTextString(m) }
func (*HTTPRequestProperties) ProtoMessage()    {}
func (*HTTPRequestProperties) Descriptor() ([]byte, []int) {
	return fileDescriptor_accesslog_f7d38ea1e253147a, []int{5}
}
func (m *HTTPRequestProperties) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HTTPRequestProperties) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HTTPRequestProperties.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *HTTPRequestProperties) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HTTPRequestProperties.Merge(dst, src)
}
func (m *HTTPRequestProperties) XXX_Size() int {
	return m.Size()
}
func (m *HTTPRequestProperties) XXX_DiscardUnknown() {
	xxx_messageInfo_HTTPRequestProperties.DiscardUnknown(m)
}

var xxx_messageInfo_HTTPRequestProperties proto.InternalMessageInfo

func (m *HTTPRequestProperties) GetRequestMethod() core.RequestMethod {
	if m != nil {
		return m.RequestMethod
	}
	return core.METHOD_UNSPECIFIED
}

func (m *HTTPRequestProperties) GetScheme() string {
	if m != nil {
		return m.Scheme
	}
	return ""
}

func (m *HTTPRequestProperties) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *HTTPRequestProperties) GetPort() *types.UInt32Value {
	if m != nil {
		return m.Port
	}
	return nil
}

func (m *HTTPRequestProperties) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *HTTPRequestProperties) GetUserAgent() string {
	if m != nil {
		return m.UserAgent
	}
	return ""
}

func (m *HTTPRequestProperties) GetReferer() string {
	if m != nil {
		return m.Referer
	}
	return ""
}

func (m *HTTPRequestProperties) GetForwardedFor() string {
	if m != nil {
		return m.ForwardedFor
	}
	return ""
}

func (m *HTTPRequestProperties) GetRequestId() string {
	if m != nil {
		return m.RequestId
	}
	return ""
}

func (m *HTTPRequestProperties) GetOriginalPath() string {
	if m != nil {
		return m.OriginalPath
	}
	return ""
}

func (m *HTTPRequestProperties) GetRequestHeadersBytes() uint64 {
	if m != nil {
		return m.RequestHeadersBytes
	}
	return 0
}

func (m *HTTPRequestProperties) GetRequestBodyBytes() uint64 {
	if m != nil {
		return m.RequestBodyBytes
	}
	return 0
}

func (m *HTTPRequestProperties) GetRequestHeaders() map[string]string {
	if m != nil {
		return m.RequestHeaders
	}
	return nil
}

type HTTPResponseProperties struct {
	// The HTTP response code returned by Envoy.
	ResponseCode *types.UInt32Value `protobuf:"bytes,1,opt,name=response_code,json=responseCode" json:"response_code,omitempty"`
	// Size of the HTTP response headers in bytes.
	//
	// This value is captured from the OSI layer 7 perspective, i.e. it does not
	// include overhead from framing or encoding at other networking layers.
	ResponseHeadersBytes uint64 `protobuf:"varint,2,opt,name=response_headers_bytes,json=responseHeadersBytes,proto3" json:"response_headers_bytes,omitempty"`
	// Size of the HTTP response body in bytes.
	//
	// This value is captured from the OSI layer 7 perspective, i.e. it does not
	// include overhead from framing or encoding at other networking layers.
	ResponseBodyBytes uint64 `protobuf:"varint,3,opt,name=response_body_bytes,json=responseBodyBytes,proto3" json:"response_body_bytes,omitempty"`
	// Map of additional headers configured to be logged.
	ResponseHeaders map[string]string `protobuf:"bytes,4,rep,name=response_headers,json=responseHeaders" json:"response_headers,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Map of trailers configured to be logged.
	ResponseTrailers     map[string]string `protobuf:"bytes,5,rep,name=response_trailers,json=responseTrailers" json:"response_trailers,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *HTTPResponseProperties) Reset()         { *m = HTTPResponseProperties{} }
func (m *HTTPResponseProperties) String() string { return proto.CompactTextString(m) }
func (*HTTPResponseProperties) ProtoMessage()    {}
func (*HTTPResponseProperties) Descriptor() ([]byte, []int) {
	return fileDescriptor_accesslog_f7d38ea1e253147a, []int{6}
}
func (m *HTTPResponseProperties) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HTTPResponseProperties) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HTTPResponseProperties.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *HTTPResponseProperties) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HTTPResponseProperties.Merge(dst, src)
}
func (m *HTTPResponseProperties) XXX_Size() int {
	return m.Size()
}
func (m *HTTPResponseProperties) XXX_DiscardUnknown() {
	xxx_messageInfo_HTTPResponseProperties.DiscardUnknown(m)
}

var xxx_messageInfo_HTTPResponseProperties proto.InternalMessageInfo

func (m *HTTPResponseProperties) GetResponseCode() *types.UInt32Value {
	if m != nil {
		return m.ResponseCode
	}
	return nil
}

func (m *HTTPResponseProperties) GetResponseHeadersBytes() uint64 {
	if m != nil {
		return m.ResponseHeadersBytes
	}
	return 0
}

func (m *HTTPResponseProperties) GetResponseBodyBytes() uint64 {
	if m != nil {
		return m.ResponseBodyBytes
	}
	return 0
}

func (m *HTTPResponseProperties) GetResponseHeaders() map[string]string {
	if m != nil {
		return m.ResponseHeaders
	}
	return nil
}

func (m *HTTPResponseProperties) GetResponseTrailers() map[string]string {
	if m != nil {
		return m.ResponseTrailers
	}
	return nil
}

func init() {
	proto.RegisterType((*TCPAccessLogEntry)(nil), "envoy.data.accesslog.v2.TCPAccessLogEntry")
	proto.RegisterType((*HTTPAccessLogEntry)(nil), "envoy.data.accesslog.v2.HTTPAccessLogEntry")
	proto.RegisterType((*AccessLogCommon)(nil), "envoy.data.accesslog.v2.AccessLogCommon")
	proto.RegisterType((*ResponseFlags)(nil), "envoy.data.accesslog.v2.ResponseFlags")
	proto.RegisterType((*ResponseFlags_Unauthorized)(nil), "envoy.data.accesslog.v2.ResponseFlags.Unauthorized")
	proto.RegisterType((*TLSProperties)(nil), "envoy.data.accesslog.v2.TLSProperties")
	proto.RegisterType((*HTTPRequestProperties)(nil), "envoy.data.accesslog.v2.HTTPRequestProperties")
	proto.RegisterMapType((map[string]string)(nil), "envoy.data.accesslog.v2.HTTPRequestProperties.RequestHeadersEntry")
	proto.RegisterType((*HTTPResponseProperties)(nil), "envoy.data.accesslog.v2.HTTPResponseProperties")
	proto.RegisterMapType((map[string]string)(nil), "envoy.data.accesslog.v2.HTTPResponseProperties.ResponseHeadersEntry")
	proto.RegisterMapType((map[string]string)(nil), "envoy.data.accesslog.v2.HTTPResponseProperties.ResponseTrailersEntry")
	proto.RegisterEnum("envoy.data.accesslog.v2.HTTPAccessLogEntry_HTTPVersion", HTTPAccessLogEntry_HTTPVersion_name, HTTPAccessLogEntry_HTTPVersion_value)
	proto.RegisterEnum("envoy.data.accesslog.v2.ResponseFlags_Unauthorized_Reason", ResponseFlags_Unauthorized_Reason_name, ResponseFlags_Unauthorized_Reason_value)
	proto.RegisterEnum("envoy.data.accesslog.v2.TLSProperties_TLSVersion", TLSProperties_TLSVersion_name, TLSProperties_TLSVersion_value)
}
func (m *TCPAccessLogEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TCPAccessLogEntry) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CommonProperties != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(m.CommonProperties.Size()))
		n1, err := m.CommonProperties.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *HTTPAccessLogEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HTTPAccessLogEntry) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CommonProperties != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(m.CommonProperties.Size()))
		n2, err := m.CommonProperties.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.ProtocolVersion != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(m.ProtocolVersion))
	}
	if m.Request != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(m.Request.Size()))
		n3, err := m.Request.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.Response != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(m.Response.Size()))
		n4, err := m.Response.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AccessLogCommon) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccessLogCommon) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SampleRate != 0 {
		dAtA[i] = 0x9
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.SampleRate))))
		i += 8
	}
	if m.DownstreamRemoteAddress != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(m.DownstreamRemoteAddress.Size()))
		n5, err := m.DownstreamRemoteAddress.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.DownstreamLocalAddress != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(m.DownstreamLocalAddress.Size()))
		n6, err := m.DownstreamLocalAddress.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.TlsProperties != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(m.TlsProperties.Size()))
		n7, err := m.TlsProperties.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.StartTime != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdTime(*m.StartTime)))
		n8, err := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.StartTime, dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.TimeToLastRxByte != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdDuration(*m.TimeToLastRxByte)))
		n9, err := github_com_gogo_protobuf_types.StdDurationMarshalTo(*m.TimeToLastRxByte, dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.TimeToFirstUpstreamTxByte != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdDuration(*m.TimeToFirstUpstreamTxByte)))
		n10, err := github_com_gogo_protobuf_types.StdDurationMarshalTo(*m.TimeToFirstUpstreamTxByte, dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.TimeToLastUpstreamTxByte != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdDuration(*m.TimeToLastUpstreamTxByte)))
		n11, err := github_com_gogo_protobuf_types.StdDurationMarshalTo(*m.TimeToLastUpstreamTxByte, dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.TimeToFirstUpstreamRxByte != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdDuration(*m.TimeToFirstUpstreamRxByte)))
		n12, err := github_com_gogo_protobuf_types.StdDurationMarshalTo(*m.TimeToFirstUpstreamRxByte, dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.TimeToLastUpstreamRxByte != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdDuration(*m.TimeToLastUpstreamRxByte)))
		n13, err := github_com_gogo_protobuf_types.StdDurationMarshalTo(*m.TimeToLastUpstreamRxByte, dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.TimeToFirstDownstreamTxByte != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdDuration(*m.TimeToFirstDownstreamTxByte)))
		n14, err := github_com_gogo_protobuf_types.StdDurationMarshalTo(*m.TimeToFirstDownstreamTxByte, dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.TimeToLastDownstreamTxByte != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdDuration(*m.TimeToLastDownstreamTxByte)))
		n15, err := github_com_gogo_protobuf_types.StdDurationMarshalTo(*m.TimeToLastDownstreamTxByte, dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.UpstreamRemoteAddress != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(m.UpstreamRemoteAddress.Size()))
		n16, err := m.UpstreamRemoteAddress.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.UpstreamLocalAddress != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(m.UpstreamLocalAddress.Size()))
		n17, err := m.UpstreamLocalAddress.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if len(m.UpstreamCluster) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(len(m.UpstreamCluster)))
		i += copy(dAtA[i:], m.UpstreamCluster)
	}
	if m.ResponseFlags != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(m.ResponseFlags.Size()))
		n18, err := m.ResponseFlags.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if m.Metadata != nil {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(m.Metadata.Size()))
		n19, err := m.Metadata.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ResponseFlags) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponseFlags) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FailedLocalHealthcheck {
		dAtA[i] = 0x8
		i++
		if m.FailedLocalHealthcheck {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.NoHealthyUpstream {
		dAtA[i] = 0x10
		i++
		if m.NoHealthyUpstream {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.UpstreamRequestTimeout {
		dAtA[i] = 0x18
		i++
		if m.UpstreamRequestTimeout {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.LocalReset {
		dAtA[i] = 0x20
		i++
		if m.LocalReset {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.UpstreamRemoteReset {
		dAtA[i] = 0x28
		i++
		if m.UpstreamRemoteReset {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.UpstreamConnectionFailure {
		dAtA[i] = 0x30
		i++
		if m.UpstreamConnectionFailure {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.UpstreamConnectionTermination {
		dAtA[i] = 0x38
		i++
		if m.UpstreamConnectionTermination {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.UpstreamOverflow {
		dAtA[i] = 0x40
		i++
		if m.UpstreamOverflow {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.NoRouteFound {
		dAtA[i] = 0x48
		i++
		if m.NoRouteFound {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DelayInjected {
		dAtA[i] = 0x50
		i++
		if m.DelayInjected {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.FaultInjected {
		dAtA[i] = 0x58
		i++
		if m.FaultInjected {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.RateLimited {
		dAtA[i] = 0x60
		i++
		if m.RateLimited {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.UnauthorizedDetails != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(m.UnauthorizedDetails.Size()))
		n20, err := m.UnauthorizedDetails.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if m.RateLimitServiceError {
		dAtA[i] = 0x70
		i++
		if m.RateLimitServiceError {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ResponseFlags_Unauthorized) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponseFlags_Unauthorized) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Reason != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(m.Reason))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TLSProperties) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLSProperties) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TlsVersion != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(m.TlsVersion))
	}
	if m.TlsCipherSuite != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(m.TlsCipherSuite.Size()))
		n21, err := m.TlsCipherSuite.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if len(m.TlsSniHostname) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(len(m.TlsSniHostname)))
		i += copy(dAtA[i:], m.TlsSniHostname)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *HTTPRequestProperties) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HTTPRequestProperties) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RequestMethod != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(m.RequestMethod))
	}
	if len(m.Scheme) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(len(m.Scheme)))
		i += copy(dAtA[i:], m.Scheme)
	}
	if len(m.Authority) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(len(m.Authority)))
		i += copy(dAtA[i:], m.Authority)
	}
	if m.Port != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(m.Port.Size()))
		n22, err := m.Port.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	if len(m.Path) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(len(m.Path)))
		i += copy(dAtA[i:], m.Path)
	}
	if len(m.UserAgent) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(len(m.UserAgent)))
		i += copy(dAtA[i:], m.UserAgent)
	}
	if len(m.Referer) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(len(m.Referer)))
		i += copy(dAtA[i:], m.Referer)
	}
	if len(m.ForwardedFor) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(len(m.ForwardedFor)))
		i += copy(dAtA[i:], m.ForwardedFor)
	}
	if len(m.RequestId) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(len(m.RequestId)))
		i += copy(dAtA[i:], m.RequestId)
	}
	if len(m.OriginalPath) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(len(m.OriginalPath)))
		i += copy(dAtA[i:], m.OriginalPath)
	}
	if m.RequestHeadersBytes != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(m.RequestHeadersBytes))
	}
	if m.RequestBodyBytes != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(m.RequestBodyBytes))
	}
	if len(m.RequestHeaders) > 0 {
		for k, _ := range m.RequestHeaders {
			dAtA[i] = 0x6a
			i++
			v := m.RequestHeaders[k]
			mapSize := 1 + len(k) + sovAccesslog(uint64(len(k))) + 1 + len(v) + sovAccesslog(uint64(len(v)))
			i = encodeVarintAccesslog(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintAccesslog(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintAccesslog(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *HTTPResponseProperties) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HTTPResponseProperties) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ResponseCode != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(m.ResponseCode.Size()))
		n23, err := m.ResponseCode.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	if m.ResponseHeadersBytes != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(m.ResponseHeadersBytes))
	}
	if m.ResponseBodyBytes != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAccesslog(dAtA, i, uint64(m.ResponseBodyBytes))
	}
	if len(m.ResponseHeaders) > 0 {
		for k, _ := range m.ResponseHeaders {
			dAtA[i] = 0x22
			i++
			v := m.ResponseHeaders[k]
			mapSize := 1 + len(k) + sovAccesslog(uint64(len(k))) + 1 + len(v) + sovAccesslog(uint64(len(v)))
			i = encodeVarintAccesslog(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintAccesslog(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintAccesslog(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.ResponseTrailers) > 0 {
		for k, _ := range m.ResponseTrailers {
			dAtA[i] = 0x2a
			i++
			v := m.ResponseTrailers[k]
			mapSize := 1 + len(k) + sovAccesslog(uint64(len(k))) + 1 + len(v) + sovAccesslog(uint64(len(v)))
			i = encodeVarintAccesslog(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintAccesslog(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintAccesslog(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintAccesslog(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *TCPAccessLogEntry) Size() (n int) {
	var l int
	_ = l
	if m.CommonProperties != nil {
		l = m.CommonProperties.Size()
		n += 1 + l + sovAccesslog(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HTTPAccessLogEntry) Size() (n int) {
	var l int
	_ = l
	if m.CommonProperties != nil {
		l = m.CommonProperties.Size()
		n += 1 + l + sovAccesslog(uint64(l))
	}
	if m.ProtocolVersion != 0 {
		n += 1 + sovAccesslog(uint64(m.ProtocolVersion))
	}
	if m.Request != nil {
		l = m.Request.Size()
		n += 1 + l + sovAccesslog(uint64(l))
	}
	if m.Response != nil {
		l = m.Response.Size()
		n += 1 + l + sovAccesslog(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AccessLogCommon) Size() (n int) {
	var l int
	_ = l
	if m.SampleRate != 0 {
		n += 9
	}
	if m.DownstreamRemoteAddress != nil {
		l = m.DownstreamRemoteAddress.Size()
		n += 1 + l + sovAccesslog(uint64(l))
	}
	if m.DownstreamLocalAddress != nil {
		l = m.DownstreamLocalAddress.Size()
		n += 1 + l + sovAccesslog(uint64(l))
	}
	if m.TlsProperties != nil {
		l = m.TlsProperties.Size()
		n += 1 + l + sovAccesslog(uint64(l))
	}
	if m.StartTime != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.StartTime)
		n += 1 + l + sovAccesslog(uint64(l))
	}
	if m.TimeToLastRxByte != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdDuration(*m.TimeToLastRxByte)
		n += 1 + l + sovAccesslog(uint64(l))
	}
	if m.TimeToFirstUpstreamTxByte != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdDuration(*m.TimeToFirstUpstreamTxByte)
		n += 1 + l + sovAccesslog(uint64(l))
	}
	if m.TimeToLastUpstreamTxByte != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdDuration(*m.TimeToLastUpstreamTxByte)
		n += 1 + l + sovAccesslog(uint64(l))
	}
	if m.TimeToFirstUpstreamRxByte != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdDuration(*m.TimeToFirstUpstreamRxByte)
		n += 1 + l + sovAccesslog(uint64(l))
	}
	if m.TimeToLastUpstreamRxByte != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdDuration(*m.TimeToLastUpstreamRxByte)
		n += 1 + l + sovAccesslog(uint64(l))
	}
	if m.TimeToFirstDownstreamTxByte != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdDuration(*m.TimeToFirstDownstreamTxByte)
		n += 1 + l + sovAccesslog(uint64(l))
	}
	if m.TimeToLastDownstreamTxByte != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdDuration(*m.TimeToLastDownstreamTxByte)
		n += 1 + l + sovAccesslog(uint64(l))
	}
	if m.UpstreamRemoteAddress != nil {
		l = m.UpstreamRemoteAddress.Size()
		n += 1 + l + sovAccesslog(uint64(l))
	}
	if m.UpstreamLocalAddress != nil {
		l = m.UpstreamLocalAddress.Size()
		n += 1 + l + sovAccesslog(uint64(l))
	}
	l = len(m.UpstreamCluster)
	if l > 0 {
		n += 1 + l + sovAccesslog(uint64(l))
	}
	if m.ResponseFlags != nil {
		l = m.ResponseFlags.Size()
		n += 2 + l + sovAccesslog(uint64(l))
	}
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 2 + l + sovAccesslog(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResponseFlags) Size() (n int) {
	var l int
	_ = l
	if m.FailedLocalHealthcheck {
		n += 2
	}
	if m.NoHealthyUpstream {
		n += 2
	}
	if m.UpstreamRequestTimeout {
		n += 2
	}
	if m.LocalReset {
		n += 2
	}
	if m.UpstreamRemoteReset {
		n += 2
	}
	if m.UpstreamConnectionFailure {
		n += 2
	}
	if m.UpstreamConnectionTermination {
		n += 2
	}
	if m.UpstreamOverflow {
		n += 2
	}
	if m.NoRouteFound {
		n += 2
	}
	if m.DelayInjected {
		n += 2
	}
	if m.FaultInjected {
		n += 2
	}
	if m.RateLimited {
		n += 2
	}
	if m.UnauthorizedDetails != nil {
		l = m.UnauthorizedDetails.Size()
		n += 1 + l + sovAccesslog(uint64(l))
	}
	if m.RateLimitServiceError {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResponseFlags_Unauthorized) Size() (n int) {
	var l int
	_ = l
	if m.Reason != 0 {
		n += 1 + sovAccesslog(uint64(m.Reason))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLSProperties) Size() (n int) {
	var l int
	_ = l
	if m.TlsVersion != 0 {
		n += 1 + sovAccesslog(uint64(m.TlsVersion))
	}
	if m.TlsCipherSuite != nil {
		l = m.TlsCipherSuite.Size()
		n += 1 + l + sovAccesslog(uint64(l))
	}
	l = len(m.TlsSniHostname)
	if l > 0 {
		n += 1 + l + sovAccesslog(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HTTPRequestProperties) Size() (n int) {
	var l int
	_ = l
	if m.RequestMethod != 0 {
		n += 1 + sovAccesslog(uint64(m.RequestMethod))
	}
	l = len(m.Scheme)
	if l > 0 {
		n += 1 + l + sovAccesslog(uint64(l))
	}
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovAccesslog(uint64(l))
	}
	if m.Port != nil {
		l = m.Port.Size()
		n += 1 + l + sovAccesslog(uint64(l))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovAccesslog(uint64(l))
	}
	l = len(m.UserAgent)
	if l > 0 {
		n += 1 + l + sovAccesslog(uint64(l))
	}
	l = len(m.Referer)
	if l > 0 {
		n += 1 + l + sovAccesslog(uint64(l))
	}
	l = len(m.ForwardedFor)
	if l > 0 {
		n += 1 + l + sovAccesslog(uint64(l))
	}
	l = len(m.RequestId)
	if l > 0 {
		n += 1 + l + sovAccesslog(uint64(l))
	}
	l = len(m.OriginalPath)
	if l > 0 {
		n += 1 + l + sovAccesslog(uint64(l))
	}
	if m.RequestHeadersBytes != 0 {
		n += 1 + sovAccesslog(uint64(m.RequestHeadersBytes))
	}
	if m.RequestBodyBytes != 0 {
		n += 1 + sovAccesslog(uint64(m.RequestBodyBytes))
	}
	if len(m.RequestHeaders) > 0 {
		for k, v := range m.RequestHeaders {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAccesslog(uint64(len(k))) + 1 + len(v) + sovAccesslog(uint64(len(v)))
			n += mapEntrySize + 1 + sovAccesslog(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HTTPResponseProperties) Size() (n int) {
	var l int
	_ = l
	if m.ResponseCode != nil {
		l = m.ResponseCode.Size()
		n += 1 + l + sovAccesslog(uint64(l))
	}
	if m.ResponseHeadersBytes != 0 {
		n += 1 + sovAccesslog(uint64(m.ResponseHeadersBytes))
	}
	if m.ResponseBodyBytes != 0 {
		n += 1 + sovAccesslog(uint64(m.ResponseBodyBytes))
	}
	if len(m.ResponseHeaders) > 0 {
		for k, v := range m.ResponseHeaders {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAccesslog(uint64(len(k))) + 1 + len(v) + sovAccesslog(uint64(len(v)))
			n += mapEntrySize + 1 + sovAccesslog(uint64(mapEntrySize))
		}
	}
	if len(m.ResponseTrailers) > 0 {
		for k, v := range m.ResponseTrailers {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAccesslog(uint64(len(k))) + 1 + len(v) + sovAccesslog(uint64(len(v)))
			n += mapEntrySize + 1 + sovAccesslog(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovAccesslog(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozAccesslog(x uint64) (n int) {
	return sovAccesslog(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *TCPAccessLogEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccesslog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TCPAccessLogEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TCPAccessLogEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommonProperties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CommonProperties == nil {
				m.CommonProperties = &AccessLogCommon{}
			}
			if err := m.CommonProperties.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccesslog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccesslog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HTTPAccessLogEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccesslog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HTTPAccessLogEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HTTPAccessLogEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommonProperties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CommonProperties == nil {
				m.CommonProperties = &AccessLogCommon{}
			}
			if err := m.CommonProperties.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtocolVersion", wireType)
			}
			m.ProtocolVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProtocolVersion |= (HTTPAccessLogEntry_HTTPVersion(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Request == nil {
				m.Request = &HTTPRequestProperties{}
			}
			if err := m.Request.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Response == nil {
				m.Response = &HTTPResponseProperties{}
			}
			if err := m.Response.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccesslog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccesslog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccessLogCommon) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccesslog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccessLogCommon: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccessLogCommon: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field SampleRate", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.SampleRate = float64(math.Float64frombits(v))
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownstreamRemoteAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DownstreamRemoteAddress == nil {
				m.DownstreamRemoteAddress = &core.Address{}
			}
			if err := m.DownstreamRemoteAddress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownstreamLocalAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DownstreamLocalAddress == nil {
				m.DownstreamLocalAddress = &core.Address{}
			}
			if err := m.DownstreamLocalAddress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsProperties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TlsProperties == nil {
				m.TlsProperties = &TLSProperties{}
			}
			if err := m.TlsProperties.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartTime == nil {
				m.StartTime = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.StartTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeToLastRxByte", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TimeToLastRxByte == nil {
				m.TimeToLastRxByte = new(time.Duration)
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(m.TimeToLastRxByte, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeToFirstUpstreamTxByte", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TimeToFirstUpstreamTxByte == nil {
				m.TimeToFirstUpstreamTxByte = new(time.Duration)
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(m.TimeToFirstUpstreamTxByte, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeToLastUpstreamTxByte", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TimeToLastUpstreamTxByte == nil {
				m.TimeToLastUpstreamTxByte = new(time.Duration)
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(m.TimeToLastUpstreamTxByte, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeToFirstUpstreamRxByte", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TimeToFirstUpstreamRxByte == nil {
				m.TimeToFirstUpstreamRxByte = new(time.Duration)
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(m.TimeToFirstUpstreamRxByte, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeToLastUpstreamRxByte", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TimeToLastUpstreamRxByte == nil {
				m.TimeToLastUpstreamRxByte = new(time.Duration)
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(m.TimeToLastUpstreamRxByte, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeToFirstDownstreamTxByte", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TimeToFirstDownstreamTxByte == nil {
				m.TimeToFirstDownstreamTxByte = new(time.Duration)
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(m.TimeToFirstDownstreamTxByte, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeToLastDownstreamTxByte", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TimeToLastDownstreamTxByte == nil {
				m.TimeToLastDownstreamTxByte = new(time.Duration)
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(m.TimeToLastDownstreamTxByte, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpstreamRemoteAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpstreamRemoteAddress == nil {
				m.UpstreamRemoteAddress = &core.Address{}
			}
			if err := m.UpstreamRemoteAddress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpstreamLocalAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpstreamLocalAddress == nil {
				m.UpstreamLocalAddress = &core.Address{}
			}
			if err := m.UpstreamLocalAddress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpstreamCluster", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpstreamCluster = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseFlags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResponseFlags == nil {
				m.ResponseFlags = &ResponseFlags{}
			}
			if err := m.ResponseFlags.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &core.Metadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccesslog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccesslog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponseFlags) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccesslog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseFlags: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseFlags: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailedLocalHealthcheck", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FailedLocalHealthcheck = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoHealthyUpstream", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoHealthyUpstream = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpstreamRequestTimeout", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpstreamRequestTimeout = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalReset", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LocalReset = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpstreamRemoteReset", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpstreamRemoteReset = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpstreamConnectionFailure", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpstreamConnectionFailure = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpstreamConnectionTermination", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpstreamConnectionTermination = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpstreamOverflow", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpstreamOverflow = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoRouteFound", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoRouteFound = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelayInjected", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DelayInjected = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FaultInjected", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FaultInjected = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RateLimited", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RateLimited = bool(v != 0)
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnauthorizedDetails", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UnauthorizedDetails == nil {
				m.UnauthorizedDetails = &ResponseFlags_Unauthorized{}
			}
			if err := m.UnauthorizedDetails.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RateLimitServiceError", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RateLimitServiceError = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAccesslog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccesslog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponseFlags_Unauthorized) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccesslog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Unauthorized: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Unauthorized: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			m.Reason = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reason |= (ResponseFlags_Unauthorized_Reason(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAccesslog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccesslog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLSProperties) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccesslog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TLSProperties: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TLSProperties: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsVersion", wireType)
			}
			m.TlsVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TlsVersion |= (TLSProperties_TLSVersion(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsCipherSuite", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TlsCipherSuite == nil {
				m.TlsCipherSuite = &types.UInt32Value{}
			}
			if err := m.TlsCipherSuite.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsSniHostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TlsSniHostname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccesslog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccesslog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HTTPRequestProperties) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccesslog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HTTPRequestProperties: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HTTPRequestProperties: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestMethod", wireType)
			}
			m.RequestMethod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestMethod |= (core.RequestMethod(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scheme", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Scheme = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Port == nil {
				m.Port = &types.UInt32Value{}
			}
			if err := m.Port.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserAgent", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserAgent = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Referer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Referer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForwardedFor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ForwardedFor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginalPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OriginalPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeadersBytes", wireType)
			}
			m.RequestHeadersBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestHeadersBytes |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestBodyBytes", wireType)
			}
			m.RequestBodyBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestBodyBytes |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeaders", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RequestHeaders == nil {
				m.RequestHeaders = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAccesslog
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAccesslog
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAccesslog
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAccesslog
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAccesslog
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAccesslog(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthAccesslog
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.RequestHeaders[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccesslog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccesslog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HTTPResponseProperties) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccesslog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HTTPResponseProperties: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HTTPResponseProperties: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseCode", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResponseCode == nil {
				m.ResponseCode = &types.UInt32Value{}
			}
			if err := m.ResponseCode.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeadersBytes", wireType)
			}
			m.ResponseHeadersBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResponseHeadersBytes |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseBodyBytes", wireType)
			}
			m.ResponseBodyBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResponseBodyBytes |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeaders", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResponseHeaders == nil {
				m.ResponseHeaders = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAccesslog
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAccesslog
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAccesslog
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAccesslog
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAccesslog
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAccesslog(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthAccesslog
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ResponseHeaders[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseTrailers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccesslog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResponseTrailers == nil {
				m.ResponseTrailers = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAccesslog
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAccesslog
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAccesslog
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAccesslog
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAccesslog
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAccesslog(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthAccesslog
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ResponseTrailers[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccesslog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccesslog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAccesslog(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAccesslog
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAccesslog
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthAccesslog
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowAccesslog
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipAccesslog(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthAccesslog = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAccesslog   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("envoy/data/accesslog/v2/accesslog.proto", fileDescriptor_accesslog_f7d38ea1e253147a)
}

var fileDescriptor_accesslog_f7d38ea1e253147a = []byte{
	// 1726 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x57, 0xcd, 0x52, 0x23, 0xc9,
	0x11, 0x5e, 0x21, 0xc1, 0x48, 0x29, 0x01, 0x4d, 0x21, 0xa0, 0x61, 0x67, 0x80, 0x95, 0xff, 0x70,
	0xd8, 0x21, 0xed, 0x68, 0x1c, 0x9e, 0x8d, 0x3d, 0x78, 0x03, 0x84, 0x30, 0xd8, 0xcc, 0x40, 0x94,
	0x04, 0xf6, 0xad, 0x5d, 0xa8, 0x4b, 0x52, 0xef, 0xb4, 0xba, 0xe4, 0xaa, 0x92, 0x66, 0xe5, 0xa7,
	0xd8, 0xf0, 0xc1, 0xe1, 0xf0, 0x43, 0xd8, 0x11, 0x3e, 0xfa, 0xe4, 0xa3, 0x8f, 0x7e, 0x03, 0x3b,
	0xe6, 0xe6, 0x9b, 0x1f, 0xc1, 0x51, 0x3f, 0xdd, 0x2d, 0x81, 0x18, 0x98, 0x39, 0x58, 0xa7, 0xaa,
	0xcc, 0x2f, 0xbf, 0xfc, 0xa9, 0xac, 0xec, 0x12, 0xfc, 0x80, 0x46, 0x63, 0x36, 0xa9, 0xf9, 0x44,
	0x92, 0x1a, 0xe9, 0x74, 0xa8, 0x10, 0x21, 0xeb, 0xd5, 0xc6, 0xf5, 0x74, 0x53, 0x1d, 0x72, 0x26,
	0x19, 0xda, 0xd2, 0xc0, 0xaa, 0x02, 0x56, 0x53, 0xdd, 0xb8, 0xbe, 0xb3, 0x67, 0x18, 0xc8, 0x30,
	0x50, 0x66, 0x1d, 0xc6, 0x69, 0x8d, 0xf8, 0x3e, 0xa7, 0x42, 0x18, 0xcb, 0x9d, 0xa7, 0x77, 0x01,
	0x37, 0x44, 0x50, 0xab, 0xdd, 0xed, 0x31, 0xd6, 0x0b, 0x69, 0x4d, 0xef, 0x6e, 0x46, 0xdd, 0x9a,
	0x3f, 0xe2, 0x44, 0x06, 0x2c, 0xb2, 0xfa, 0xbd, 0xdb, 0x7a, 0x19, 0x0c, 0xa8, 0x90, 0x64, 0x30,
	0xbc, 0x8f, 0xe0, 0x2d, 0x27, 0xc3, 0x21, 0xe5, 0xb1, 0xfb, 0x72, 0x8f, 0xf5, 0x98, 0x5e, 0xd6,
	0xd4, 0xca, 0x4a, 0xb7, 0xc6, 0x24, 0x0c, 0x7c, 0x22, 0x69, 0x2d, 0x5e, 0x18, 0x45, 0xe5, 0x6b,
	0x58, 0x6b, 0x37, 0x2e, 0x0f, 0x75, 0x86, 0xe7, 0xac, 0xd7, 0x8c, 0x24, 0x9f, 0xa0, 0x2b, 0x58,
	0xeb, 0xb0, 0xc1, 0x80, 0x45, 0xde, 0x90, 0xb3, 0x21, 0xe5, 0x32, 0xa0, 0xc2, 0xcd, 0xec, 0x67,
	0x0e, 0x8a, 0xf5, 0x83, 0xea, 0x3d, 0x85, 0xa9, 0x26, 0x1c, 0x0d, 0x6d, 0x8a, 0x1d, 0x43, 0x71,
	0x99, 0x30, 0x54, 0xfe, 0x9a, 0x05, 0x74, 0xda, 0x6e, 0xff, 0x7f, 0xbc, 0xa1, 0x1b, 0x70, 0x74,
	0x8a, 0x1d, 0x16, 0x7a, 0x63, 0xca, 0x45, 0xc0, 0x22, 0x77, 0x61, 0x3f, 0x73, 0xb0, 0x52, 0x7f,
	0x79, 0x2f, 0xeb, 0xdd, 0xe8, 0xb4, 0xe8, 0xda, 0x98, 0xe3, 0xd5, 0x98, 0xd0, 0x0a, 0xd0, 0x29,
	0x3c, 0xe1, 0xf4, 0xb7, 0x23, 0x2a, 0xa4, 0x9b, 0xd5, 0x01, 0x57, 0xdf, 0x4b, 0x8d, 0x0d, 0x36,
	0x0d, 0x12, 0xc7, 0xe6, 0xe8, 0x97, 0x90, 0xe7, 0x54, 0x0c, 0x59, 0x24, 0xa8, 0x9b, 0xd3, 0x54,
	0xb5, 0x07, 0xa8, 0x0c, 0x78, 0x8a, 0x2b, 0x21, 0xa8, 0xfc, 0x02, 0x8a, 0x53, 0x61, 0x23, 0x17,
	0xca, 0x97, 0xf8, 0xa2, 0x7d, 0xd1, 0xb8, 0x38, 0xf7, 0xae, 0x5e, 0xb7, 0x2e, 0x9b, 0x8d, 0xb3,
	0x93, 0xb3, 0xe6, 0xb1, 0xf3, 0x09, 0x02, 0x58, 0x52, 0xc0, 0xe7, 0x9f, 0x3b, 0x99, 0x64, 0xfd,
	0xdc, 0x59, 0x40, 0x05, 0x58, 0x54, 0xeb, 0xba, 0x93, 0xad, 0xfc, 0xa1, 0x08, 0xab, 0xb7, 0x8a,
	0x8d, 0x0e, 0xa1, 0x28, 0xc8, 0x60, 0x18, 0x52, 0x8f, 0x13, 0x49, 0xf5, 0x59, 0x65, 0x8e, 0xf6,
	0xff, 0xf6, 0x9f, 0xbf, 0x67, 0x8b, 0xa8, 0xf0, 0xd9, 0x27, 0xf6, 0x67, 0xf7, 0xdb, 0x66, 0xf7,
	0xdf, 0xaf, 0x30, 0x18, 0x23, 0x4c, 0x24, 0x45, 0xd7, 0xb0, 0xed, 0xb3, 0xb7, 0x91, 0x90, 0x9c,
	0x92, 0x81, 0xc7, 0xe9, 0x80, 0x49, 0xea, 0xd9, 0x8b, 0xa4, 0x8f, 0xa9, 0x58, 0xdf, 0xb1, 0x05,
	0x20, 0xc3, 0x40, 0x65, 0xad, 0x6e, 0x52, 0xf5, 0xd0, 0x20, 0xf0, 0x56, 0x6a, 0x8c, 0xb5, 0xad,
	0x55, 0xa0, 0x36, 0xb8, 0x53, 0xbc, 0x21, 0xeb, 0x90, 0x30, 0xa1, 0xcd, 0x3e, 0x48, 0xbb, 0x99,
	0xda, 0x9e, 0x2b, 0xd3, 0x98, 0xf5, 0x15, 0xac, 0xc8, 0x50, 0x4c, 0xf7, 0xa7, 0x39, 0xa3, 0xef,
	0xdf, 0x7b, 0x46, 0xed, 0xf3, 0xd6, 0xd4, 0xd1, 0x2c, 0xcb, 0x50, 0x4c, 0xb5, 0xe6, 0x57, 0x00,
	0x42, 0x12, 0x2e, 0x3d, 0x75, 0xb9, 0xdd, 0x45, 0x1b, 0x96, 0xb9, 0xd8, 0xd5, 0xf8, 0x62, 0x57,
	0xdb, 0xf1, 0xcd, 0x3f, 0xca, 0x7d, 0xfb, 0xaf, 0xbd, 0x0c, 0x2e, 0x68, 0x1b, 0x25, 0x45, 0x17,
	0x50, 0x56, 0xa6, 0x9e, 0x64, 0x5e, 0x48, 0x84, 0xf4, 0xf8, 0x37, 0xde, 0xcd, 0x44, 0x52, 0x77,
	0x49, 0x53, 0x6d, 0xdf, 0xa1, 0x3a, 0xb6, 0x43, 0xe6, 0x28, 0xf7, 0x47, 0xc5, 0xe4, 0x28, 0xe3,
	0x36, 0x3b, 0x27, 0x42, 0xe2, 0x6f, 0x8e, 0x26, 0x92, 0xa2, 0x1b, 0xd8, 0x8d, 0x09, 0xbb, 0x01,
	0x17, 0xd2, 0x1b, 0x0d, 0x6d, 0x09, 0xa5, 0xa5, 0x7e, 0xf2, 0x38, 0xea, 0x6d, 0x43, 0x7d, 0xa2,
	0x48, 0xae, 0x2c, 0x47, 0xdb, 0xf8, 0xf8, 0x0d, 0x3c, 0x9b, 0x09, 0xfa, 0x8e, 0x8b, 0xfc, 0xe3,
	0x5c, 0xb8, 0x69, 0xf4, 0xb7, 0x3c, 0xdc, 0x9f, 0x45, 0x5c, 0xa0, 0xc2, 0xc7, 0x67, 0x81, 0x1f,
	0xc8, 0x22, 0x76, 0x01, 0x1f, 0x9d, 0x85, 0xf5, 0xd0, 0x85, 0xfd, 0xd9, 0x2c, 0xa6, 0x1a, 0x3a,
	0x2e, 0x55, 0xf1, 0x71, 0x4e, 0x3e, 0x9d, 0xca, 0xe3, 0x38, 0x61, 0xb1, 0xd5, 0xf2, 0x61, 0x6f,
	0x26, 0x93, 0x39, 0x6e, 0x4a, 0x8f, 0x73, 0xb3, 0x93, 0xe6, 0x72, 0xc7, 0x0b, 0x86, 0xad, 0xb4,
	0x44, 0xb3, 0xd7, 0x7c, 0xf9, 0xc1, 0xfb, 0xb8, 0x11, 0x9b, 0xce, 0x5e, 0xf2, 0x4b, 0xd8, 0x4c,
	0x38, 0x67, 0xaf, 0xf8, 0xca, 0x83, 0x94, 0xe5, 0xd8, 0x72, 0xe6, 0x82, 0xff, 0x10, 0x9c, 0x84,
	0xb1, 0x13, 0x8e, 0x84, 0xa4, 0xdc, 0x5d, 0xdd, 0xcf, 0x1c, 0x14, 0xf0, 0x6a, 0x2c, 0x6f, 0x18,
	0xb1, 0x9a, 0x05, 0xf1, 0xa0, 0xf5, 0xba, 0x21, 0xe9, 0x09, 0xd7, 0x79, 0x60, 0x16, 0xc4, 0xb3,
	0xfa, 0x44, 0xa1, 0xf1, 0x32, 0x9f, 0xde, 0xa2, 0x97, 0x90, 0x1f, 0x50, 0x49, 0x94, 0x95, 0xbb,
	0xa6, 0x89, 0x3e, 0x9d, 0x13, 0xfd, 0x2b, 0x0b, 0xc1, 0x09, 0xb8, 0xf2, 0xfb, 0x27, 0xb0, 0x3c,
	0xc3, 0x8c, 0xbe, 0x00, 0xb7, 0x4b, 0x82, 0x90, 0xfa, 0xb6, 0x28, 0x7d, 0x4a, 0x42, 0xd9, 0xef,
	0xf4, 0x69, 0xe7, 0x8d, 0x9e, 0xd1, 0x79, 0xbc, 0x69, 0xf4, 0x3a, 0xf5, 0xd3, 0x54, 0x8b, 0xaa,
	0xb0, 0x1e, 0x31, 0x8b, 0x9f, 0x24, 0x2d, 0xad, 0xe7, 0x70, 0x1e, 0xaf, 0x45, 0xcc, 0x60, 0x27,
	0x71, 0xa3, 0x2a, 0x4f, 0x53, 0x87, 0xaa, 0xbf, 0x60, 0x7a, 0x96, 0xb1, 0x91, 0xf9, 0x10, 0xe6,
	0xf1, 0x66, 0x7a, 0x72, 0x5a, 0xdd, 0x36, 0x5a, 0xb4, 0x07, 0x45, 0x13, 0x1c, 0xa7, 0x82, 0x4a,
	0x3d, 0x46, 0xf3, 0x18, 0xb4, 0x08, 0x2b, 0x09, 0xaa, 0xc3, 0xc6, 0xed, 0x7e, 0x31, 0xd0, 0x45,
	0x0d, 0x5d, 0x9f, 0xed, 0x08, 0x63, 0xf3, 0x33, 0xf8, 0x34, 0x3d, 0x3d, 0x16, 0x45, 0xb4, 0xa3,
	0x9a, 0xd3, 0x53, 0xc9, 0x8e, 0xb8, 0x99, 0x8a, 0x79, 0xbc, 0x9d, 0x1c, 0x64, 0x82, 0x38, 0x31,
	0x00, 0x74, 0x02, 0x7b, 0xf3, 0xec, 0x25, 0xe5, 0x83, 0x20, 0xd2, 0x8d, 0xae, 0xc7, 0x5f, 0x1e,
	0x3f, 0xbb, 0xcb, 0xd1, 0x4e, 0x41, 0xe8, 0x47, 0xb0, 0x96, 0xf0, 0xb0, 0x31, 0xe5, 0xdd, 0x90,
	0xbd, 0xd5, 0x53, 0x2d, 0x8f, 0x93, 0xf6, 0xba, 0xb0, 0x72, 0xf4, 0x5d, 0x58, 0x89, 0x98, 0xc7,
	0xd9, 0x48, 0x52, 0xaf, 0xcb, 0x46, 0x91, 0xaf, 0x87, 0x53, 0x1e, 0x97, 0x22, 0x86, 0x95, 0xf0,
	0x44, 0xc9, 0xd0, 0xf7, 0x60, 0xc5, 0xa7, 0x21, 0x99, 0x78, 0x41, 0xf4, 0x35, 0xed, 0x48, 0xea,
	0xeb, 0xf9, 0x92, 0xc7, 0xcb, 0x5a, 0x7a, 0x66, 0x85, 0x0a, 0xd6, 0x25, 0xa3, 0x50, 0xa6, 0xb0,
	0xa2, 0x81, 0x69, 0x69, 0x02, 0xfb, 0x0c, 0x4a, 0xea, 0x8b, 0xed, 0x85, 0xc1, 0x20, 0x50, 0xa0,
	0x92, 0x06, 0x15, 0x95, 0xec, 0xdc, 0x88, 0x50, 0x17, 0xca, 0xa3, 0x88, 0x8c, 0x64, 0x9f, 0xf1,
	0xe0, 0x77, 0xd4, 0xf7, 0x7c, 0x2a, 0x49, 0x10, 0xc6, 0x97, 0xf5, 0xc5, 0xe3, 0x9a, 0xbc, 0x7a,
	0x35, 0x45, 0x81, 0xd7, 0xa7, 0x09, 0x8f, 0x0d, 0x1f, 0x7a, 0x09, 0x6e, 0x1a, 0x8a, 0x27, 0x28,
	0x1f, 0x07, 0x1d, 0xea, 0x51, 0xce, 0x19, 0xd7, 0xb7, 0x38, 0x8f, 0x37, 0x92, 0xb0, 0x5a, 0x46,
	0xdb, 0x54, 0xca, 0x9d, 0x3f, 0x65, 0xa0, 0x34, 0x4d, 0x8f, 0x30, 0x2c, 0x71, 0x4a, 0x04, 0x8b,
	0x74, 0x93, 0xaf, 0xd4, 0xbf, 0xfc, 0x88, 0x18, 0xab, 0x58, 0x33, 0x60, 0xcb, 0x54, 0xf9, 0x29,
	0x2c, 0x19, 0x09, 0xda, 0x04, 0x84, 0x9b, 0x87, 0xad, 0x8b, 0xd7, 0xb7, 0x9e, 0x4e, 0x65, 0x70,
	0x9a, 0xbf, 0x6e, 0x37, 0xf1, 0xeb, 0xc3, 0x73, 0xaf, 0xd5, 0xc4, 0xd7, 0x67, 0x8d, 0xa6, 0x93,
	0xa9, 0xfc, 0x79, 0x01, 0x96, 0x67, 0x3e, 0xfd, 0x08, 0x43, 0x51, 0x3d, 0x1d, 0xe2, 0x17, 0xa8,
	0x09, 0xf1, 0xf9, 0xe3, 0xde, 0x0d, 0x6a, 0x17, 0xbf, 0x3d, 0x41, 0x86, 0x22, 0x7e, 0xd0, 0x9d,
	0x80, 0xa3, 0x38, 0x3b, 0xc1, 0xb0, 0x4f, 0xb9, 0x27, 0x46, 0x81, 0xa4, 0xf6, 0xcd, 0xf4, 0xf4,
	0xce, 0xa8, 0xbe, 0x3a, 0x8b, 0xe4, 0x8b, 0xfa, 0x35, 0x09, 0x47, 0x14, 0xab, 0x47, 0x4c, 0x43,
	0x1b, 0xb5, 0x94, 0x0d, 0x3a, 0x30, 0x3c, 0x22, 0x0a, 0xbc, 0x3e, 0x13, 0x32, 0x22, 0x03, 0xaa,
	0xaf, 0x6f, 0x41, 0x23, 0x5b, 0x51, 0x70, 0x6a, 0xa5, 0x95, 0x5f, 0x01, 0xa4, 0xb1, 0xa0, 0x2d,
	0x58, 0xbf, 0x6e, 0xe2, 0xd6, 0xd9, 0x9d, 0xa2, 0x14, 0x60, 0xb1, 0x7d, 0xde, 0x1a, 0x3f, 0x77,
	0x32, 0xa8, 0x08, 0x4f, 0xf4, 0xd2, 0x53, 0xef, 0xc9, 0x64, 0x53, 0x77, 0xb2, 0xe9, 0xe6, 0x85,
	0x93, 0xab, 0x7c, 0xbb, 0x08, 0x1b, 0x73, 0x9f, 0xc6, 0xe8, 0xe7, 0x6a, 0xce, 0x9a, 0xd1, 0x32,
	0xa0, 0xb2, 0xcf, 0x7c, 0x5b, 0xbb, 0xfd, 0x39, 0xe3, 0xd1, 0x5a, 0xbf, 0xd2, 0x38, 0x35, 0x61,
	0xa7, 0xb6, 0x68, 0x13, 0x96, 0x44, 0xa7, 0x4f, 0x07, 0xa6, 0x46, 0x05, 0x6c, 0x77, 0xe8, 0x29,
	0x14, 0x6c, 0x03, 0xc8, 0x89, 0x4d, 0x3b, 0x15, 0xa0, 0xcf, 0x21, 0x37, 0x64, 0x5c, 0xda, 0x87,
	0xde, 0xfb, 0xeb, 0xaa, 0x91, 0x08, 0x41, 0x6e, 0x48, 0x64, 0x5f, 0x0f, 0xaa, 0x02, 0xd6, 0x6b,
	0xf4, 0x0c, 0x60, 0x24, 0x28, 0xf7, 0x48, 0x8f, 0x46, 0x52, 0x0f, 0xa2, 0x02, 0x2e, 0x28, 0xc9,
	0xa1, 0x12, 0x20, 0x57, 0xfd, 0x7f, 0xe8, 0x52, 0x4e, 0xb9, 0x1e, 0x30, 0x05, 0x1c, 0x6f, 0xd1,
	0x77, 0x60, 0xb9, 0xcb, 0xf8, 0x5b, 0xc2, 0x7d, 0xea, 0x7b, 0x5d, 0xc6, 0xf5, 0x18, 0x29, 0xe0,
	0x52, 0x22, 0x3c, 0x61, 0x5c, 0xb1, 0xc7, 0x25, 0x0a, 0xcc, 0xf8, 0x28, 0xe0, 0x82, 0x95, 0x9c,
	0xf9, 0x8a, 0x83, 0xf1, 0xa0, 0x17, 0x44, 0x24, 0xf4, 0x74, 0x64, 0x60, 0x38, 0x62, 0xe1, 0xa5,
	0x8a, 0xb0, 0x0e, 0x1b, 0x31, 0x47, 0x9f, 0x12, 0x9f, 0x72, 0xa1, 0x3f, 0xfd, 0x42, 0x0f, 0x90,
	0x1c, 0x5e, 0xb7, 0xca, 0x53, 0xa3, 0x53, 0x9f, 0x74, 0x81, 0x7e, 0x0c, 0x28, 0xb6, 0xb9, 0x61,
	0xfe, 0xc4, 0x1a, 0x94, 0xb4, 0x81, 0x63, 0x35, 0x47, 0xcc, 0x9f, 0x18, 0xf4, 0x1b, 0x58, 0xbd,
	0xe5, 0xc1, 0x5d, 0xde, 0xcf, 0x1e, 0x14, 0xeb, 0x47, 0x1f, 0xf6, 0x67, 0x29, 0x3e, 0x65, 0x1b,
	0x8a, 0xfe, 0x7b, 0x86, 0x57, 0x66, 0xe3, 0xdb, 0x39, 0x84, 0xf5, 0x39, 0x30, 0xe4, 0x40, 0xf6,
	0x0d, 0x9d, 0xe8, 0x0e, 0x2a, 0x60, 0xb5, 0x44, 0x65, 0x58, 0x1c, 0xab, 0xc3, 0xb3, 0x4d, 0x61,
	0x36, 0x5f, 0x2e, 0x7c, 0x91, 0xa9, 0xfc, 0x25, 0x07, 0x9b, 0xf3, 0xff, 0x62, 0xa1, 0x43, 0x48,
	0xbe, 0xde, 0x5e, 0x87, 0xf9, 0xd4, 0xfe, 0x4d, 0x7d, 0x7f, 0x77, 0x94, 0x62, 0x93, 0x06, 0xf3,
	0x29, 0xfa, 0x09, 0x6c, 0x26, 0x14, 0xb3, 0x05, 0x5f, 0xd0, 0xf5, 0x2b, 0xc7, 0xda, 0x99, 0x8a,
	0x57, 0x61, 0x3d, 0xb1, 0x9a, 0x2a, 0x79, 0x56, 0x9b, 0xac, 0xc5, 0xaa, 0xb4, 0xe6, 0x0c, 0x9c,
	0xdb, 0x5e, 0xdc, 0x9c, 0x2e, 0xfa, 0xf1, 0x07, 0xfe, 0xad, 0x4c, 0x86, 0xe6, 0x4c, 0xd9, 0x57,
	0x6f, 0x45, 0x89, 0x38, 0x24, 0x51, 0x78, 0x92, 0xab, 0x57, 0x06, 0x17, 0xee, 0xa2, 0xf6, 0xd8,
	0xfc, 0x58, 0x8f, 0x6d, 0xcb, 0x63, 0x5c, 0x26, 0x09, 0xc5, 0xe2, 0x9d, 0x23, 0x28, 0xcf, 0x0b,
	0xee, 0x43, 0x0e, 0x7b, 0xa7, 0x01, 0x1b, 0x73, 0xdd, 0x7d, 0x08, 0xc9, 0x51, 0xe9, 0x1f, 0xef,
	0x76, 0x33, 0xff, 0x7c, 0xb7, 0x9b, 0xf9, 0xf7, 0xbb, 0xdd, 0xcc, 0xcd, 0x92, 0xee, 0x82, 0x17,
	0xff, 0x0b, 0x00, 0x00, 0xff, 0xff, 0x5a, 0x41, 0x0b, 0x8d, 0x6c, 0x12, 0x00, 0x00,
}
