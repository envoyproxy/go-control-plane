// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: envoy/api/v2/core/health_check.proto

package core

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf2 "github.com/gogo/protobuf/types"
import google_protobuf "github.com/gogo/protobuf/types"
import _ "github.com/lyft/protoc-gen-validate/validate"
import _ "github.com/gogo/protobuf/gogoproto"

import bytes "bytes"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// [#not-implemented-hide:] Part of HDS.
type HealthStatus int32

const (
	// UNKNOWN should be treated by Envoy as HEALTHY.
	HealthStatus_UNKNOWN HealthStatus = 0
	// Healthy.
	HealthStatus_HEALTHY HealthStatus = 1
	// Unhealthy.
	HealthStatus_UNHEALTHY HealthStatus = 2
	// Connection draining in progress. E.g.,
	// https://aws.amazon.com/blogs/aws/elb-connection-draining-remove-instances-from-service-with-care/
	// or
	// https://cloud.google.com/compute/docs/load-balancing/enabling-connection-draining.
	HealthStatus_DRAINING HealthStatus = 3
	// This value is used by HDS Remote server. From Envoy’s perspective
	// TIMEOUT = UNHEALTHY in case EDS returns HealthStatus.
	HealthStatus_TIMEOUT HealthStatus = 4
)

var HealthStatus_name = map[int32]string{
	0: "UNKNOWN",
	1: "HEALTHY",
	2: "UNHEALTHY",
	3: "DRAINING",
	4: "TIMEOUT",
}
var HealthStatus_value = map[string]int32{
	"UNKNOWN":   0,
	"HEALTHY":   1,
	"UNHEALTHY": 2,
	"DRAINING":  3,
	"TIMEOUT":   4,
}

func (x HealthStatus) String() string {
	return proto.EnumName(HealthStatus_name, int32(x))
}
func (HealthStatus) EnumDescriptor() ([]byte, []int) { return fileDescriptorHealthCheck, []int{0} }

type HealthCheck struct {
	// The time to wait for a health check response. If the timeout is reached the
	// health check attempt will be considered a failure.
	Timeout *google_protobuf2.Duration `protobuf:"bytes,1,opt,name=timeout" json:"timeout,omitempty"`
	// The interval between health checks.
	Interval *google_protobuf2.Duration `protobuf:"bytes,2,opt,name=interval" json:"interval,omitempty"`
	// An optional jitter amount in millseconds. If specified, during every
	// internal Envoy will add 0 to interval_jitter to the wait time.
	IntervalJitter *google_protobuf2.Duration `protobuf:"bytes,3,opt,name=interval_jitter,json=intervalJitter" json:"interval_jitter,omitempty"`
	// The number of unhealthy health checks required before a host is marked
	// unhealthy. Note that for *http* health checking if a host responds with 503
	// this threshold is ignored and the host is considered unhealthy immediately.
	UnhealthyThreshold *google_protobuf.UInt32Value `protobuf:"bytes,4,opt,name=unhealthy_threshold,json=unhealthyThreshold" json:"unhealthy_threshold,omitempty"`
	// The number of healthy health checks required before a host is marked
	// healthy. Note that during startup, only a single successful health check is
	// required to mark a host healthy.
	HealthyThreshold *google_protobuf.UInt32Value `protobuf:"bytes,5,opt,name=healthy_threshold,json=healthyThreshold" json:"healthy_threshold,omitempty"`
	// [#not-implemented-hide:] Non-serving port for health checking.
	AltPort *google_protobuf.UInt32Value `protobuf:"bytes,6,opt,name=alt_port,json=altPort" json:"alt_port,omitempty"`
	// Reuse health check connection between health checks. Default is true.
	ReuseConnection *google_protobuf.BoolValue `protobuf:"bytes,7,opt,name=reuse_connection,json=reuseConnection" json:"reuse_connection,omitempty"`
	// Types that are valid to be assigned to HealthChecker:
	//	*HealthCheck_HttpHealthCheck_
	//	*HealthCheck_TcpHealthCheck_
	//	*HealthCheck_RedisHealthCheck_
	//	*HealthCheck_GrpcHealthCheck_
	HealthChecker isHealthCheck_HealthChecker `protobuf_oneof:"health_checker"`
	// The "no traffic interval" is a special health check interval that is used when a cluster has
	// never had traffic routed to it. This lower interval allows cluster information to be kept up to
	// date, without sending a potentially large amount of active health checking traffic for no
	// reason. Once a cluster has been used for traffic routing, Envoy will shift back to using the
	// standard health check interval that is defined.
	//
	// The default value for "no traffic interval" is 60 seconds.
	NoTrafficInterval *google_protobuf2.Duration `protobuf:"bytes,12,opt,name=no_traffic_interval,json=noTrafficInterval" json:"no_traffic_interval,omitempty"`
}

func (m *HealthCheck) Reset()                    { *m = HealthCheck{} }
func (m *HealthCheck) String() string            { return proto.CompactTextString(m) }
func (*HealthCheck) ProtoMessage()               {}
func (*HealthCheck) Descriptor() ([]byte, []int) { return fileDescriptorHealthCheck, []int{0} }

type isHealthCheck_HealthChecker interface {
	isHealthCheck_HealthChecker()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type HealthCheck_HttpHealthCheck_ struct {
	HttpHealthCheck *HealthCheck_HttpHealthCheck `protobuf:"bytes,8,opt,name=http_health_check,json=httpHealthCheck,oneof"`
}
type HealthCheck_TcpHealthCheck_ struct {
	TcpHealthCheck *HealthCheck_TcpHealthCheck `protobuf:"bytes,9,opt,name=tcp_health_check,json=tcpHealthCheck,oneof"`
}
type HealthCheck_RedisHealthCheck_ struct {
	RedisHealthCheck *HealthCheck_RedisHealthCheck `protobuf:"bytes,10,opt,name=redis_health_check,json=redisHealthCheck,oneof"`
}
type HealthCheck_GrpcHealthCheck_ struct {
	GrpcHealthCheck *HealthCheck_GrpcHealthCheck `protobuf:"bytes,11,opt,name=grpc_health_check,json=grpcHealthCheck,oneof"`
}

func (*HealthCheck_HttpHealthCheck_) isHealthCheck_HealthChecker()  {}
func (*HealthCheck_TcpHealthCheck_) isHealthCheck_HealthChecker()   {}
func (*HealthCheck_RedisHealthCheck_) isHealthCheck_HealthChecker() {}
func (*HealthCheck_GrpcHealthCheck_) isHealthCheck_HealthChecker()  {}

func (m *HealthCheck) GetHealthChecker() isHealthCheck_HealthChecker {
	if m != nil {
		return m.HealthChecker
	}
	return nil
}

func (m *HealthCheck) GetTimeout() *google_protobuf2.Duration {
	if m != nil {
		return m.Timeout
	}
	return nil
}

func (m *HealthCheck) GetInterval() *google_protobuf2.Duration {
	if m != nil {
		return m.Interval
	}
	return nil
}

func (m *HealthCheck) GetIntervalJitter() *google_protobuf2.Duration {
	if m != nil {
		return m.IntervalJitter
	}
	return nil
}

func (m *HealthCheck) GetUnhealthyThreshold() *google_protobuf.UInt32Value {
	if m != nil {
		return m.UnhealthyThreshold
	}
	return nil
}

func (m *HealthCheck) GetHealthyThreshold() *google_protobuf.UInt32Value {
	if m != nil {
		return m.HealthyThreshold
	}
	return nil
}

func (m *HealthCheck) GetAltPort() *google_protobuf.UInt32Value {
	if m != nil {
		return m.AltPort
	}
	return nil
}

func (m *HealthCheck) GetReuseConnection() *google_protobuf.BoolValue {
	if m != nil {
		return m.ReuseConnection
	}
	return nil
}

func (m *HealthCheck) GetHttpHealthCheck() *HealthCheck_HttpHealthCheck {
	if x, ok := m.GetHealthChecker().(*HealthCheck_HttpHealthCheck_); ok {
		return x.HttpHealthCheck
	}
	return nil
}

func (m *HealthCheck) GetTcpHealthCheck() *HealthCheck_TcpHealthCheck {
	if x, ok := m.GetHealthChecker().(*HealthCheck_TcpHealthCheck_); ok {
		return x.TcpHealthCheck
	}
	return nil
}

func (m *HealthCheck) GetRedisHealthCheck() *HealthCheck_RedisHealthCheck {
	if x, ok := m.GetHealthChecker().(*HealthCheck_RedisHealthCheck_); ok {
		return x.RedisHealthCheck
	}
	return nil
}

func (m *HealthCheck) GetGrpcHealthCheck() *HealthCheck_GrpcHealthCheck {
	if x, ok := m.GetHealthChecker().(*HealthCheck_GrpcHealthCheck_); ok {
		return x.GrpcHealthCheck
	}
	return nil
}

func (m *HealthCheck) GetNoTrafficInterval() *google_protobuf2.Duration {
	if m != nil {
		return m.NoTrafficInterval
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*HealthCheck) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _HealthCheck_OneofMarshaler, _HealthCheck_OneofUnmarshaler, _HealthCheck_OneofSizer, []interface{}{
		(*HealthCheck_HttpHealthCheck_)(nil),
		(*HealthCheck_TcpHealthCheck_)(nil),
		(*HealthCheck_RedisHealthCheck_)(nil),
		(*HealthCheck_GrpcHealthCheck_)(nil),
	}
}

func _HealthCheck_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*HealthCheck)
	// health_checker
	switch x := m.HealthChecker.(type) {
	case *HealthCheck_HttpHealthCheck_:
		_ = b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.HttpHealthCheck); err != nil {
			return err
		}
	case *HealthCheck_TcpHealthCheck_:
		_ = b.EncodeVarint(9<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TcpHealthCheck); err != nil {
			return err
		}
	case *HealthCheck_RedisHealthCheck_:
		_ = b.EncodeVarint(10<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.RedisHealthCheck); err != nil {
			return err
		}
	case *HealthCheck_GrpcHealthCheck_:
		_ = b.EncodeVarint(11<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.GrpcHealthCheck); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("HealthCheck.HealthChecker has unexpected type %T", x)
	}
	return nil
}

func _HealthCheck_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*HealthCheck)
	switch tag {
	case 8: // health_checker.http_health_check
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(HealthCheck_HttpHealthCheck)
		err := b.DecodeMessage(msg)
		m.HealthChecker = &HealthCheck_HttpHealthCheck_{msg}
		return true, err
	case 9: // health_checker.tcp_health_check
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(HealthCheck_TcpHealthCheck)
		err := b.DecodeMessage(msg)
		m.HealthChecker = &HealthCheck_TcpHealthCheck_{msg}
		return true, err
	case 10: // health_checker.redis_health_check
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(HealthCheck_RedisHealthCheck)
		err := b.DecodeMessage(msg)
		m.HealthChecker = &HealthCheck_RedisHealthCheck_{msg}
		return true, err
	case 11: // health_checker.grpc_health_check
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(HealthCheck_GrpcHealthCheck)
		err := b.DecodeMessage(msg)
		m.HealthChecker = &HealthCheck_GrpcHealthCheck_{msg}
		return true, err
	default:
		return false, nil
	}
}

func _HealthCheck_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*HealthCheck)
	// health_checker
	switch x := m.HealthChecker.(type) {
	case *HealthCheck_HttpHealthCheck_:
		s := proto.Size(x.HttpHealthCheck)
		n += proto.SizeVarint(8<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *HealthCheck_TcpHealthCheck_:
		s := proto.Size(x.TcpHealthCheck)
		n += proto.SizeVarint(9<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *HealthCheck_RedisHealthCheck_:
		s := proto.Size(x.RedisHealthCheck)
		n += proto.SizeVarint(10<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *HealthCheck_GrpcHealthCheck_:
		s := proto.Size(x.GrpcHealthCheck)
		n += proto.SizeVarint(11<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Describes the encoding of the payload bytes in the payload.
type HealthCheck_Payload struct {
	// Types that are valid to be assigned to Payload:
	//	*HealthCheck_Payload_Text
	//	*HealthCheck_Payload_Binary
	Payload isHealthCheck_Payload_Payload `protobuf_oneof:"payload"`
}

func (m *HealthCheck_Payload) Reset()         { *m = HealthCheck_Payload{} }
func (m *HealthCheck_Payload) String() string { return proto.CompactTextString(m) }
func (*HealthCheck_Payload) ProtoMessage()    {}
func (*HealthCheck_Payload) Descriptor() ([]byte, []int) {
	return fileDescriptorHealthCheck, []int{0, 0}
}

type isHealthCheck_Payload_Payload interface {
	isHealthCheck_Payload_Payload()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type HealthCheck_Payload_Text struct {
	Text string `protobuf:"bytes,1,opt,name=text,proto3,oneof"`
}
type HealthCheck_Payload_Binary struct {
	Binary []byte `protobuf:"bytes,2,opt,name=binary,proto3,oneof"`
}

func (*HealthCheck_Payload_Text) isHealthCheck_Payload_Payload()   {}
func (*HealthCheck_Payload_Binary) isHealthCheck_Payload_Payload() {}

func (m *HealthCheck_Payload) GetPayload() isHealthCheck_Payload_Payload {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *HealthCheck_Payload) GetText() string {
	if x, ok := m.GetPayload().(*HealthCheck_Payload_Text); ok {
		return x.Text
	}
	return ""
}

func (m *HealthCheck_Payload) GetBinary() []byte {
	if x, ok := m.GetPayload().(*HealthCheck_Payload_Binary); ok {
		return x.Binary
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*HealthCheck_Payload) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _HealthCheck_Payload_OneofMarshaler, _HealthCheck_Payload_OneofUnmarshaler, _HealthCheck_Payload_OneofSizer, []interface{}{
		(*HealthCheck_Payload_Text)(nil),
		(*HealthCheck_Payload_Binary)(nil),
	}
}

func _HealthCheck_Payload_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*HealthCheck_Payload)
	// payload
	switch x := m.Payload.(type) {
	case *HealthCheck_Payload_Text:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.Text)
	case *HealthCheck_Payload_Binary:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		_ = b.EncodeRawBytes(x.Binary)
	case nil:
	default:
		return fmt.Errorf("HealthCheck_Payload.Payload has unexpected type %T", x)
	}
	return nil
}

func _HealthCheck_Payload_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*HealthCheck_Payload)
	switch tag {
	case 1: // payload.text
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Payload = &HealthCheck_Payload_Text{x}
		return true, err
	case 2: // payload.binary
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.Payload = &HealthCheck_Payload_Binary{x}
		return true, err
	default:
		return false, nil
	}
}

func _HealthCheck_Payload_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*HealthCheck_Payload)
	// payload
	switch x := m.Payload.(type) {
	case *HealthCheck_Payload_Text:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Text)))
		n += len(x.Text)
	case *HealthCheck_Payload_Binary:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Binary)))
		n += len(x.Binary)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type HealthCheck_HttpHealthCheck struct {
	// The value of the host header in the HTTP health check request. If
	// left empty (default value), the IP on behalf of which this health check is performed will be
	// used.
	Host string `protobuf:"bytes,1,opt,name=host,proto3" json:"host,omitempty"`
	// Specifies the HTTP path that will be requested during health checking. For example
	// */healthcheck*.
	Path string `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty"`
	// [#not-implemented-hide:] HTTP specific payload.
	Send *HealthCheck_Payload `protobuf:"bytes,3,opt,name=send" json:"send,omitempty"`
	// [#not-implemented-hide:] HTTP specific response.
	Receive *HealthCheck_Payload `protobuf:"bytes,4,opt,name=receive" json:"receive,omitempty"`
	// An optional service name parameter which is used to validate the identity of
	// the health checked cluster. See the :ref:`architecture overview
	// <arch_overview_health_checking_identity>` for more information.
	ServiceName string `protobuf:"bytes,5,opt,name=service_name,json=serviceName,proto3" json:"service_name,omitempty"`
	// Specifies a list of HTTP headers that should be added to each request that is sent to the
	// health checked cluster.
	RequestHeadersToAdd []*HeaderValueOption `protobuf:"bytes,6,rep,name=request_headers_to_add,json=requestHeadersToAdd" json:"request_headers_to_add,omitempty"`
}

func (m *HealthCheck_HttpHealthCheck) Reset()         { *m = HealthCheck_HttpHealthCheck{} }
func (m *HealthCheck_HttpHealthCheck) String() string { return proto.CompactTextString(m) }
func (*HealthCheck_HttpHealthCheck) ProtoMessage()    {}
func (*HealthCheck_HttpHealthCheck) Descriptor() ([]byte, []int) {
	return fileDescriptorHealthCheck, []int{0, 1}
}

func (m *HealthCheck_HttpHealthCheck) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *HealthCheck_HttpHealthCheck) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *HealthCheck_HttpHealthCheck) GetSend() *HealthCheck_Payload {
	if m != nil {
		return m.Send
	}
	return nil
}

func (m *HealthCheck_HttpHealthCheck) GetReceive() *HealthCheck_Payload {
	if m != nil {
		return m.Receive
	}
	return nil
}

func (m *HealthCheck_HttpHealthCheck) GetServiceName() string {
	if m != nil {
		return m.ServiceName
	}
	return ""
}

func (m *HealthCheck_HttpHealthCheck) GetRequestHeadersToAdd() []*HeaderValueOption {
	if m != nil {
		return m.RequestHeadersToAdd
	}
	return nil
}

type HealthCheck_TcpHealthCheck struct {
	// Empty payloads imply a connect-only health check.
	Send *HealthCheck_Payload `protobuf:"bytes,1,opt,name=send" json:"send,omitempty"`
	// When checking the response, “fuzzy” matching is performed such that each
	// binary block must be found, and in the order specified, but not
	// necessarily contiguous.
	Receive []*HealthCheck_Payload `protobuf:"bytes,2,rep,name=receive" json:"receive,omitempty"`
}

func (m *HealthCheck_TcpHealthCheck) Reset()         { *m = HealthCheck_TcpHealthCheck{} }
func (m *HealthCheck_TcpHealthCheck) String() string { return proto.CompactTextString(m) }
func (*HealthCheck_TcpHealthCheck) ProtoMessage()    {}
func (*HealthCheck_TcpHealthCheck) Descriptor() ([]byte, []int) {
	return fileDescriptorHealthCheck, []int{0, 2}
}

func (m *HealthCheck_TcpHealthCheck) GetSend() *HealthCheck_Payload {
	if m != nil {
		return m.Send
	}
	return nil
}

func (m *HealthCheck_TcpHealthCheck) GetReceive() []*HealthCheck_Payload {
	if m != nil {
		return m.Receive
	}
	return nil
}

type HealthCheck_RedisHealthCheck struct {
	// If set, optionally perform ``EXISTS <key>`` instead of ``PING``. A return value
	// from Redis of 0 (does not exist) is considered a passing healthcheck. A return value other
	// than 0 is considered a failure. This allows the user to mark a Redis instance for maintenance
	// by setting the specified key to any value and waiting for traffic to drain.
	Key string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
}

func (m *HealthCheck_RedisHealthCheck) Reset()         { *m = HealthCheck_RedisHealthCheck{} }
func (m *HealthCheck_RedisHealthCheck) String() string { return proto.CompactTextString(m) }
func (*HealthCheck_RedisHealthCheck) ProtoMessage()    {}
func (*HealthCheck_RedisHealthCheck) Descriptor() ([]byte, []int) {
	return fileDescriptorHealthCheck, []int{0, 3}
}

func (m *HealthCheck_RedisHealthCheck) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

// `grpc.health.v1.Health
// <https://github.com/grpc/grpc/blob/master/src/proto/grpc/health/v1/health.proto>`_-based
// healthcheck. See `gRPC doc <https://github.com/grpc/grpc/blob/master/doc/health-checking.md>`_
// for details.
type HealthCheck_GrpcHealthCheck struct {
	// An optional service name parameter which will be sent to gRPC service in
	// `grpc.health.v1.HealthCheckRequest
	// <https://github.com/grpc/grpc/blob/master/src/proto/grpc/health/v1/health.proto#L20>`_.
	// message. See `gRPC health-checking overview
	// <https://github.com/grpc/grpc/blob/master/doc/health-checking.md>`_ for more information.
	ServiceName string `protobuf:"bytes,1,opt,name=service_name,json=serviceName,proto3" json:"service_name,omitempty"`
}

func (m *HealthCheck_GrpcHealthCheck) Reset()         { *m = HealthCheck_GrpcHealthCheck{} }
func (m *HealthCheck_GrpcHealthCheck) String() string { return proto.CompactTextString(m) }
func (*HealthCheck_GrpcHealthCheck) ProtoMessage()    {}
func (*HealthCheck_GrpcHealthCheck) Descriptor() ([]byte, []int) {
	return fileDescriptorHealthCheck, []int{0, 4}
}

func (m *HealthCheck_GrpcHealthCheck) GetServiceName() string {
	if m != nil {
		return m.ServiceName
	}
	return ""
}

func init() {
	proto.RegisterType((*HealthCheck)(nil), "envoy.api.v2.core.HealthCheck")
	proto.RegisterType((*HealthCheck_Payload)(nil), "envoy.api.v2.core.HealthCheck.Payload")
	proto.RegisterType((*HealthCheck_HttpHealthCheck)(nil), "envoy.api.v2.core.HealthCheck.HttpHealthCheck")
	proto.RegisterType((*HealthCheck_TcpHealthCheck)(nil), "envoy.api.v2.core.HealthCheck.TcpHealthCheck")
	proto.RegisterType((*HealthCheck_RedisHealthCheck)(nil), "envoy.api.v2.core.HealthCheck.RedisHealthCheck")
	proto.RegisterType((*HealthCheck_GrpcHealthCheck)(nil), "envoy.api.v2.core.HealthCheck.GrpcHealthCheck")
	proto.RegisterEnum("envoy.api.v2.core.HealthStatus", HealthStatus_name, HealthStatus_value)
}
func (this *HealthCheck) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*HealthCheck)
	if !ok {
		that2, ok := that.(HealthCheck)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Timeout.Equal(that1.Timeout) {
		return false
	}
	if !this.Interval.Equal(that1.Interval) {
		return false
	}
	if !this.IntervalJitter.Equal(that1.IntervalJitter) {
		return false
	}
	if !this.UnhealthyThreshold.Equal(that1.UnhealthyThreshold) {
		return false
	}
	if !this.HealthyThreshold.Equal(that1.HealthyThreshold) {
		return false
	}
	if !this.AltPort.Equal(that1.AltPort) {
		return false
	}
	if !this.ReuseConnection.Equal(that1.ReuseConnection) {
		return false
	}
	if that1.HealthChecker == nil {
		if this.HealthChecker != nil {
			return false
		}
	} else if this.HealthChecker == nil {
		return false
	} else if !this.HealthChecker.Equal(that1.HealthChecker) {
		return false
	}
	if !this.NoTrafficInterval.Equal(that1.NoTrafficInterval) {
		return false
	}
	return true
}
func (this *HealthCheck_HttpHealthCheck_) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*HealthCheck_HttpHealthCheck_)
	if !ok {
		that2, ok := that.(HealthCheck_HttpHealthCheck_)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.HttpHealthCheck.Equal(that1.HttpHealthCheck) {
		return false
	}
	return true
}
func (this *HealthCheck_TcpHealthCheck_) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*HealthCheck_TcpHealthCheck_)
	if !ok {
		that2, ok := that.(HealthCheck_TcpHealthCheck_)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.TcpHealthCheck.Equal(that1.TcpHealthCheck) {
		return false
	}
	return true
}
func (this *HealthCheck_RedisHealthCheck_) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*HealthCheck_RedisHealthCheck_)
	if !ok {
		that2, ok := that.(HealthCheck_RedisHealthCheck_)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.RedisHealthCheck.Equal(that1.RedisHealthCheck) {
		return false
	}
	return true
}
func (this *HealthCheck_GrpcHealthCheck_) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*HealthCheck_GrpcHealthCheck_)
	if !ok {
		that2, ok := that.(HealthCheck_GrpcHealthCheck_)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.GrpcHealthCheck.Equal(that1.GrpcHealthCheck) {
		return false
	}
	return true
}
func (this *HealthCheck_Payload) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*HealthCheck_Payload)
	if !ok {
		that2, ok := that.(HealthCheck_Payload)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if that1.Payload == nil {
		if this.Payload != nil {
			return false
		}
	} else if this.Payload == nil {
		return false
	} else if !this.Payload.Equal(that1.Payload) {
		return false
	}
	return true
}
func (this *HealthCheck_Payload_Text) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*HealthCheck_Payload_Text)
	if !ok {
		that2, ok := that.(HealthCheck_Payload_Text)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Text != that1.Text {
		return false
	}
	return true
}
func (this *HealthCheck_Payload_Binary) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*HealthCheck_Payload_Binary)
	if !ok {
		that2, ok := that.(HealthCheck_Payload_Binary)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Binary, that1.Binary) {
		return false
	}
	return true
}
func (this *HealthCheck_HttpHealthCheck) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*HealthCheck_HttpHealthCheck)
	if !ok {
		that2, ok := that.(HealthCheck_HttpHealthCheck)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Host != that1.Host {
		return false
	}
	if this.Path != that1.Path {
		return false
	}
	if !this.Send.Equal(that1.Send) {
		return false
	}
	if !this.Receive.Equal(that1.Receive) {
		return false
	}
	if this.ServiceName != that1.ServiceName {
		return false
	}
	if len(this.RequestHeadersToAdd) != len(that1.RequestHeadersToAdd) {
		return false
	}
	for i := range this.RequestHeadersToAdd {
		if !this.RequestHeadersToAdd[i].Equal(that1.RequestHeadersToAdd[i]) {
			return false
		}
	}
	return true
}
func (this *HealthCheck_TcpHealthCheck) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*HealthCheck_TcpHealthCheck)
	if !ok {
		that2, ok := that.(HealthCheck_TcpHealthCheck)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Send.Equal(that1.Send) {
		return false
	}
	if len(this.Receive) != len(that1.Receive) {
		return false
	}
	for i := range this.Receive {
		if !this.Receive[i].Equal(that1.Receive[i]) {
			return false
		}
	}
	return true
}
func (this *HealthCheck_RedisHealthCheck) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*HealthCheck_RedisHealthCheck)
	if !ok {
		that2, ok := that.(HealthCheck_RedisHealthCheck)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Key != that1.Key {
		return false
	}
	return true
}
func (this *HealthCheck_GrpcHealthCheck) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*HealthCheck_GrpcHealthCheck)
	if !ok {
		that2, ok := that.(HealthCheck_GrpcHealthCheck)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.ServiceName != that1.ServiceName {
		return false
	}
	return true
}
func (m *HealthCheck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HealthCheck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Timeout != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintHealthCheck(dAtA, i, uint64(m.Timeout.Size()))
		n1, err := m.Timeout.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Interval != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintHealthCheck(dAtA, i, uint64(m.Interval.Size()))
		n2, err := m.Interval.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.IntervalJitter != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintHealthCheck(dAtA, i, uint64(m.IntervalJitter.Size()))
		n3, err := m.IntervalJitter.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.UnhealthyThreshold != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintHealthCheck(dAtA, i, uint64(m.UnhealthyThreshold.Size()))
		n4, err := m.UnhealthyThreshold.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.HealthyThreshold != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintHealthCheck(dAtA, i, uint64(m.HealthyThreshold.Size()))
		n5, err := m.HealthyThreshold.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.AltPort != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintHealthCheck(dAtA, i, uint64(m.AltPort.Size()))
		n6, err := m.AltPort.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.ReuseConnection != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintHealthCheck(dAtA, i, uint64(m.ReuseConnection.Size()))
		n7, err := m.ReuseConnection.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.HealthChecker != nil {
		nn8, err := m.HealthChecker.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn8
	}
	if m.NoTrafficInterval != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintHealthCheck(dAtA, i, uint64(m.NoTrafficInterval.Size()))
		n9, err := m.NoTrafficInterval.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}

func (m *HealthCheck_HttpHealthCheck_) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.HttpHealthCheck != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintHealthCheck(dAtA, i, uint64(m.HttpHealthCheck.Size()))
		n10, err := m.HttpHealthCheck.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}
func (m *HealthCheck_TcpHealthCheck_) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.TcpHealthCheck != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintHealthCheck(dAtA, i, uint64(m.TcpHealthCheck.Size()))
		n11, err := m.TcpHealthCheck.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}
func (m *HealthCheck_RedisHealthCheck_) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.RedisHealthCheck != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintHealthCheck(dAtA, i, uint64(m.RedisHealthCheck.Size()))
		n12, err := m.RedisHealthCheck.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}
func (m *HealthCheck_GrpcHealthCheck_) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.GrpcHealthCheck != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintHealthCheck(dAtA, i, uint64(m.GrpcHealthCheck.Size()))
		n13, err := m.GrpcHealthCheck.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}
func (m *HealthCheck_Payload) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HealthCheck_Payload) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Payload != nil {
		nn14, err := m.Payload.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn14
	}
	return i, nil
}

func (m *HealthCheck_Payload_Text) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0xa
	i++
	i = encodeVarintHealthCheck(dAtA, i, uint64(len(m.Text)))
	i += copy(dAtA[i:], m.Text)
	return i, nil
}
func (m *HealthCheck_Payload_Binary) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Binary != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintHealthCheck(dAtA, i, uint64(len(m.Binary)))
		i += copy(dAtA[i:], m.Binary)
	}
	return i, nil
}
func (m *HealthCheck_HttpHealthCheck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HealthCheck_HttpHealthCheck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Host) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintHealthCheck(dAtA, i, uint64(len(m.Host)))
		i += copy(dAtA[i:], m.Host)
	}
	if len(m.Path) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintHealthCheck(dAtA, i, uint64(len(m.Path)))
		i += copy(dAtA[i:], m.Path)
	}
	if m.Send != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintHealthCheck(dAtA, i, uint64(m.Send.Size()))
		n15, err := m.Send.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.Receive != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintHealthCheck(dAtA, i, uint64(m.Receive.Size()))
		n16, err := m.Receive.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if len(m.ServiceName) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintHealthCheck(dAtA, i, uint64(len(m.ServiceName)))
		i += copy(dAtA[i:], m.ServiceName)
	}
	if len(m.RequestHeadersToAdd) > 0 {
		for _, msg := range m.RequestHeadersToAdd {
			dAtA[i] = 0x32
			i++
			i = encodeVarintHealthCheck(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *HealthCheck_TcpHealthCheck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HealthCheck_TcpHealthCheck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Send != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintHealthCheck(dAtA, i, uint64(m.Send.Size()))
		n17, err := m.Send.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if len(m.Receive) > 0 {
		for _, msg := range m.Receive {
			dAtA[i] = 0x12
			i++
			i = encodeVarintHealthCheck(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *HealthCheck_RedisHealthCheck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HealthCheck_RedisHealthCheck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintHealthCheck(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	return i, nil
}

func (m *HealthCheck_GrpcHealthCheck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HealthCheck_GrpcHealthCheck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ServiceName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintHealthCheck(dAtA, i, uint64(len(m.ServiceName)))
		i += copy(dAtA[i:], m.ServiceName)
	}
	return i, nil
}

func encodeVarintHealthCheck(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *HealthCheck) Size() (n int) {
	var l int
	_ = l
	if m.Timeout != nil {
		l = m.Timeout.Size()
		n += 1 + l + sovHealthCheck(uint64(l))
	}
	if m.Interval != nil {
		l = m.Interval.Size()
		n += 1 + l + sovHealthCheck(uint64(l))
	}
	if m.IntervalJitter != nil {
		l = m.IntervalJitter.Size()
		n += 1 + l + sovHealthCheck(uint64(l))
	}
	if m.UnhealthyThreshold != nil {
		l = m.UnhealthyThreshold.Size()
		n += 1 + l + sovHealthCheck(uint64(l))
	}
	if m.HealthyThreshold != nil {
		l = m.HealthyThreshold.Size()
		n += 1 + l + sovHealthCheck(uint64(l))
	}
	if m.AltPort != nil {
		l = m.AltPort.Size()
		n += 1 + l + sovHealthCheck(uint64(l))
	}
	if m.ReuseConnection != nil {
		l = m.ReuseConnection.Size()
		n += 1 + l + sovHealthCheck(uint64(l))
	}
	if m.HealthChecker != nil {
		n += m.HealthChecker.Size()
	}
	if m.NoTrafficInterval != nil {
		l = m.NoTrafficInterval.Size()
		n += 1 + l + sovHealthCheck(uint64(l))
	}
	return n
}

func (m *HealthCheck_HttpHealthCheck_) Size() (n int) {
	var l int
	_ = l
	if m.HttpHealthCheck != nil {
		l = m.HttpHealthCheck.Size()
		n += 1 + l + sovHealthCheck(uint64(l))
	}
	return n
}
func (m *HealthCheck_TcpHealthCheck_) Size() (n int) {
	var l int
	_ = l
	if m.TcpHealthCheck != nil {
		l = m.TcpHealthCheck.Size()
		n += 1 + l + sovHealthCheck(uint64(l))
	}
	return n
}
func (m *HealthCheck_RedisHealthCheck_) Size() (n int) {
	var l int
	_ = l
	if m.RedisHealthCheck != nil {
		l = m.RedisHealthCheck.Size()
		n += 1 + l + sovHealthCheck(uint64(l))
	}
	return n
}
func (m *HealthCheck_GrpcHealthCheck_) Size() (n int) {
	var l int
	_ = l
	if m.GrpcHealthCheck != nil {
		l = m.GrpcHealthCheck.Size()
		n += 1 + l + sovHealthCheck(uint64(l))
	}
	return n
}
func (m *HealthCheck_Payload) Size() (n int) {
	var l int
	_ = l
	if m.Payload != nil {
		n += m.Payload.Size()
	}
	return n
}

func (m *HealthCheck_Payload_Text) Size() (n int) {
	var l int
	_ = l
	l = len(m.Text)
	n += 1 + l + sovHealthCheck(uint64(l))
	return n
}
func (m *HealthCheck_Payload_Binary) Size() (n int) {
	var l int
	_ = l
	if m.Binary != nil {
		l = len(m.Binary)
		n += 1 + l + sovHealthCheck(uint64(l))
	}
	return n
}
func (m *HealthCheck_HttpHealthCheck) Size() (n int) {
	var l int
	_ = l
	l = len(m.Host)
	if l > 0 {
		n += 1 + l + sovHealthCheck(uint64(l))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovHealthCheck(uint64(l))
	}
	if m.Send != nil {
		l = m.Send.Size()
		n += 1 + l + sovHealthCheck(uint64(l))
	}
	if m.Receive != nil {
		l = m.Receive.Size()
		n += 1 + l + sovHealthCheck(uint64(l))
	}
	l = len(m.ServiceName)
	if l > 0 {
		n += 1 + l + sovHealthCheck(uint64(l))
	}
	if len(m.RequestHeadersToAdd) > 0 {
		for _, e := range m.RequestHeadersToAdd {
			l = e.Size()
			n += 1 + l + sovHealthCheck(uint64(l))
		}
	}
	return n
}

func (m *HealthCheck_TcpHealthCheck) Size() (n int) {
	var l int
	_ = l
	if m.Send != nil {
		l = m.Send.Size()
		n += 1 + l + sovHealthCheck(uint64(l))
	}
	if len(m.Receive) > 0 {
		for _, e := range m.Receive {
			l = e.Size()
			n += 1 + l + sovHealthCheck(uint64(l))
		}
	}
	return n
}

func (m *HealthCheck_RedisHealthCheck) Size() (n int) {
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovHealthCheck(uint64(l))
	}
	return n
}

func (m *HealthCheck_GrpcHealthCheck) Size() (n int) {
	var l int
	_ = l
	l = len(m.ServiceName)
	if l > 0 {
		n += 1 + l + sovHealthCheck(uint64(l))
	}
	return n
}

func sovHealthCheck(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozHealthCheck(x uint64) (n int) {
	return sovHealthCheck(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *HealthCheck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHealthCheck
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HealthCheck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HealthCheck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHealthCheck
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timeout == nil {
				m.Timeout = &google_protobuf2.Duration{}
			}
			if err := m.Timeout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interval", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHealthCheck
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Interval == nil {
				m.Interval = &google_protobuf2.Duration{}
			}
			if err := m.Interval.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntervalJitter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHealthCheck
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IntervalJitter == nil {
				m.IntervalJitter = &google_protobuf2.Duration{}
			}
			if err := m.IntervalJitter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnhealthyThreshold", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHealthCheck
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UnhealthyThreshold == nil {
				m.UnhealthyThreshold = &google_protobuf.UInt32Value{}
			}
			if err := m.UnhealthyThreshold.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HealthyThreshold", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHealthCheck
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HealthyThreshold == nil {
				m.HealthyThreshold = &google_protobuf.UInt32Value{}
			}
			if err := m.HealthyThreshold.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AltPort", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHealthCheck
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AltPort == nil {
				m.AltPort = &google_protobuf.UInt32Value{}
			}
			if err := m.AltPort.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReuseConnection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHealthCheck
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReuseConnection == nil {
				m.ReuseConnection = &google_protobuf.BoolValue{}
			}
			if err := m.ReuseConnection.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpHealthCheck", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHealthCheck
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &HealthCheck_HttpHealthCheck{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.HealthChecker = &HealthCheck_HttpHealthCheck_{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpHealthCheck", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHealthCheck
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &HealthCheck_TcpHealthCheck{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.HealthChecker = &HealthCheck_TcpHealthCheck_{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedisHealthCheck", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHealthCheck
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &HealthCheck_RedisHealthCheck{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.HealthChecker = &HealthCheck_RedisHealthCheck_{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GrpcHealthCheck", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHealthCheck
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &HealthCheck_GrpcHealthCheck{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.HealthChecker = &HealthCheck_GrpcHealthCheck_{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoTrafficInterval", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHealthCheck
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NoTrafficInterval == nil {
				m.NoTrafficInterval = &google_protobuf2.Duration{}
			}
			if err := m.NoTrafficInterval.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHealthCheck(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHealthCheck
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HealthCheck_Payload) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHealthCheck
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Payload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Payload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHealthCheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = &HealthCheck_Payload_Text{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Binary", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthHealthCheck
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.Payload = &HealthCheck_Payload_Binary{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHealthCheck(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHealthCheck
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HealthCheck_HttpHealthCheck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHealthCheck
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HttpHealthCheck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HttpHealthCheck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHealthCheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Host = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHealthCheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Send", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHealthCheck
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Send == nil {
				m.Send = &HealthCheck_Payload{}
			}
			if err := m.Send.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Receive", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHealthCheck
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Receive == nil {
				m.Receive = &HealthCheck_Payload{}
			}
			if err := m.Receive.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHealthCheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeadersToAdd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHealthCheck
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestHeadersToAdd = append(m.RequestHeadersToAdd, &HeaderValueOption{})
			if err := m.RequestHeadersToAdd[len(m.RequestHeadersToAdd)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHealthCheck(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHealthCheck
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HealthCheck_TcpHealthCheck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHealthCheck
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpHealthCheck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpHealthCheck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Send", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHealthCheck
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Send == nil {
				m.Send = &HealthCheck_Payload{}
			}
			if err := m.Send.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Receive", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHealthCheck
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Receive = append(m.Receive, &HealthCheck_Payload{})
			if err := m.Receive[len(m.Receive)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHealthCheck(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHealthCheck
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HealthCheck_RedisHealthCheck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHealthCheck
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RedisHealthCheck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RedisHealthCheck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHealthCheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHealthCheck(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHealthCheck
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HealthCheck_GrpcHealthCheck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHealthCheck
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GrpcHealthCheck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GrpcHealthCheck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthCheck
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHealthCheck
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHealthCheck(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHealthCheck
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipHealthCheck(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowHealthCheck
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowHealthCheck
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowHealthCheck
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthHealthCheck
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowHealthCheck
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipHealthCheck(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthHealthCheck = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowHealthCheck   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("envoy/api/v2/core/health_check.proto", fileDescriptorHealthCheck) }

var fileDescriptorHealthCheck = []byte{
	// 806 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x93, 0x51, 0x6f, 0xe3, 0x44,
	0x10, 0xc7, 0xeb, 0x24, 0x6d, 0x92, 0x49, 0x68, 0xdc, 0x2d, 0xe2, 0x8c, 0x75, 0x84, 0x82, 0x2a,
	0x74, 0x42, 0xc2, 0x96, 0x72, 0x48, 0x48, 0xbc, 0x40, 0x73, 0x57, 0x5d, 0x02, 0x5c, 0x7a, 0x32,
	0xc9, 0xa1, 0x4a, 0x48, 0xd6, 0xc6, 0x9e, 0xc6, 0xe6, 0x5c, 0xaf, 0x59, 0xaf, 0x03, 0xf9, 0x12,
	0x7c, 0x0e, 0xc4, 0x27, 0x40, 0x3c, 0xf5, 0x91, 0x47, 0x24, 0xbe, 0x00, 0xca, 0xdb, 0x7d, 0x0b,
	0xe4, 0xb5, 0x1d, 0x25, 0x31, 0x28, 0xa9, 0xee, 0x6d, 0x76, 0xd6, 0xff, 0xdf, 0xac, 0x67, 0xe6,
	0x0f, 0xe7, 0x18, 0xce, 0xd9, 0xc2, 0xa4, 0x91, 0x6f, 0xce, 0x7b, 0xa6, 0xc3, 0x38, 0x9a, 0x1e,
	0xd2, 0x40, 0x78, 0xb6, 0xe3, 0xa1, 0xf3, 0xca, 0x88, 0x38, 0x13, 0x8c, 0x9c, 0xc8, 0xaf, 0x0c,
	0x1a, 0xf9, 0xc6, 0xbc, 0x67, 0xa4, 0x5f, 0xe9, 0x0f, 0xcb, 0xc2, 0x29, 0x8d, 0x31, 0x13, 0xe8,
	0xdd, 0x19, 0x63, 0xb3, 0x00, 0x4d, 0x79, 0x9a, 0x26, 0x37, 0xa6, 0x9b, 0x70, 0x2a, 0x7c, 0x16,
	0xfe, 0xdf, 0xfd, 0x4f, 0x9c, 0x46, 0x11, 0xf2, 0x38, 0xbf, 0x7f, 0x30, 0xa7, 0x81, 0xef, 0x52,
	0x81, 0x66, 0x11, 0xe4, 0x17, 0x6f, 0xcf, 0xd8, 0x8c, 0xc9, 0xd0, 0x4c, 0xa3, 0x2c, 0xfb, 0xe1,
	0xdf, 0x6d, 0x68, 0x0d, 0xe4, 0xb3, 0x9f, 0xa4, 0xaf, 0x26, 0x5f, 0x40, 0x5d, 0xf8, 0xb7, 0xc8,
	0x12, 0xa1, 0x29, 0x67, 0xca, 0xa3, 0x56, 0xef, 0x5d, 0x23, 0x2b, 0x68, 0x14, 0x05, 0x8d, 0xa7,
	0xf9, 0x83, 0xfa, 0xf0, 0xc7, 0xeb, 0xbb, 0xea, 0xe1, 0x6f, 0x4a, 0xa5, 0xa1, 0x58, 0x85, 0x8a,
	0x5c, 0x40, 0xc3, 0x0f, 0x05, 0xf2, 0x39, 0x0d, 0xb4, 0xca, 0x7d, 0x08, 0x2b, 0x19, 0xe9, 0x43,
	0xa7, 0x88, 0xed, 0x1f, 0x7c, 0x21, 0x90, 0x6b, 0xd5, 0x1d, 0x24, 0xeb, 0xb8, 0x50, 0x7c, 0x25,
	0x05, 0xe4, 0x39, 0x9c, 0x26, 0x61, 0x36, 0x8f, 0x85, 0x2d, 0x3c, 0x8e, 0xb1, 0xc7, 0x02, 0x57,
	0xab, 0x49, 0xce, 0xc3, 0x12, 0x67, 0x32, 0x0c, 0xc5, 0xe3, 0xde, 0x4b, 0x1a, 0x24, 0x68, 0x91,
	0x95, 0x70, 0x5c, 0xe8, 0xc8, 0x10, 0x4e, 0xca, 0xb0, 0xc3, 0x3d, 0x60, 0x6a, 0x09, 0xf5, 0x19,
	0x34, 0x68, 0x20, 0xec, 0x88, 0x71, 0xa1, 0x1d, 0xed, 0x41, 0xa8, 0xd3, 0x40, 0xbc, 0x60, 0x5c,
	0x90, 0x4b, 0x50, 0x39, 0x26, 0x31, 0xda, 0x0e, 0x0b, 0x43, 0x74, 0xd2, 0xdf, 0xd6, 0xea, 0x12,
	0xa0, 0x97, 0x00, 0x7d, 0xc6, 0x82, 0x4c, 0xde, 0x91, 0x9a, 0x27, 0x2b, 0x09, 0xf9, 0x1e, 0x4e,
	0x3c, 0x21, 0x22, 0x7b, 0x7d, 0x59, 0xb5, 0x86, 0xe4, 0x18, 0x46, 0x69, 0x5b, 0x8d, 0xb5, 0xe5,
	0x30, 0x06, 0x42, 0x44, 0x6b, 0xe7, 0xc1, 0x81, 0xd5, 0xf1, 0x36, 0x53, 0xe4, 0x1a, 0x54, 0xe1,
	0x6c, 0xc1, 0x9b, 0x12, 0xfe, 0xc9, 0x0e, 0xf8, 0xd8, 0xd9, 0x62, 0x1f, 0x8b, 0x8d, 0x0c, 0xb1,
	0x81, 0x70, 0x74, 0xfd, 0x78, 0x13, 0x0e, 0x12, 0x6e, 0xee, 0x80, 0x5b, 0xa9, 0x70, 0x13, 0xaf,
	0xf2, 0xad, 0x5c, 0xda, 0x99, 0x19, 0x8f, 0x9c, 0x4d, 0x7e, 0x6b, 0xaf, 0xce, 0x3c, 0xe3, 0x91,
	0xb3, 0xd5, 0x99, 0xd9, 0x66, 0x8a, 0x0c, 0xe1, 0x34, 0x64, 0xb6, 0xe0, 0xf4, 0xe6, 0xc6, 0x77,
	0xec, 0x95, 0x47, 0xda, 0xbb, 0x36, 0xfb, 0x24, 0x64, 0xe3, 0x4c, 0x34, 0xcc, 0x35, 0xfa, 0x4b,
	0xa8, 0xbf, 0xa0, 0x8b, 0x80, 0x51, 0x97, 0xbc, 0x0f, 0x35, 0x81, 0x3f, 0x67, 0x66, 0x6d, 0xf6,
	0x9b, 0xa9, 0x9f, 0x6a, 0xbc, 0x72, 0xa6, 0x0c, 0x0e, 0x2c, 0x79, 0x41, 0x34, 0x38, 0x9a, 0xfa,
	0x21, 0xe5, 0x0b, 0xe9, 0xc6, 0xf6, 0xe0, 0xc0, 0xca, 0xcf, 0x7d, 0x15, 0xea, 0x51, 0x4e, 0x39,
	0xfc, 0xfd, 0xf5, 0x5d, 0x55, 0xd1, 0xef, 0x2a, 0xd0, 0xd9, 0x9a, 0x31, 0x21, 0x50, 0xf3, 0x58,
	0x9c, 0x17, 0xb0, 0x64, 0x4c, 0xde, 0x83, 0x5a, 0x44, 0x85, 0x27, 0x89, 0xeb, 0x45, 0x2d, 0x99,
	0x26, 0x9f, 0x43, 0x2d, 0xc6, 0xd0, 0xcd, 0x4d, 0xfb, 0xd1, 0x8e, 0xd6, 0xe5, 0x7f, 0x62, 0x49,
	0x0d, 0xf9, 0x12, 0xea, 0x1c, 0x1d, 0xf4, 0xe7, 0x98, 0x7b, 0x75, 0x5f, 0x79, 0x21, 0x23, 0x1f,
	0x40, 0x3b, 0x46, 0x3e, 0xf7, 0x1d, 0xb4, 0x43, 0x7a, 0x8b, 0xd2, 0xa5, 0x4d, 0xab, 0x95, 0xe7,
	0x46, 0xf4, 0x16, 0xc9, 0x35, 0xbc, 0xc3, 0xf1, 0xc7, 0x04, 0x63, 0x91, 0xce, 0xda, 0x45, 0x1e,
	0xdb, 0x82, 0xd9, 0xd4, 0x75, 0xb5, 0xa3, 0xb3, 0xea, 0xa3, 0x56, 0xef, 0xfc, 0xbf, 0x6b, 0xba,
	0xc8, 0xa5, 0xa7, 0xae, 0x22, 0x39, 0x98, 0xd3, 0x9c, 0x91, 0xdd, 0xc4, 0x63, 0x76, 0xe1, 0xba,
	0xfa, 0x2f, 0x0a, 0x1c, 0x6f, 0x6e, 0xf2, 0xaa, 0x1d, 0xca, 0x9b, 0xb5, 0xa3, 0x22, 0x9f, 0x76,
	0xdf, 0x76, 0xe8, 0xe7, 0xa0, 0x6e, 0x2f, 0x3f, 0x51, 0xa1, 0xfa, 0x0a, 0x17, 0xf9, 0x48, 0xd3,
	0x50, 0xff, 0x14, 0x3a, 0x5b, 0x2b, 0x5c, 0xea, 0xa3, 0x52, 0xea, 0x63, 0xff, 0x01, 0x1c, 0xaf,
	0x7b, 0x05, 0x79, 0xbe, 0x48, 0x1f, 0x5b, 0xd0, 0xce, 0x50, 0xdf, 0x0a, 0x2a, 0x92, 0x98, 0xb4,
	0xa0, 0x3e, 0x19, 0x7d, 0x3d, 0xba, 0xfa, 0x6e, 0xa4, 0x1e, 0xa4, 0x87, 0xc1, 0xe5, 0xc5, 0x37,
	0xe3, 0xc1, 0xb5, 0xaa, 0x90, 0xb7, 0xa0, 0x39, 0x19, 0x15, 0xc7, 0x0a, 0x69, 0x43, 0xe3, 0xa9,
	0x75, 0x31, 0x1c, 0x0d, 0x47, 0xcf, 0xd4, 0x6a, 0xfa, 0xe5, 0x78, 0xf8, 0xfc, 0xf2, 0x6a, 0x32,
	0x56, 0x6b, 0x7d, 0xf5, 0xd7, 0x65, 0x57, 0xf9, 0x73, 0xd9, 0x55, 0xfe, 0x5a, 0x76, 0x95, 0x7f,
	0x96, 0x5d, 0x65, 0x7a, 0x24, 0xcd, 0xf2, 0xf8, 0xdf, 0x00, 0x00, 0x00, 0xff, 0xff, 0x20, 0xa4,
	0xdc, 0x40, 0x8a, 0x07, 0x00, 0x00,
}
